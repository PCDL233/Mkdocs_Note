
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="CMQ233">
      
      
        <link rel="canonical" href="https://PCDL233.github.io/Mkdocs_Note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/Algorithm/">
      
      
        <link rel="prev" href="../../%E7%BA%BF%E6%80%A7%E8%A1%A8/%E9%A1%BA%E5%BA%8F%E8%A1%A8/">
      
      
        <link rel="next" href="../DataStructure/">
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-9.1.2">
    
    
      
        <title>-1 - CMQNote</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.7bf56d0a.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.a0c5b2b5.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../css/extra.css">
    
      <link rel="stylesheet" href="../../css/video.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="light-blue" data-md-color-accent="light-blue">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="CMQNote" class="md-header__button md-logo" aria-label="CMQNote" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            CMQNote
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              -1
            
          </span>
        </div>
      </div>
    </div>
    
      <form class="md-header__option" data-md-component="palette">
        
          
          <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="light-blue" data-md-color-accent="light-blue"  aria-label="切换至夜间模式"  type="radio" name="__palette" id="__palette_1">
          
            <label class="md-header__button md-icon" title="切换至夜间模式" for="__palette_2" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
            </label>
          
        
          
          <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="cyan"  aria-label="切换至日间模式"  type="radio" name="__palette" id="__palette_2">
          
            <label class="md-header__button md-icon" title="切换至日间模式" for="__palette_1" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
            </label>
          
        
      </form>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="分享" aria-label="分享" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/PCDL233/Mkdocs_Note" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    Mkdocs_Note.github.io
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="md-tabs__link">
        学习
      </a>
    </li>
  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../c%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%EF%BC%9A/" class="md-tabs__link">
        C语言
      </a>
    </li>
  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../c%2B%2B/C%2B%2B%20%E4%B8%ADstring%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95%EF%BC%9A/" class="md-tabs__link">
        c++
      </a>
    </li>
  

      
        
  
  
    
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="../../%E7%BA%BF%E6%80%A7%E8%A1%A8/dataStructure_day01/" class="md-tabs__link md-tabs__link--active">
        数据结构学习
      </a>
    </li>
  

  

      
        
  
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="../../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C/%E6%95%B0%E6%8D%AE%E5%AE%9E%E9%AA%8C_%E5%AD%A6%E7%94%9F%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%BA%E5%BA%8F%E8%A1%A8/" class="md-tabs__link">
        数据结构实验
      </a>
    </li>
  

  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../sortAlgorithm/bubbleSort/" class="md-tabs__link">
        排序算法
      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="CMQNote" class="md-nav__button md-logo" aria-label="CMQNote" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    CMQNote
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/PCDL233/Mkdocs_Note" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    Mkdocs_Note.github.io
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
        
      
      <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_1" >
      
      
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1" id="__nav_1_label" tabindex="0">
          学习
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          学习
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="md-nav__link">
        JavaScript
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BD%91%E7%AB%99/" class="md-nav__link">
        算法可视化学习网站
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
        
      
      <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2" >
      
      
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
          C语言
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          C语言
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../c%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%EF%BC%9A/" class="md-nav__link">
        排序方法
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../c%E8%AF%AD%E8%A8%80/c%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E9%80%92%E5%BD%92/" class="md-nav__link">
        递归
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../c%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%EF%BC%9A/" class="md-nav__link">
        字符串函数
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../c%E8%AF%AD%E8%A8%80/%E6%9E%9A%E4%B8%BE%E6%B3%95%EF%BC%88%E7%A9%B7%E4%B8%BE%E6%B3%95%EF%BC%89/" class="md-nav__link">
        穷举法
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
        
      
      <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_3" >
      
      
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
          c++
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          c++
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../c%2B%2B/C%2B%2B%20%E4%B8%ADstring%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95%EF%BC%9A/" class="md-nav__link">
        string
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../c%2B%2B/C%2B%2B%20%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88STL%EF%BC%89/" class="md-nav__link">
        c++标准模板(STL)
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" checked>
      
      
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
          数据结构学习
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="true">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          数据结构学习
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
        
      
      <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_4_1" >
      
      
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_4_1" id="__nav_4_1_label" tabindex="0">
          线性表
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_1">
          <span class="md-nav__icon md-icon"></span>
          线性表
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%BA%BF%E6%80%A7%E8%A1%A8/dataStructure_day01/" class="md-nav__link">
        1
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%BA%BF%E6%80%A7%E8%A1%A8/dataStructure_day02/" class="md-nav__link">
        2
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%BA%BF%E6%80%A7%E8%A1%A8/dataStructure_day03/" class="md-nav__link">
        3
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/" class="md-nav__link">
        单链表
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%BA%BF%E6%80%A7%E8%A1%A8/%E9%A1%BA%E5%BA%8F%E8%A1%A8/" class="md-nav__link">
        顺序表
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_2" checked>
      
      
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_4_2" id="__nav_4_2_label" tabindex="0">
          数据结构代码实现
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_2_label" aria-expanded="true">
        <label class="md-nav__title" for="__nav_4_2">
          <span class="md-nav__icon md-icon"></span>
          数据结构代码实现
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          -1
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        -1
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    查找和排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    查找表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    线性表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    顺序查找
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    算法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    算法分析
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    如何提高查找效率
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    顺序查找特点
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#binary-search" class="md-nav__link">
    折半查找(Binary Search)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-" class="md-nav__link">
    算法分析--判断树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    折半查找特点
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#blocking-search" class="md-nav__link">
    分块查找(Blocking Search)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    算法分析
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    分块查找特点
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    线性表查找方法比较
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    树表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#binary-sort-tree" class="md-nav__link">
    二叉排序树(Binary Sort Tree)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    数据类型定义
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    复习：递归创建二叉树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bst" class="md-nav__link">
    BST查找
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bst_1" class="md-nav__link">
    BST查找算法分分析
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bst_2" class="md-nav__link">
    BST插入
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bst_3" class="md-nav__link">
    创建BST
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bst_4" class="md-nav__link">
    BST删除
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#avlbalance-binary-tree" class="md-nav__link">
    AVL树(Balance Binary Tree)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ll" class="md-nav__link">
    LL型旋转(右旋转)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rr" class="md-nav__link">
    RR旋转(左旋转)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lr" class="md-nav__link">
    LR旋转(左右旋转)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rl" class="md-nav__link">
    RL旋转(右左旋转)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    总结
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    代码实现
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#llrr" class="md-nav__link">
    左旋转和右旋转(参照LL，RR旋转)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    左平衡和右平衡
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    插入节点和及时平衡
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    测试代码
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hash-table" class="md-nav__link">
    哈希表(Hash Table)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hash" class="md-nav__link">
    hash函数的构造方法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    处理冲突的方法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hash-table_1" class="md-nav__link">
    除留余数法构造Hash Table
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    查找效率分析
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    几点结论
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    查找总结
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    直接插入排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#binary-insert-sort" class="md-nav__link">
    折半插入排序(Binary Insert Sort)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shells-sort" class="md-nav__link">
    希尔排序(Shell's Sort)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    交换排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    冒泡排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    快速排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    选则排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    堆
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    堆定义
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    定理1:
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    定理2:
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    初始化堆
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    堆调整
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    堆排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    其他类型排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#merge-sort" class="md-nav__link">
    并归排序 Merge Sort
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    合并两个有序序列
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    分割序列并进行合并
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    函数封装
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    算法效率
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    基数排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    数据类型定义
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    分配函数
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    收集函数
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_45" class="md-nav__link">
    排序函数
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_46" class="md-nav__link">
    初始化和输出函数
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_47" class="md-nav__link">
    算法效率
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_48" class="md-nav__link">
    排序总结
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_49" class="md-nav__link">
    查找和排序
  </a>
  
    <nav class="md-nav" aria-label="查找和排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_50" class="md-nav__link">
    查找表
  </a>
  
    <nav class="md-nav" aria-label="查找表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_51" class="md-nav__link">
    关键字
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_52" class="md-nav__link">
    主关键字：可唯一标识一个记录的关键字
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_53" class="md-nav__link">
    次关键字：用以识别若干记录的关键字
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_54" class="md-nav__link">
    查找表分类
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_55" class="md-nav__link">
    线性表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_56" class="md-nav__link">
    树表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_57" class="md-nav__link">
    哈希表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_58" class="md-nav__link">
    动态和静态
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_59" class="md-nav__link">
    静态：仅作查询，检索
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_60" class="md-nav__link">
    动态：作插入和删除操作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aslaverage-search-length" class="md-nav__link">
    平均查找长度ASL(Average Search Length)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_61" class="md-nav__link">
    关键字的平均比较次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_62" class="md-nav__link">
    记录的个数表长
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_63" class="md-nav__link">
    查找第个元素的概率
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_64" class="md-nav__link">
    查找到第个元素需要的比较次数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_65" class="md-nav__link">
    线性表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_66" class="md-nav__link">
    顺序查找
  </a>
  
    <nav class="md-nav" aria-label="顺序查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_67" class="md-nav__link">
    应用范围
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_68" class="md-nav__link">
    顺序表或线性链表的静态查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_69" class="md-nav__link">
    表内元素无序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_70" class="md-nav__link">
    类型定义:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_71" class="md-nav__link">
    算法
  </a>
  
    <nav class="md-nav" aria-label="算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#base-0-0" class="md-nav__link">
    思路:把base数组中 0 号位置预留出来，从最后一个元素出发，依此向 0 号方向比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#i0-key-stbasei" class="md-nav__link">
    可发现此算法中一次循环 i&gt;0; 和 key == ST.base[i] 比较了两次
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_72" class="md-nav__link">
    其他形式：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#i0-stbaseikey-key" class="md-nav__link">
    i&gt;0 &amp;&amp; ST.base[i].key != key 同样的比较了两次
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_73" class="md-nav__link">
    优化算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0-guard" class="md-nav__link">
    为数组中 0 号位置添加guard
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stbaseikey-key" class="md-nav__link">
    可发现循环中 ST.base[i].key!= key; 只比较一次
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_74" class="md-nav__link">
    算法分析
  </a>
  
    <nav class="md-nav" aria-label="算法分析">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_75" class="md-nav__link">
    观察此图，发现想查到第个位置，需要 次比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_76" class="md-nav__link">
    查找失败则需要 次比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_77" class="md-nav__link">
    令
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_78" class="md-nav__link">
    所以
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_79" class="md-nav__link">
    时间复杂度：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_80" class="md-nav__link">
    空间复杂度需要额外的数组中 号位置
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_81" class="md-nav__link">
    如何提高查找效率
  </a>
  
    <nav class="md-nav" aria-label="如何提高查找效率">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    1. 按查找概率高低存储
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_82" class="md-nav__link">
    查找概率高，比较次数少
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_83" class="md-nav__link">
    查找概率低，比较次数多
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_1" class="md-nav__link">
    2. 当查找概率无法确定时
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_84" class="md-nav__link">
    按查找概率动态调整
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#key" class="md-nav__link">
    在每个key中增设一个访问频度域
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_85" class="md-nav__link">
    始终保持频度域按非递增，有序的次序排列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#key_1" class="md-nav__link">
    每次查找后，讲刚查到的key数据移至表头
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_86" class="md-nav__link">
    顺序查找特点
  </a>
  
    <nav class="md-nav" aria-label="顺序查找特点">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_87" class="md-nav__link">
    优点：算法简单，逻辑次序无要求，不同存储结构均适用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asl" class="md-nav__link">
    缺点：ASL太长，时间效率低
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#binary-search_1" class="md-nav__link">
    折半查找(Binary Search)
  </a>
  
    <nav class="md-nav" aria-label="折半查找(Binary Search)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_88" class="md-nav__link">
    前置条件：集合中的元素按递增的顺序排列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_89" class="md-nav__link">
    方法：每次将集合中的元素缩小一半
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lowhighleftright" class="md-nav__link">
    需要变量 low,high或left,right
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lowhigh" class="md-nav__link">
    由图可知，如果查找的元素不在集合中，那么最终的结果为 low&gt;high,即循环的条件为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_1" class="md-nav__link">
    算法分析--判断树
  </a>
  
    <nav class="md-nav" aria-label="算法分析--判断树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_90" class="md-nav__link">
    二叉树性质
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_91" class="md-nav__link">
    节点数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_92" class="md-nav__link">
    高度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_93" class="md-nav__link">
    第 层节点个数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_94" class="md-nav__link">
    可以把该搜索过程抽象成一颗二叉树，在数组中的位置表示节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_95" class="md-nav__link">
    可以看出该二叉树的 为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_96" class="md-nav__link">
    那么该二叉树的节点数为 即
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_97" class="md-nav__link">
    由此可见，找到元素所在位置经过的路径就是需要的比较次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lowhigh_1" class="md-nav__link">
    方形节点代表着外部节点，如果到达方形节点则表示查找失败，即 low&gt;high
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_98" class="md-nav__link">
    为了方便讨论，设一个数组中有 个元素
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_99" class="md-nav__link">
    令每个元素找到的概率相等
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_100" class="md-nav__link">
    转化成高度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_101" class="md-nav__link">
    推导
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_102" class="md-nav__link">
    假设有 则有数列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_103" class="md-nav__link">
    令 则有数列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_104" class="md-nav__link">
    由 可知
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_105" class="md-nav__link">
    折半查找特点
  </a>
  
    <nav class="md-nav" aria-label="折半查找特点">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_106" class="md-nav__link">
    优点：效率比顺序查找高
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_107" class="md-nav__link">
    缺点：只适用于有序表，且仅限于顺序存储结构(对链表无效)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#blocking-search_1" class="md-nav__link">
    分块查找(Blocking Search)
  </a>
  
    <nav class="md-nav" aria-label="分块查找(Blocking Search)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_108" class="md-nav__link">
    将表分为几块，并且分块有序，块内可以无序，如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_109" class="md-nav__link">
    把所有抽象成一个数组，数组内元素是最大关键字，对块进行折半查找，对块内进行顺序查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_110" class="md-nav__link">
    数据类型定义：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_111" class="md-nav__link">
    算法实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_112" class="md-nav__link">
    测试案例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_113" class="md-nav__link">
    算法分析
  </a>
  
    <nav class="md-nav" aria-label="算法分析">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_114" class="md-nav__link">
    为对 进行的折半查找， 为对块内进行的顺序查找， 为每一块内元素个数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_115" class="md-nav__link">
    例如当 时
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_116" class="md-nav__link">
    折半查找为 顺序查找为
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_117" class="md-nav__link">
    分块查找特点
  </a>
  
    <nav class="md-nav" aria-label="分块查找特点">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_118" class="md-nav__link">
    优点：插入和删除比较容易，无需进行大量移动
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#indextable" class="md-nav__link">
    缺点：要增加一个indextable数组(索引表)的储存空间并对初始索引进行排序运算
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_119" class="md-nav__link">
    使用情况：如果线性表要快速查找且又经常动态变化，则可采用分块查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_120" class="md-nav__link">
    顺序查找 折半查找 分块查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asl_1" class="md-nav__link">
    ASL 最大 最小 适中
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ok" class="md-nav__link">
    结构 有序表，无需表OK 仅有序表 分块有序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ok-no-ok" class="md-nav__link">
    存储结构 循序表，链表OK 链表NO 顺序表，链表OK
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_121" class="md-nav__link">
    线性表查找方法比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_122" class="md-nav__link">
    树表
  </a>
  
    <nav class="md-nav" aria-label="树表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_123" class="md-nav__link">
    当表插入，删除操作频繁时，为维护表的有序性，需要移动表中很多记录，有一种方法就是改用动态
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_2" class="md-nav__link">
    查找表--树表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#keykey" class="md-nav__link">
    对于给定的key值，若表中存在则成功返回，若不存在则插入一个等于key值的记录
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_124" class="md-nav__link">
    树表分为：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_125" class="md-nav__link">
    二叉排序树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_126" class="md-nav__link">
    平衡二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_127" class="md-nav__link">
    红黑树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b-" class="md-nav__link">
    B-树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b" class="md-nav__link">
    B+树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_128" class="md-nav__link">
    建树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_129" class="md-nav__link">
    此笔记暂时只记录 二叉排序树 和 平衡二叉树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#binary-sort-tree_1" class="md-nav__link">
    二叉排序树(Binary Sort Tree)
  </a>
  
    <nav class="md-nav" aria-label="二叉排序树(Binary Sort Tree)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_130" class="md-nav__link">
    定义：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_131" class="md-nav__link">
    若其左子树非空，则左子树上所有节点的值均小于根节点的值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_132" class="md-nav__link">
    若其右子树非空，则右子树上所有节点的值均大于等于根节点的值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_133" class="md-nav__link">
    其左右子树本身又是一颗二叉排序树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_134" class="md-nav__link">
    如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_135" class="md-nav__link">
    如果中序遍历非空二叉排序树，所得到的元素数据序列是一个递增有序数列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_136" class="md-nav__link">
    数据类型定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_137" class="md-nav__link">
    复习：递归创建二叉树
  </a>
  
    <nav class="md-nav" aria-label="复习：递归创建二叉树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pre-orderpost-orderin-order" class="md-nav__link">
    可以按照Pre-order或Post-order创建二叉树，但是无法按照In-order创建。
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#prepostin-order" class="md-nav__link">
    这是因为在Pre和Post中连续的虚空节点可以确定唯一的叶子节点，但是In-order不能。
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bst_5" class="md-nav__link">
    BST查找
  </a>
  
    <nav class="md-nav" aria-label="BST查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_138" class="md-nav__link">
    若关键字等于根节点，成功
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_139" class="md-nav__link">
    否则：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_140" class="md-nav__link">
    若小于根节点，查其左子树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_141" class="md-nav__link">
    若大于等于根节点，查起右子树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_142" class="md-nav__link">
    依此递归
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bst_6" class="md-nav__link">
    BST查找算法分分析
  </a>
  
    <nav class="md-nav" aria-label="BST查找算法分分析">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bst_7" class="md-nav__link">
    BST查找算法类似于折半查找，每个节点的比较次数和所在层次有关，所及
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n" class="md-nav__link">
    含有n个节点的二叉排序树的平均查找长度与此二叉树的形态有关，如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asl_2" class="md-nav__link">
    节点数一样，但ASL显然不同
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_143" class="md-nav__link">
    的 折半查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_144" class="md-nav__link">
    的 顺序查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_145" class="md-nav__link">
    所以说在创建二叉排序树的时候，尽量要让此二叉树形状均匀
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bst_8" class="md-nav__link">
    BST插入
  </a>
  
    <nav class="md-nav" aria-label="BST插入">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bst_9" class="md-nav__link">
    BST插入算法和线性表的插入算法不同，不需要具体位置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_146" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bst_10" class="md-nav__link">
    创建BST
  </a>
  
    <nav class="md-nav" aria-label="创建BST">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#t" class="md-nav__link">
    若从一颗空树T出发，依次插入节点，那么可以创建一个二叉排序树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_147" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_148" class="md-nav__link">
    如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_149" class="md-nav__link">
    注意：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_150" class="md-nav__link">
    不同序列产生的二叉排序树的形态不一样
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#45-24-53-12-90-12-24-45-90-53" class="md-nav__link">
    45 24 53 12 90(如上图)和 12 24 45 90 53(如下图)中序遍历的顺序一样，但是形态不一样
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_151" class="md-nav__link">
    已知插入的 为 ，一共有个节点则需要 次循环
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_152" class="md-nav__link">
    所以创建时间效率为
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bst_11" class="md-nav__link">
    BST删除
  </a>
  
    <nav class="md-nav" aria-label="BST删除">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bst_12" class="md-nav__link">
    从BST删除一个节点，不能把以该节点为根的子树都删除，只能删除该节点，并且还要保证删除后的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bst_13" class="md-nav__link">
    二叉树仍然为BST
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bst_14" class="md-nav__link">
    BST的删除操作分为三种情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ppfpf" class="md-nav__link">
    令被删除节点的地址为p，p的双亲结点为f且p为f的左孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pf-lchild-null" class="md-nav__link">
    当p为叶子节点时，f-&gt;lchild = NULL;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pf-lchild-p-lchild-f-lchild-p-rchild" class="md-nav__link">
    当p只有一个左子树或右子树时，f-&gt;lchild = p-&gt;lchild; 或 f-&gt;lchild = p-&gt;rchild;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p" class="md-nav__link">
    当p拥有左右子树时,此种情况较为复杂，需要具体分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mmm" class="md-nav__link">
    前置知识，若已知一个二叉排序树的节点m，m的直接前驱节点为m的左子树上右分支最后一个右孩
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_153" class="md-nav__link">
    子为空的节点，如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nnmn" class="md-nav__link">
    由图可知，n没有右孩子(如果n一旦有了有孩子，那么m的直接前驱必然会发生变化)，但n可以有左孩
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nm" class="md-nav__link">
    子(即使有左孩子也并不影响n是m的直接前驱)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n_1" class="md-nav__link">
    同时也要考虑n的左子树没有右分支的情况，如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nmn" class="md-nav__link">
    由图可知，如果n没有右分支，那么m的直接前驱为n
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#m" class="md-nav__link">
    利用对称性可知直接后继节点则为：m的右子树上左分支上最后一个左孩子为空的节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_154" class="md-nav__link">
    考虑下图：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_155" class="md-nav__link">
    中序遍历所得到的序列为:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p-sp-p-s" class="md-nav__link">
    由图可知 P 的直接前驱为 S，如果把序列中P删除并且 P 的数据用 S 代替
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#q-" class="md-nav__link">
    此时 变成了 的直接前驱为 的右子树上的左分支最后一个左孩子为空的节点为 即 Q-
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_156" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#avlbalance-binary-tree_1" class="md-nav__link">
    AVL树(Balance Binary Tree)
  </a>
  
    <nav class="md-nav" aria-label="AVL树(Balance Binary Tree)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#avl" class="md-nav__link">
    平衡二叉树排序树(AVL树)：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_157" class="md-nav__link">
    需要满足如下的三个性质:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_158" class="md-nav__link">
    有一个树 ，令 的左子树的高度为 ，右子树高度为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_159" class="md-nav__link">
    平衡因子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_160" class="md-nav__link">
    的左右子树也为平衡二叉排序树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_161" class="md-nav__link">
    如果插入节点使得
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_162" class="md-nav__link">
    则必须旋转 为 的节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_2" class="md-nav__link">
    定理 1 ：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_163" class="md-nav__link">
    若一个 树 在添加一个节点 后， 则 的双亲结点 的 不能为 叶子节点除外
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_164" class="md-nav__link">
    令一颗 树 在添加一个节点 后 ，且 的双亲节点 的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_165" class="md-nav__link">
    若删去 节点，则 的高度并未发生变化，且 未发生变化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_166" class="md-nav__link">
    即 说明 在添加 节点之前不是 树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_167" class="md-nav__link">
    不是一颗 树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ll_1" class="md-nav__link">
    LL型旋转(右旋转)
  </a>
  
    <nav class="md-nav" aria-label="LL型旋转(右旋转)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_168" class="md-nav__link">
    情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_169" class="md-nav__link">
    且 ，以 的左孩子 为中心，向右旋转
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_170" class="md-nav__link">
    如下图 为插入节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_2" class="md-nav__link">
    定理 2
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_171" class="md-nav__link">
    即将进行 旋转的树 ， 且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_172" class="md-nav__link">
    则旋转后
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_173" class="md-nav__link">
    情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_174" class="md-nav__link">
    且 以 的左孩子 为中心向右旋转，此时 成为 的左孩子， 称成为 的左孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_175" class="md-nav__link">
    则 节点脱落 使 成为 的右孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_176" class="md-nav__link">
    如下图 为插入节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    定理 3
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_177" class="md-nav__link">
    即将进行 旋转的树 ， 且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_178" class="md-nav__link">
    则旋转后
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rr_1" class="md-nav__link">
    RR旋转(左旋转)
  </a>
  
    <nav class="md-nav" aria-label="RR旋转(左旋转)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_179" class="md-nav__link">
    情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_180" class="md-nav__link">
    且 ，以 的右孩子 为中心，向左旋转
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_181" class="md-nav__link">
    如下图 为插入节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    定理 4
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_182" class="md-nav__link">
    即将进行 旋转的树 ， 且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_183" class="md-nav__link">
    则旋转后
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_184" class="md-nav__link">
    情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_185" class="md-nav__link">
    且 以 的右孩子 为中心向左旋转，此时 成为 的右孩子， 称成为 的左孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_186" class="md-nav__link">
    则 节点脱落使 成为 的右孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_187" class="md-nav__link">
    如下图 为插入节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    定理 5
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_188" class="md-nav__link">
    即将进行 旋转的树 ， 且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_189" class="md-nav__link">
    则旋转后
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lr_1" class="md-nav__link">
    LR旋转(左右旋转)
  </a>
  
    <nav class="md-nav" aria-label="LR旋转(左右旋转)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_190" class="md-nav__link">
    情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_191" class="md-nav__link">
    即将进行旋转的树 且 ，则 旋转 ，再 旋转
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_192" class="md-nav__link">
    如下图， 为插入节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6" class="md-nav__link">
    定理 6
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_193" class="md-nav__link">
    即将进行 旋转的树 ， 且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_194" class="md-nav__link">
    则 旋转后
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_195" class="md-nav__link">
    情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_196" class="md-nav__link">
    节点 有右孩子 ，即
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_197" class="md-nav__link">
    即将进行旋转的树 且 ，则 旋转 节点脱落，再 旋转 ，使 成为 的左孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_198" class="md-nav__link">
    如下图， 为插入节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7" class="md-nav__link">
    定理 7
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_199" class="md-nav__link">
    即将进行 旋转的树 ， 且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_200" class="md-nav__link">
    则 旋转后
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_201" class="md-nav__link">
    情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_202" class="md-nav__link">
    节点 有左孩子 ，即
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_203" class="md-nav__link">
    即将进行 旋转的树 且 ，则 旋转 节点脱落，再 旋转 ，使 成为 的有孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_204" class="md-nav__link">
    如下图， 为插入节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8" class="md-nav__link">
    定理 8
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_205" class="md-nav__link">
    即将进行 旋转的树 ， 且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_206" class="md-nav__link">
    则 旋转后
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rl_1" class="md-nav__link">
    RL旋转(右左旋转)
  </a>
  
    <nav class="md-nav" aria-label="RL旋转(右左旋转)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_207" class="md-nav__link">
    情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_208" class="md-nav__link">
    即将进行 旋转的树 且 ，则 旋转 ，再 旋转
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_209" class="md-nav__link">
    如下图， 为插入节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#9" class="md-nav__link">
    定理 9
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_210" class="md-nav__link">
    即将进行 旋转的树 ， 且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_211" class="md-nav__link">
    则 旋转后
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_212" class="md-nav__link">
    情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_213" class="md-nav__link">
    节点 有左孩子 ，即
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_214" class="md-nav__link">
    即将进行 旋转的树 且 ，则 旋转 节点脱落，再 旋转 ，使 成为 的左孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_215" class="md-nav__link">
    如下图， 为插入节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#10" class="md-nav__link">
    定理 10
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_216" class="md-nav__link">
    即将进行 旋转的树 ， 且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_217" class="md-nav__link">
    则 旋转后
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_218" class="md-nav__link">
    情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_219" class="md-nav__link">
    节点 有右孩子 ，即
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_220" class="md-nav__link">
    即将进行 旋转的树 且 ，则 旋转 节点脱落，再 旋转 ，使 成为 的左孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_221" class="md-nav__link">
    如下图， 为插入节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    定理 11
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_222" class="md-nav__link">
    即将进行 旋转的树 ， 且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_223" class="md-nav__link">
    则 旋转后
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_224" class="md-nav__link">
    总结
  </a>
  
    <nav class="md-nav" aria-label="总结">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_225" class="md-nav__link">
    如果一个 树 参入一个节点使得 的某个子树的 ，则需要对该子树进行旋转
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_226" class="md-nav__link">
    令这颗子树为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_227" class="md-nav__link">
    如果 ，且 的左子树 为 ，则对 进行 旋转
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_228" class="md-nav__link">
    如果 ，且 的左子树 为 ，则对 进行 旋转
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_229" class="md-nav__link">
    如果 ，且 的左子树 为 ，则对 进行 旋转
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_230" class="md-nav__link">
    如果 ，且 的左子树 为 ，则对 进行 旋转
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_231" class="md-nav__link">
    代码实现
  </a>
  
    <nav class="md-nav" aria-label="代码实现">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_232" class="md-nav__link">
    数据类型：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#llrr_1" class="md-nav__link">
    左旋转和右旋转(参照LL，RR旋转)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_233" class="md-nav__link">
    左旋转树 代表着：以 的右孩子为中心，向左旋转
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_234" class="md-nav__link">
    右旋转树 代表着：以 的左孩子为中心，向右旋转
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_235" class="md-nav__link">
    左平衡和右平衡
  </a>
  
    <nav class="md-nav" aria-label="左平衡和右平衡">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lllrrrrl" class="md-nav__link">
    根据总结可知，大体上可以分成左平衡(LL,LR)和右平衡(RR,RL)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_236" class="md-nav__link">
    左平衡
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_237" class="md-nav__link">
    右平衡
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_238" class="md-nav__link">
    插入节点和及时平衡
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_239" class="md-nav__link">
    测试代码
  </a>
  
    <nav class="md-nav" aria-label="测试代码">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#output" class="md-nav__link">
    output:
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hash-table_2" class="md-nav__link">
    哈希表(Hash Table)
  </a>
  
    <nav class="md-nav" aria-label="哈希表(Hash Table)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_240" class="md-nav__link">
    记录存储位置与关键字之间存在对应关系
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_241" class="md-nav__link">
    用 表示
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_242" class="md-nav__link">
    优点：查找效率高
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_243" class="md-nav__link">
    缺点：空间效率低
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hash_1" class="md-nav__link">
    冲突：通过Hash函数，不同的关键字映射到同一个地址上
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hash_2" class="md-nav__link">
    hash函数的构造方法
  </a>
  
    <nav class="md-nav" aria-label="hash函数的构造方法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_244" class="md-nav__link">
    需要考虑的因素：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_245" class="md-nav__link">
    执行速度(计算时间)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_246" class="md-nav__link">
    关键字长度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hash-table_3" class="md-nav__link">
    Hash Table的大小
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_247" class="md-nav__link">
    关键字的分布情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_248" class="md-nav__link">
    朝朝频率
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_249" class="md-nav__link">
    主要构造方法 ：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_250" class="md-nav__link">
    直接定址法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_251" class="md-nav__link">
    数字分析法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_252" class="md-nav__link">
    平方取中法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_253" class="md-nav__link">
    折叠法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_254" class="md-nav__link">
    除留余数法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_255" class="md-nav__link">
    随机数法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_256" class="md-nav__link">
    直接定址法 ：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#key_2" class="md-nav__link">
    优点：以关键字key的某个线性函数值为散列地址，不会产生冲突
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_257" class="md-nav__link">
    缺点：要占用连续地址空间，空间效率低
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_258" class="md-nav__link">
    例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_259" class="md-nav__link">
    散列函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_260" class="md-nav__link">
    处理冲突的方法
  </a>
  
    <nav class="md-nav" aria-label="处理冲突的方法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_261" class="md-nav__link">
    除留余数法：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_262" class="md-nav__link">
    为增量序列 表长，且 是个 质数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_263" class="md-nav__link">
    开放定址法 ：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_264" class="md-nav__link">
    基本思想：有冲突时就去寻找下一个空的散列地址，只要表足够大，总能找到空的地址
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_265" class="md-nav__link">
    常用方法：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_266" class="md-nav__link">
    线性探测法 为 ， ， ，
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_267" class="md-nav__link">
    二次探测法 为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_268" class="md-nav__link">
    伪随机数探测法 为伪随机数数列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_269" class="md-nav__link">
    链地址法：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_270" class="md-nav__link">
    基本思想，相同散列地址的记录链成一单链表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_271" class="md-nav__link">
    例：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_272" class="md-nav__link">
    已知一组关键字为 令
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_273" class="md-nav__link">
    链地址法的优点：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_274" class="md-nav__link">
    非同义词不会冲突，无聚集现象
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_275" class="md-nav__link">
    链表上空间动态申请，更适用于表长不确定的情况
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hash-table_4" class="md-nav__link">
    除留余数法构造Hash Table
  </a>
  
    <nav class="md-nav" aria-label="除留余数法构造Hash Table">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_276" class="md-nav__link">
    类型定义：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_277" class="md-nav__link">
    初始化并构造：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_278" class="md-nav__link">
    搜索：
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_279" class="md-nav__link">
    查找效率分析
  </a>
  
    <nav class="md-nav" aria-label="查找效率分析">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#hash-tableasl" class="md-nav__link">
    Hash Table的ASL取决于：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_280" class="md-nav__link">
    散列函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_281" class="md-nav__link">
    处理冲突的方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_282" class="md-nav__link">
    散列表的装填因子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_283" class="md-nav__link">
    表中元素个数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_284" class="md-nav__link">
    表长 越接近 说明发生冲突的可能性越大
  </a>
  
    <nav class="md-nav" aria-label="表长 越接近 说明发生冲突的可能性越大">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#hash-table_5" class="md-nav__link">
    所以说Hash Table的查找效率 既不是 也不是
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_285" class="md-nav__link">
    顺序查找 折半查找 分块查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_286" class="md-nav__link">
    时间
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_287" class="md-nav__link">
    复杂
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_288" class="md-nav__link">
    度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_289" class="md-nav__link">
    与确定所在块的查找方法有关
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_290" class="md-nav__link">
    特点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_291" class="md-nav__link">
    算法简单，对结构无要
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_292" class="md-nav__link">
    求，效率底
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_293" class="md-nav__link">
    对表结构有要求，效
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_294" class="md-nav__link">
    率高
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_295" class="md-nav__link">
    对结构有一定要求，效率介于顺
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_296" class="md-nav__link">
    序查找和折半查找之间
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_297" class="md-nav__link">
    适用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_298" class="md-nav__link">
    情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_299" class="md-nav__link">
    任何结构的线性表，不
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_300" class="md-nav__link">
    经常做插入和删除
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_301" class="md-nav__link">
    有序的顺序表，不经
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_302" class="md-nav__link">
    常做插入和删除
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_303" class="md-nav__link">
    块间有序，块内无序的循序表，
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_304" class="md-nav__link">
    经常做插入和删除
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_305" class="md-nav__link">
    折半查找 二叉排序树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_306" class="md-nav__link">
    时间复
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_307" class="md-nav__link">
    杂度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_308" class="md-nav__link">
    特点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_309" class="md-nav__link">
    有序的顺序表，插入和删除需要移动
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_310" class="md-nav__link">
    大量元素
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_311" class="md-nav__link">
    用二叉链表，插入和删除无需移动元素，只
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_312" class="md-nav__link">
    需修改指针
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_313" class="md-nav__link">
    适用情
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_314" class="md-nav__link">
    况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_315" class="md-nav__link">
    不经常插入删除 经常插入和删除
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_316" class="md-nav__link">
    拉链法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_317" class="md-nav__link">
    线性探测法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_318" class="md-nav__link">
    随机探测法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_319" class="md-nav__link">
    几点结论
  </a>
  
    <nav class="md-nav" aria-label="几点结论">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_320" class="md-nav__link">
    散列表技术具有很好的平均性能，优于一些传统技术
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_321" class="md-nav__link">
    链地址法优于开地址法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_322" class="md-nav__link">
    除留余数法作散列函数优于其他类型函数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_323" class="md-nav__link">
    查找总结
  </a>
  
    <nav class="md-nav" aria-label="查找总结">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_324" class="md-nav__link">
    顺序查找，折半查找，分块查找比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_325" class="md-nav__link">
    折半查找和二叉排序树比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_326" class="md-nav__link">
    哈希表:开地址法和链地址法比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_327" class="md-nav__link">
    开地址法 链地址法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_328" class="md-nav__link">
    空间 无指针域，存储效率高 附加指针域
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_329" class="md-nav__link">
    时间复杂度 有二次聚集现象，查找效率低 无二次聚集现象，查找效率高
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_330" class="md-nav__link">
    插入删除 不易实现 易于实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_331" class="md-nav__link">
    适用情况 表的大小固定，适用于表长无变化 节点动态生成，适用于表长经常变化
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_332" class="md-nav__link">
    排序
  </a>
  
    <nav class="md-nav" aria-label="排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_333" class="md-nav__link">
    排序方法的分类：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_334" class="md-nav__link">
    按数据存储介质：内部排序和外部排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_335" class="md-nav__link">
    内部排序：数据量不大，数据在内存，无需内外存交换数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_336" class="md-nav__link">
    外部排序：数据量较大，数据在外存(文件排序)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_337" class="md-nav__link">
    外部排序时，要将数据分批调入内存来排序，中间结果还要及时存入外存
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_338" class="md-nav__link">
    按比较器个数：串行排序和并行排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_339" class="md-nav__link">
    串行排序：单处理机(同一时刻比较一对元素)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_340" class="md-nav__link">
    并行排序：多处理机(同一时刻比较多对元素)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_341" class="md-nav__link">
    按主要操作：比较排序和基数排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_342" class="md-nav__link">
    比较排序：用比较的方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_343" class="md-nav__link">
    基数排序：仅仅根据数据本身的取值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_344" class="md-nav__link">
    按辅助空间排序：原地排序和非原地排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_345" class="md-nav__link">
    原地排序：辅助空间为 的排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_346" class="md-nav__link">
    非原地排序：辅助空间大于 的排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_347" class="md-nav__link">
    按稳定性：稳定排序和非稳定排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_348" class="md-nav__link">
    稳定排序：任何数值相等的元素，排序以后相对次序不变
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_349" class="md-nav__link">
    排序方法是否稳定，并不能衡量一个排序算法的优劣
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_350" class="md-nav__link">
    按自然性：自然排序和非自然排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_351" class="md-nav__link">
    自然排序：输入数据越有序，排序的速度越快
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_352" class="md-nav__link">
    排序类型定义：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_353" class="md-nav__link">
    直接插入排序
  </a>
  
    <nav class="md-nav" aria-label="直接插入排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_354" class="md-nav__link">
    若有 个元素需要进行排序，令 到 为有序表非递减， 元素与该有序表比较，插入到适当位置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_355" class="md-nav__link">
    为有序表只有一个元素， 与该有序表比较，进行插入，此时有序表变成 到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_356" class="md-nav__link">
    依此进行插入
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_357" class="md-nav__link">
    此时 到 为非递减序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_358" class="md-nav__link">
    代码实现：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_359" class="md-nav__link">
    测试代码：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_360" class="md-nav__link">
    性能分析：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_361" class="md-nav__link">
    最坏情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_362" class="md-nav__link">
    比较的次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_363" class="md-nav__link">
    移动的次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_364" class="md-nav__link">
    平均情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_365" class="md-nav__link">
    比较次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_366" class="md-nav__link">
    移动次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_367" class="md-nav__link">
    最坏情况下
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_368" class="md-nav__link">
    平均
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#binary-insert-sort_1" class="md-nav__link">
    折半插入排序(Binary Insert Sort)
  </a>
  
    <nav class="md-nav" aria-label="折半插入排序(Binary Insert Sort)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#right1" class="md-nav__link">
    在直接插入排序的基础上，对已经排序好的有序表进行折半操作，随着折半的进行，right+1就是插入
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_369" class="md-nav__link">
    的位置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_370" class="md-nav__link">
    折半插入性能：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_371" class="md-nav__link">
    时间复杂度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_372" class="md-nav__link">
    空间复杂度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_373" class="md-nav__link">
    是一种稳定排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_374" class="md-nav__link">
    直接插入和折半插入的比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_375" class="md-nav__link">
    折半插入的比较次数和待排序序列的初始排列无关，仅依赖序列元素个数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_376" class="md-nav__link">
    折半插入减少了比较次数，但是没有减少移动次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_377" class="md-nav__link">
    折半插入平均性能优于直接插入排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_378" class="md-nav__link">
    直接插入在基本有序时，效率更高
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shells-sort_1" class="md-nav__link">
    希尔排序(Shell's Sort)
  </a>
  
    <nav class="md-nav" aria-label="希尔排序(Shell's Sort)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_379" class="md-nav__link">
    希尔排序思路
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_380" class="md-nav__link">
    增量序列 并且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_381" class="md-nav__link">
    对每个 进行间隔插入排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_382" class="md-nav__link">
    例如
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_383" class="md-nav__link">
    则依此对将要排序的序列进行间隔为 ， ， 的直接插入排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_384" class="md-nav__link">
    希尔排序特点：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_385" class="md-nav__link">
    移动位置较大，跳跃式地接近排序后的最终位置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_386" class="md-nav__link">
    最后一次只需要少量移动
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_3" class="md-nav__link">
    增量序列必须是递减的，最后一个必须是 1
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_387" class="md-nav__link">
    增量序列必须是互质的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_388" class="md-nav__link">
    代码实现：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_389" class="md-nav__link">
    测试代码：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_390" class="md-nav__link">
    效率分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_391" class="md-nav__link">
    增量序列 ，相邻元素互质
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_392" class="md-nav__link">
    最坏情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_393" class="md-nav__link">
    猜想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_394" class="md-nav__link">
    增量序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_395" class="md-nav__link">
    或
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_396" class="md-nav__link">
    猜想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_397" class="md-nav__link">
    最坏情况
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_398" class="md-nav__link">
    交换排序
  </a>
  
    <nav class="md-nav" aria-label="交换排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_399" class="md-nav__link">
    冒泡排序
  </a>
  
    <nav class="md-nav" aria-label="冒泡排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_400" class="md-nav__link">
    冒泡排序算法效率分析：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_401" class="md-nav__link">
    最好情况正序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_402" class="md-nav__link">
    比较次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_403" class="md-nav__link">
    移动次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_404" class="md-nav__link">
    最坏情况逆序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_405" class="md-nav__link">
    比较次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_406" class="md-nav__link">
    移动次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_407" class="md-nav__link">
    综上
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_408" class="md-nav__link">
    冒泡排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_409" class="md-nav__link">
    最好
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_410" class="md-nav__link">
    最坏
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_411" class="md-nav__link">
    平均
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_412" class="md-nav__link">
    需要辅助空间一个
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_413" class="md-nav__link">
    冒泡排序是稳定的
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_414" class="md-nav__link">
    快速排序
  </a>
  
    <nav class="md-nav" aria-label="快速排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_415" class="md-nav__link">
    基本思路：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_416" class="md-nav__link">
    选取序列 中第一个元素 作为 ，依此扫描序列，如果 小于 则排在 后面，反之排在前面
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_417" class="md-nav__link">
    此时以 为中心，序列被分成两个子序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_418" class="md-nav__link">
    依此对 进行取 操作，以此类推直到 中只有一个元素，此时 为有序序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_419" class="md-nav__link">
    代码实现:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_420" class="md-nav__link">
    快速排序算法效率：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_421" class="md-nav__link">
    平均效率为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_422" class="md-nav__link">
    快速排序不是原地排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_423" class="md-nav__link">
    需要借助递归来实现，调用栈
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_424" class="md-nav__link">
    平均情况下需要 的栈空间
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_425" class="md-nav__link">
    最快情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_426" class="md-nav__link">
    快速排序不是一种稳定排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_427" class="md-nav__link">
    若对 或 进行快速排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_428" class="md-nav__link">
    以 为中心，必然有一侧的子序列个数为 ，那么此时退化成冒泡排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_429" class="md-nav__link">
    所以快速排序不适用于原本有序或基本有序的序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_430" class="md-nav__link">
    总结
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_431" class="md-nav__link">
    的选取直接影响快排性能
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_432" class="md-nav__link">
    数据次序越乱，快排越快，效率越高
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_433" class="md-nav__link">
    快速排序不是自然排序方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_434" class="md-nav__link">
    改变 的选取方法，至多只能改变算法平均情况下的效率，无法改变最快情况下的效率
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_435" class="md-nav__link">
    即最坏情况
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_436" class="md-nav__link">
    选则排序
  </a>
  
    <nav class="md-nav" aria-label="选则排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_437" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_438" class="md-nav__link">
    算法效率分析:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_439" class="md-nav__link">
    时间复杂度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_440" class="md-nav__link">
    记录移动次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_441" class="md-nav__link">
    最好情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_442" class="md-nav__link">
    最坏情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_443" class="md-nav__link">
    比较次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_444" class="md-nav__link">
    无论待排序处于什么状态，选则排序所需进行的比较次数都相同
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_445" class="md-nav__link">
    算法特点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_446" class="md-nav__link">
    就选则排序本身来讲，是一种稳定的排序方法，稳定取决于是否在在比较时加入等号
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_447" class="md-nav__link">
    可用于链式存储结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_448" class="md-nav__link">
    移动记录次数较少，当每一记录占用空间较多时，此方法比直接插入排序块
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_449" class="md-nav__link">
    堆
  </a>
  
    <nav class="md-nav" aria-label="堆">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_450" class="md-nav__link">
    堆定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_451" class="md-nav__link">
    若 个元素的序列为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_452" class="md-nav__link">
    满足如下条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_453" class="md-nav__link">
    小根堆或 大根堆
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_454" class="md-nav__link">
    从上述定义可知，堆实质上就是一个完全二叉树 二叉树中任意非叶子节点均小于大于它的孩子节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_455" class="md-nav__link">
    如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_4" class="md-nav__link">
    定理1:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_456" class="md-nav__link">
    若有数列 有 个元素，若按照按下标 存入一颗树中，则此颗树为完全二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_3" class="md-nav__link">
    定理2:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_457" class="md-nav__link">
    若有数列 有 个元素，若按照按下标 存入一颗完全二叉树中，令
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_458" class="md-nav__link">
    为堆
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_459" class="md-nav__link">
    根据完全二叉树的性质可知 为序号最大的非叶子节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_460" class="md-nav__link">
    叶子节点本身为堆，所以 到 为堆
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_461" class="md-nav__link">
    初始化堆
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_462" class="md-nav__link">
    若在输出堆顶的最小值最大之后，使剩余 个元素的序列重新组成一个堆
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_463" class="md-nav__link">
    则得到 个元素中的次小值次大值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_464" class="md-nav__link">
    对 执行如上操作，得到一个有序序列，此过程为堆排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_465" class="md-nav__link">
    堆调整
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_466" class="md-nav__link">
    根据定理 可知， 到 为堆，那么只需要判断到 是否为堆
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_467" class="md-nav__link">
    如果 到 不为堆，选取 和 交换，此时 为堆
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_468" class="md-nav__link">
    但是交换了 和 ，无法保证交换后的序列是否为堆，所以还要继续调整
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_469" class="md-nav__link">
    令 继续调整，直到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_470" class="md-nav__link">
    堆排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_471" class="md-nav__link">
    堆初始化虽然完成并且有序，但是 到 并不是有序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_472" class="md-nav__link">
    此时堆顶元素为 交换堆顶元素和 号元素
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_473" class="md-nav__link">
    并且对 到 进行堆调整，此时 号元素为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_474" class="md-nav__link">
    依此类推，继续交换堆顶和 ，并对 到 进行堆调整
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_475" class="md-nav__link">
    直到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_476" class="md-nav__link">
    堆排序算法效率分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_477" class="md-nav__link">
    初始化堆
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_478" class="md-nav__link">
    交换堆顶元素和 元素，并重新堆调整
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_479" class="md-nav__link">
    所以堆排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_480" class="md-nav__link">
    具体推导过程在书中第二版 页
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_481" class="md-nav__link">
    堆排序的特点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_482" class="md-nav__link">
    不是稳定排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_483" class="md-nav__link">
    只能用于顺序结构，不能用于链式结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_484" class="md-nav__link">
    堆排序在最坏情况下时间复杂度也为 ，无论待排序序列是正序还是逆序都一样
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_485" class="md-nav__link">
    初始化堆时，需要比较的次数较多，因此记录较少时不宜采用。堆排序在最坏情况下 ，
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_486" class="md-nav__link">
    相对于快速排序最坏情况 而言是一个优点，当记录较多时效率高
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_487" class="md-nav__link">
    其他类型排序
  </a>
  
    <nav class="md-nav" aria-label="其他类型排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#merge-sort_1" class="md-nav__link">
    并归排序 Merge Sort
  </a>
  
    <nav class="md-nav" aria-label="并归排序 Merge Sort">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_488" class="md-nav__link">
    基本思想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_489" class="md-nav__link">
    若有序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_490" class="md-nav__link">
    其中 为非递减序列 也为非递减序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_491" class="md-nav__link">
    依此比较 取较小值放入新建序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_492" class="md-nav__link">
    依此类推得到的序列 为有序序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_493" class="md-nav__link">
    但是如果一个杂乱无章的序列应该如何应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_494" class="md-nav__link">
    若有序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_495" class="md-nav__link">
    依此对该序列进行二分，直到获得只有一个元素的子序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_496" class="md-nav__link">
    如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_497" class="md-nav__link">
    比较 和 较小值放入 充当 ，较大值则充当 ，此时 为有序序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_498" class="md-nav__link">
    按照此方法递归，可以得到有序序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_499" class="md-nav__link">
    例子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_500" class="md-nav__link">
    实现代码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_501" class="md-nav__link">
    合并两个有序序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_502" class="md-nav__link">
    分割序列并进行合并
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_503" class="md-nav__link">
    函数封装
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_504" class="md-nav__link">
    算法效率
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_505" class="md-nav__link">
    时间复杂度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_506" class="md-nav__link">
    空间复杂度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_507" class="md-nav__link">
    是稳定排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_508" class="md-nav__link">
    可以用于链式存储结构，且不需要附加存储空间，但递归的实现仍要需要开辟相应的工作栈
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_509" class="md-nav__link">
    基数排序
  </a>
  
    <nav class="md-nav" aria-label="基数排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_510" class="md-nav__link">
    前面的算法都是基于比较，而基数排序则不需要比较，通过关键字中的信息进行分类，进行 分配 和 采
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_511" class="md-nav__link">
    集 来实现排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_512" class="md-nav__link">
    如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_513" class="md-nav__link">
    先按照个位排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_514" class="md-nav__link">
    再按照十位排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_515" class="md-nav__link">
    再按百位排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_516" class="md-nav__link">
    数据类型定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_1" class="md-nav__link">
    采用静态链表来对 3 位数字排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_517" class="md-nav__link">
    分配函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_518" class="md-nav__link">
    收集函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_519" class="md-nav__link">
    排序函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_520" class="md-nav__link">
    初始化和输出函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_521" class="md-nav__link">
    排序方法 最好情况 最坏情况 平均情况 空间复杂度 稳定性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_522" class="md-nav__link">
    直接插入排序 稳定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_523" class="md-nav__link">
    折半插入排序 稳定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_524" class="md-nav__link">
    希尔排序 不稳定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_525" class="md-nav__link">
    冒泡排序 稳定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_526" class="md-nav__link">
    简单选择排序 稳定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_527" class="md-nav__link">
    快速排序 不稳定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_528" class="md-nav__link">
    堆排序 不稳定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_529" class="md-nav__link">
    归并排序 稳定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_530" class="md-nav__link">
    基数排序 稳定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_531" class="md-nav__link">
    算法效率
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_532" class="md-nav__link">
    令基数为 有 个记录，每个记录含有 个关键字，则分配需要 ，收集则需要
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_533" class="md-nav__link">
    所以
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_534" class="md-nav__link">
    需要两个长度为 的 数组，且还增加了个 个 元素
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_535" class="md-nav__link">
    所以空间复杂度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_536" class="md-nav__link">
    算法特点：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_537" class="md-nav__link">
    稳定排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_538" class="md-nav__link">
    可用于链式存储结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_539" class="md-nav__link">
    只要基数选取合适，时间复杂度是线性的可以达到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_540" class="md-nav__link">
    有严格的使用要求：需要直到各级关键字的主次关系和取值范围
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_541" class="md-nav__link">
    排序总结
  </a>
  
    <nav class="md-nav" aria-label="排序总结">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_542" class="md-nav__link">
    按照时间性能来区分：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_543" class="md-nav__link">
    有 快速排序，归并排序，堆排序，其中快速排序最好
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_544" class="md-nav__link">
    有 直接插入排序，冒泡排序，简单选择排序，其中直接插入最好
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_545" class="md-nav__link">
    特别是对于关键字近似有序的记录
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_546" class="md-nav__link">
    只有 基数排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_547" class="md-nav__link">
    当待排记录有序时，直接插入排序和冒泡排序能达到 ，而对于快速排序而言，这是最不好的情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_548" class="md-nav__link">
    此时快速排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_549" class="md-nav__link">
    简单选则排序，堆排序，归并排序的效率并不能根据关键字的分布而改变
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_550" class="md-nav__link">
    按空间性能来区分
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_551" class="md-nav__link">
    所有简单排序方法直接插入，冒泡，简单选择排序和堆排序为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_552" class="md-nav__link">
    快速排序为 需要借助栈
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_553" class="md-nav__link">
    归并排序需要辅助空间最多，
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_554" class="md-nav__link">
    链式基数排序需要 ， 数组和 变量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_555" class="md-nav__link">
    按稳定性来区分
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_556" class="md-nav__link">
    快速排序和堆排序不是稳定的方法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../DataStructure/" class="md-nav__link">
        -2
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
        
      
      <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_5" >
      
      
        
          
        
      
      
        <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
          数据结构实验
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          数据结构实验
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
        
      
      <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_5_1" >
      
      
        
          
        
      
      
        <label class="md-nav__link" for="__nav_5_1" id="__nav_5_1_label" tabindex="0">
          顺序表
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5_1">
          <span class="md-nav__icon md-icon"></span>
          顺序表
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C/%E6%95%B0%E6%8D%AE%E5%AE%9E%E9%AA%8C_%E5%AD%A6%E7%94%9F%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%BA%E5%BA%8F%E8%A1%A8/" class="md-nav__link">
        学生通讯录
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
        
      
      <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_6" >
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
          排序算法
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          排序算法
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sortAlgorithm/bubbleSort/" class="md-nav__link">
        冒泡排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sortAlgorithm/countingSort/" class="md-nav__link">
        计数排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sortAlgorithm/heapSort/" class="md-nav__link">
        堆排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sortAlgorithm/insertionSort/" class="md-nav__link">
        插入排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sortAlgorithm/mergeSort/" class="md-nav__link">
        归并排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sortAlgorithm/quickSort/" class="md-nav__link">
        快速排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sortAlgorithm/selectionSort/" class="md-nav__link">
        选择排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sortAlgorithm/shellSort/" class="md-nav__link">
        希尔排序
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    查找和排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    查找表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    线性表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    顺序查找
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    算法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    算法分析
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    如何提高查找效率
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    顺序查找特点
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#binary-search" class="md-nav__link">
    折半查找(Binary Search)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-" class="md-nav__link">
    算法分析--判断树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    折半查找特点
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#blocking-search" class="md-nav__link">
    分块查找(Blocking Search)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    算法分析
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    分块查找特点
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    线性表查找方法比较
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    树表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#binary-sort-tree" class="md-nav__link">
    二叉排序树(Binary Sort Tree)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    数据类型定义
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    复习：递归创建二叉树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bst" class="md-nav__link">
    BST查找
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bst_1" class="md-nav__link">
    BST查找算法分分析
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bst_2" class="md-nav__link">
    BST插入
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bst_3" class="md-nav__link">
    创建BST
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bst_4" class="md-nav__link">
    BST删除
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#avlbalance-binary-tree" class="md-nav__link">
    AVL树(Balance Binary Tree)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ll" class="md-nav__link">
    LL型旋转(右旋转)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rr" class="md-nav__link">
    RR旋转(左旋转)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lr" class="md-nav__link">
    LR旋转(左右旋转)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rl" class="md-nav__link">
    RL旋转(右左旋转)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    总结
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    代码实现
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#llrr" class="md-nav__link">
    左旋转和右旋转(参照LL，RR旋转)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    左平衡和右平衡
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    插入节点和及时平衡
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    测试代码
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hash-table" class="md-nav__link">
    哈希表(Hash Table)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hash" class="md-nav__link">
    hash函数的构造方法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    处理冲突的方法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hash-table_1" class="md-nav__link">
    除留余数法构造Hash Table
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    查找效率分析
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    几点结论
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    查找总结
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    直接插入排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#binary-insert-sort" class="md-nav__link">
    折半插入排序(Binary Insert Sort)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shells-sort" class="md-nav__link">
    希尔排序(Shell's Sort)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    交换排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    冒泡排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    快速排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    选则排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    堆
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    堆定义
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    定理1:
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    定理2:
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    初始化堆
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    堆调整
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    堆排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    其他类型排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#merge-sort" class="md-nav__link">
    并归排序 Merge Sort
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    合并两个有序序列
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    分割序列并进行合并
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    函数封装
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    算法效率
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    基数排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    数据类型定义
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    分配函数
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    收集函数
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_45" class="md-nav__link">
    排序函数
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_46" class="md-nav__link">
    初始化和输出函数
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_47" class="md-nav__link">
    算法效率
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_48" class="md-nav__link">
    排序总结
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_49" class="md-nav__link">
    查找和排序
  </a>
  
    <nav class="md-nav" aria-label="查找和排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_50" class="md-nav__link">
    查找表
  </a>
  
    <nav class="md-nav" aria-label="查找表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_51" class="md-nav__link">
    关键字
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_52" class="md-nav__link">
    主关键字：可唯一标识一个记录的关键字
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_53" class="md-nav__link">
    次关键字：用以识别若干记录的关键字
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_54" class="md-nav__link">
    查找表分类
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_55" class="md-nav__link">
    线性表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_56" class="md-nav__link">
    树表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_57" class="md-nav__link">
    哈希表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_58" class="md-nav__link">
    动态和静态
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_59" class="md-nav__link">
    静态：仅作查询，检索
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_60" class="md-nav__link">
    动态：作插入和删除操作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aslaverage-search-length" class="md-nav__link">
    平均查找长度ASL(Average Search Length)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_61" class="md-nav__link">
    关键字的平均比较次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_62" class="md-nav__link">
    记录的个数表长
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_63" class="md-nav__link">
    查找第个元素的概率
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_64" class="md-nav__link">
    查找到第个元素需要的比较次数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_65" class="md-nav__link">
    线性表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_66" class="md-nav__link">
    顺序查找
  </a>
  
    <nav class="md-nav" aria-label="顺序查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_67" class="md-nav__link">
    应用范围
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_68" class="md-nav__link">
    顺序表或线性链表的静态查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_69" class="md-nav__link">
    表内元素无序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_70" class="md-nav__link">
    类型定义:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_71" class="md-nav__link">
    算法
  </a>
  
    <nav class="md-nav" aria-label="算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#base-0-0" class="md-nav__link">
    思路:把base数组中 0 号位置预留出来，从最后一个元素出发，依此向 0 号方向比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#i0-key-stbasei" class="md-nav__link">
    可发现此算法中一次循环 i&gt;0; 和 key == ST.base[i] 比较了两次
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_72" class="md-nav__link">
    其他形式：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#i0-stbaseikey-key" class="md-nav__link">
    i&gt;0 &amp;&amp; ST.base[i].key != key 同样的比较了两次
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_73" class="md-nav__link">
    优化算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0-guard" class="md-nav__link">
    为数组中 0 号位置添加guard
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stbaseikey-key" class="md-nav__link">
    可发现循环中 ST.base[i].key!= key; 只比较一次
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_74" class="md-nav__link">
    算法分析
  </a>
  
    <nav class="md-nav" aria-label="算法分析">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_75" class="md-nav__link">
    观察此图，发现想查到第个位置，需要 次比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_76" class="md-nav__link">
    查找失败则需要 次比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_77" class="md-nav__link">
    令
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_78" class="md-nav__link">
    所以
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_79" class="md-nav__link">
    时间复杂度：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_80" class="md-nav__link">
    空间复杂度需要额外的数组中 号位置
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_81" class="md-nav__link">
    如何提高查找效率
  </a>
  
    <nav class="md-nav" aria-label="如何提高查找效率">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    1. 按查找概率高低存储
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_82" class="md-nav__link">
    查找概率高，比较次数少
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_83" class="md-nav__link">
    查找概率低，比较次数多
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_1" class="md-nav__link">
    2. 当查找概率无法确定时
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_84" class="md-nav__link">
    按查找概率动态调整
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#key" class="md-nav__link">
    在每个key中增设一个访问频度域
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_85" class="md-nav__link">
    始终保持频度域按非递增，有序的次序排列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#key_1" class="md-nav__link">
    每次查找后，讲刚查到的key数据移至表头
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_86" class="md-nav__link">
    顺序查找特点
  </a>
  
    <nav class="md-nav" aria-label="顺序查找特点">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_87" class="md-nav__link">
    优点：算法简单，逻辑次序无要求，不同存储结构均适用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asl" class="md-nav__link">
    缺点：ASL太长，时间效率低
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#binary-search_1" class="md-nav__link">
    折半查找(Binary Search)
  </a>
  
    <nav class="md-nav" aria-label="折半查找(Binary Search)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_88" class="md-nav__link">
    前置条件：集合中的元素按递增的顺序排列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_89" class="md-nav__link">
    方法：每次将集合中的元素缩小一半
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lowhighleftright" class="md-nav__link">
    需要变量 low,high或left,right
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lowhigh" class="md-nav__link">
    由图可知，如果查找的元素不在集合中，那么最终的结果为 low&gt;high,即循环的条件为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_1" class="md-nav__link">
    算法分析--判断树
  </a>
  
    <nav class="md-nav" aria-label="算法分析--判断树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_90" class="md-nav__link">
    二叉树性质
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_91" class="md-nav__link">
    节点数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_92" class="md-nav__link">
    高度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_93" class="md-nav__link">
    第 层节点个数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_94" class="md-nav__link">
    可以把该搜索过程抽象成一颗二叉树，在数组中的位置表示节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_95" class="md-nav__link">
    可以看出该二叉树的 为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_96" class="md-nav__link">
    那么该二叉树的节点数为 即
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_97" class="md-nav__link">
    由此可见，找到元素所在位置经过的路径就是需要的比较次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lowhigh_1" class="md-nav__link">
    方形节点代表着外部节点，如果到达方形节点则表示查找失败，即 low&gt;high
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_98" class="md-nav__link">
    为了方便讨论，设一个数组中有 个元素
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_99" class="md-nav__link">
    令每个元素找到的概率相等
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_100" class="md-nav__link">
    转化成高度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_101" class="md-nav__link">
    推导
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_102" class="md-nav__link">
    假设有 则有数列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_103" class="md-nav__link">
    令 则有数列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_104" class="md-nav__link">
    由 可知
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_105" class="md-nav__link">
    折半查找特点
  </a>
  
    <nav class="md-nav" aria-label="折半查找特点">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_106" class="md-nav__link">
    优点：效率比顺序查找高
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_107" class="md-nav__link">
    缺点：只适用于有序表，且仅限于顺序存储结构(对链表无效)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#blocking-search_1" class="md-nav__link">
    分块查找(Blocking Search)
  </a>
  
    <nav class="md-nav" aria-label="分块查找(Blocking Search)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_108" class="md-nav__link">
    将表分为几块，并且分块有序，块内可以无序，如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_109" class="md-nav__link">
    把所有抽象成一个数组，数组内元素是最大关键字，对块进行折半查找，对块内进行顺序查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_110" class="md-nav__link">
    数据类型定义：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_111" class="md-nav__link">
    算法实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_112" class="md-nav__link">
    测试案例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_113" class="md-nav__link">
    算法分析
  </a>
  
    <nav class="md-nav" aria-label="算法分析">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_114" class="md-nav__link">
    为对 进行的折半查找， 为对块内进行的顺序查找， 为每一块内元素个数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_115" class="md-nav__link">
    例如当 时
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_116" class="md-nav__link">
    折半查找为 顺序查找为
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_117" class="md-nav__link">
    分块查找特点
  </a>
  
    <nav class="md-nav" aria-label="分块查找特点">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_118" class="md-nav__link">
    优点：插入和删除比较容易，无需进行大量移动
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#indextable" class="md-nav__link">
    缺点：要增加一个indextable数组(索引表)的储存空间并对初始索引进行排序运算
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_119" class="md-nav__link">
    使用情况：如果线性表要快速查找且又经常动态变化，则可采用分块查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_120" class="md-nav__link">
    顺序查找 折半查找 分块查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asl_1" class="md-nav__link">
    ASL 最大 最小 适中
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ok" class="md-nav__link">
    结构 有序表，无需表OK 仅有序表 分块有序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ok-no-ok" class="md-nav__link">
    存储结构 循序表，链表OK 链表NO 顺序表，链表OK
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_121" class="md-nav__link">
    线性表查找方法比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_122" class="md-nav__link">
    树表
  </a>
  
    <nav class="md-nav" aria-label="树表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_123" class="md-nav__link">
    当表插入，删除操作频繁时，为维护表的有序性，需要移动表中很多记录，有一种方法就是改用动态
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_2" class="md-nav__link">
    查找表--树表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#keykey" class="md-nav__link">
    对于给定的key值，若表中存在则成功返回，若不存在则插入一个等于key值的记录
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_124" class="md-nav__link">
    树表分为：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_125" class="md-nav__link">
    二叉排序树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_126" class="md-nav__link">
    平衡二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_127" class="md-nav__link">
    红黑树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b-" class="md-nav__link">
    B-树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b" class="md-nav__link">
    B+树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_128" class="md-nav__link">
    建树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_129" class="md-nav__link">
    此笔记暂时只记录 二叉排序树 和 平衡二叉树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#binary-sort-tree_1" class="md-nav__link">
    二叉排序树(Binary Sort Tree)
  </a>
  
    <nav class="md-nav" aria-label="二叉排序树(Binary Sort Tree)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_130" class="md-nav__link">
    定义：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_131" class="md-nav__link">
    若其左子树非空，则左子树上所有节点的值均小于根节点的值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_132" class="md-nav__link">
    若其右子树非空，则右子树上所有节点的值均大于等于根节点的值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_133" class="md-nav__link">
    其左右子树本身又是一颗二叉排序树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_134" class="md-nav__link">
    如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_135" class="md-nav__link">
    如果中序遍历非空二叉排序树，所得到的元素数据序列是一个递增有序数列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_136" class="md-nav__link">
    数据类型定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_137" class="md-nav__link">
    复习：递归创建二叉树
  </a>
  
    <nav class="md-nav" aria-label="复习：递归创建二叉树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pre-orderpost-orderin-order" class="md-nav__link">
    可以按照Pre-order或Post-order创建二叉树，但是无法按照In-order创建。
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#prepostin-order" class="md-nav__link">
    这是因为在Pre和Post中连续的虚空节点可以确定唯一的叶子节点，但是In-order不能。
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bst_5" class="md-nav__link">
    BST查找
  </a>
  
    <nav class="md-nav" aria-label="BST查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_138" class="md-nav__link">
    若关键字等于根节点，成功
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_139" class="md-nav__link">
    否则：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_140" class="md-nav__link">
    若小于根节点，查其左子树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_141" class="md-nav__link">
    若大于等于根节点，查起右子树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_142" class="md-nav__link">
    依此递归
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bst_6" class="md-nav__link">
    BST查找算法分分析
  </a>
  
    <nav class="md-nav" aria-label="BST查找算法分分析">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bst_7" class="md-nav__link">
    BST查找算法类似于折半查找，每个节点的比较次数和所在层次有关，所及
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n" class="md-nav__link">
    含有n个节点的二叉排序树的平均查找长度与此二叉树的形态有关，如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asl_2" class="md-nav__link">
    节点数一样，但ASL显然不同
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_143" class="md-nav__link">
    的 折半查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_144" class="md-nav__link">
    的 顺序查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_145" class="md-nav__link">
    所以说在创建二叉排序树的时候，尽量要让此二叉树形状均匀
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bst_8" class="md-nav__link">
    BST插入
  </a>
  
    <nav class="md-nav" aria-label="BST插入">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bst_9" class="md-nav__link">
    BST插入算法和线性表的插入算法不同，不需要具体位置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_146" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bst_10" class="md-nav__link">
    创建BST
  </a>
  
    <nav class="md-nav" aria-label="创建BST">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#t" class="md-nav__link">
    若从一颗空树T出发，依次插入节点，那么可以创建一个二叉排序树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_147" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_148" class="md-nav__link">
    如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_149" class="md-nav__link">
    注意：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_150" class="md-nav__link">
    不同序列产生的二叉排序树的形态不一样
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#45-24-53-12-90-12-24-45-90-53" class="md-nav__link">
    45 24 53 12 90(如上图)和 12 24 45 90 53(如下图)中序遍历的顺序一样，但是形态不一样
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_151" class="md-nav__link">
    已知插入的 为 ，一共有个节点则需要 次循环
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_152" class="md-nav__link">
    所以创建时间效率为
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bst_11" class="md-nav__link">
    BST删除
  </a>
  
    <nav class="md-nav" aria-label="BST删除">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bst_12" class="md-nav__link">
    从BST删除一个节点，不能把以该节点为根的子树都删除，只能删除该节点，并且还要保证删除后的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bst_13" class="md-nav__link">
    二叉树仍然为BST
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bst_14" class="md-nav__link">
    BST的删除操作分为三种情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ppfpf" class="md-nav__link">
    令被删除节点的地址为p，p的双亲结点为f且p为f的左孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pf-lchild-null" class="md-nav__link">
    当p为叶子节点时，f-&gt;lchild = NULL;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pf-lchild-p-lchild-f-lchild-p-rchild" class="md-nav__link">
    当p只有一个左子树或右子树时，f-&gt;lchild = p-&gt;lchild; 或 f-&gt;lchild = p-&gt;rchild;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p" class="md-nav__link">
    当p拥有左右子树时,此种情况较为复杂，需要具体分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mmm" class="md-nav__link">
    前置知识，若已知一个二叉排序树的节点m，m的直接前驱节点为m的左子树上右分支最后一个右孩
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_153" class="md-nav__link">
    子为空的节点，如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nnmn" class="md-nav__link">
    由图可知，n没有右孩子(如果n一旦有了有孩子，那么m的直接前驱必然会发生变化)，但n可以有左孩
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nm" class="md-nav__link">
    子(即使有左孩子也并不影响n是m的直接前驱)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n_1" class="md-nav__link">
    同时也要考虑n的左子树没有右分支的情况，如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nmn" class="md-nav__link">
    由图可知，如果n没有右分支，那么m的直接前驱为n
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#m" class="md-nav__link">
    利用对称性可知直接后继节点则为：m的右子树上左分支上最后一个左孩子为空的节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_154" class="md-nav__link">
    考虑下图：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_155" class="md-nav__link">
    中序遍历所得到的序列为:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p-sp-p-s" class="md-nav__link">
    由图可知 P 的直接前驱为 S，如果把序列中P删除并且 P 的数据用 S 代替
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#q-" class="md-nav__link">
    此时 变成了 的直接前驱为 的右子树上的左分支最后一个左孩子为空的节点为 即 Q-
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_156" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#avlbalance-binary-tree_1" class="md-nav__link">
    AVL树(Balance Binary Tree)
  </a>
  
    <nav class="md-nav" aria-label="AVL树(Balance Binary Tree)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#avl" class="md-nav__link">
    平衡二叉树排序树(AVL树)：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_157" class="md-nav__link">
    需要满足如下的三个性质:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_158" class="md-nav__link">
    有一个树 ，令 的左子树的高度为 ，右子树高度为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_159" class="md-nav__link">
    平衡因子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_160" class="md-nav__link">
    的左右子树也为平衡二叉排序树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_161" class="md-nav__link">
    如果插入节点使得
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_162" class="md-nav__link">
    则必须旋转 为 的节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_2" class="md-nav__link">
    定理 1 ：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_163" class="md-nav__link">
    若一个 树 在添加一个节点 后， 则 的双亲结点 的 不能为 叶子节点除外
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_164" class="md-nav__link">
    令一颗 树 在添加一个节点 后 ，且 的双亲节点 的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_165" class="md-nav__link">
    若删去 节点，则 的高度并未发生变化，且 未发生变化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_166" class="md-nav__link">
    即 说明 在添加 节点之前不是 树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_167" class="md-nav__link">
    不是一颗 树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ll_1" class="md-nav__link">
    LL型旋转(右旋转)
  </a>
  
    <nav class="md-nav" aria-label="LL型旋转(右旋转)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_168" class="md-nav__link">
    情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_169" class="md-nav__link">
    且 ，以 的左孩子 为中心，向右旋转
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_170" class="md-nav__link">
    如下图 为插入节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_2" class="md-nav__link">
    定理 2
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_171" class="md-nav__link">
    即将进行 旋转的树 ， 且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_172" class="md-nav__link">
    则旋转后
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_173" class="md-nav__link">
    情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_174" class="md-nav__link">
    且 以 的左孩子 为中心向右旋转，此时 成为 的左孩子， 称成为 的左孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_175" class="md-nav__link">
    则 节点脱落 使 成为 的右孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_176" class="md-nav__link">
    如下图 为插入节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    定理 3
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_177" class="md-nav__link">
    即将进行 旋转的树 ， 且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_178" class="md-nav__link">
    则旋转后
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rr_1" class="md-nav__link">
    RR旋转(左旋转)
  </a>
  
    <nav class="md-nav" aria-label="RR旋转(左旋转)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_179" class="md-nav__link">
    情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_180" class="md-nav__link">
    且 ，以 的右孩子 为中心，向左旋转
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_181" class="md-nav__link">
    如下图 为插入节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    定理 4
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_182" class="md-nav__link">
    即将进行 旋转的树 ， 且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_183" class="md-nav__link">
    则旋转后
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_184" class="md-nav__link">
    情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_185" class="md-nav__link">
    且 以 的右孩子 为中心向左旋转，此时 成为 的右孩子， 称成为 的左孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_186" class="md-nav__link">
    则 节点脱落使 成为 的右孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_187" class="md-nav__link">
    如下图 为插入节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    定理 5
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_188" class="md-nav__link">
    即将进行 旋转的树 ， 且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_189" class="md-nav__link">
    则旋转后
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lr_1" class="md-nav__link">
    LR旋转(左右旋转)
  </a>
  
    <nav class="md-nav" aria-label="LR旋转(左右旋转)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_190" class="md-nav__link">
    情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_191" class="md-nav__link">
    即将进行旋转的树 且 ，则 旋转 ，再 旋转
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_192" class="md-nav__link">
    如下图， 为插入节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6" class="md-nav__link">
    定理 6
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_193" class="md-nav__link">
    即将进行 旋转的树 ， 且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_194" class="md-nav__link">
    则 旋转后
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_195" class="md-nav__link">
    情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_196" class="md-nav__link">
    节点 有右孩子 ，即
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_197" class="md-nav__link">
    即将进行旋转的树 且 ，则 旋转 节点脱落，再 旋转 ，使 成为 的左孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_198" class="md-nav__link">
    如下图， 为插入节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7" class="md-nav__link">
    定理 7
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_199" class="md-nav__link">
    即将进行 旋转的树 ， 且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_200" class="md-nav__link">
    则 旋转后
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_201" class="md-nav__link">
    情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_202" class="md-nav__link">
    节点 有左孩子 ，即
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_203" class="md-nav__link">
    即将进行 旋转的树 且 ，则 旋转 节点脱落，再 旋转 ，使 成为 的有孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_204" class="md-nav__link">
    如下图， 为插入节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8" class="md-nav__link">
    定理 8
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_205" class="md-nav__link">
    即将进行 旋转的树 ， 且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_206" class="md-nav__link">
    则 旋转后
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rl_1" class="md-nav__link">
    RL旋转(右左旋转)
  </a>
  
    <nav class="md-nav" aria-label="RL旋转(右左旋转)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_207" class="md-nav__link">
    情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_208" class="md-nav__link">
    即将进行 旋转的树 且 ，则 旋转 ，再 旋转
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_209" class="md-nav__link">
    如下图， 为插入节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#9" class="md-nav__link">
    定理 9
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_210" class="md-nav__link">
    即将进行 旋转的树 ， 且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_211" class="md-nav__link">
    则 旋转后
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_212" class="md-nav__link">
    情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_213" class="md-nav__link">
    节点 有左孩子 ，即
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_214" class="md-nav__link">
    即将进行 旋转的树 且 ，则 旋转 节点脱落，再 旋转 ，使 成为 的左孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_215" class="md-nav__link">
    如下图， 为插入节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#10" class="md-nav__link">
    定理 10
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_216" class="md-nav__link">
    即将进行 旋转的树 ， 且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_217" class="md-nav__link">
    则 旋转后
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_218" class="md-nav__link">
    情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_219" class="md-nav__link">
    节点 有右孩子 ，即
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_220" class="md-nav__link">
    即将进行 旋转的树 且 ，则 旋转 节点脱落，再 旋转 ，使 成为 的左孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_221" class="md-nav__link">
    如下图， 为插入节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    定理 11
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_222" class="md-nav__link">
    即将进行 旋转的树 ， 且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_223" class="md-nav__link">
    则 旋转后
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_224" class="md-nav__link">
    总结
  </a>
  
    <nav class="md-nav" aria-label="总结">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_225" class="md-nav__link">
    如果一个 树 参入一个节点使得 的某个子树的 ，则需要对该子树进行旋转
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_226" class="md-nav__link">
    令这颗子树为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_227" class="md-nav__link">
    如果 ，且 的左子树 为 ，则对 进行 旋转
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_228" class="md-nav__link">
    如果 ，且 的左子树 为 ，则对 进行 旋转
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_229" class="md-nav__link">
    如果 ，且 的左子树 为 ，则对 进行 旋转
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_230" class="md-nav__link">
    如果 ，且 的左子树 为 ，则对 进行 旋转
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_231" class="md-nav__link">
    代码实现
  </a>
  
    <nav class="md-nav" aria-label="代码实现">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_232" class="md-nav__link">
    数据类型：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#llrr_1" class="md-nav__link">
    左旋转和右旋转(参照LL，RR旋转)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_233" class="md-nav__link">
    左旋转树 代表着：以 的右孩子为中心，向左旋转
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_234" class="md-nav__link">
    右旋转树 代表着：以 的左孩子为中心，向右旋转
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_235" class="md-nav__link">
    左平衡和右平衡
  </a>
  
    <nav class="md-nav" aria-label="左平衡和右平衡">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lllrrrrl" class="md-nav__link">
    根据总结可知，大体上可以分成左平衡(LL,LR)和右平衡(RR,RL)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_236" class="md-nav__link">
    左平衡
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_237" class="md-nav__link">
    右平衡
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_238" class="md-nav__link">
    插入节点和及时平衡
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_239" class="md-nav__link">
    测试代码
  </a>
  
    <nav class="md-nav" aria-label="测试代码">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#output" class="md-nav__link">
    output:
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hash-table_2" class="md-nav__link">
    哈希表(Hash Table)
  </a>
  
    <nav class="md-nav" aria-label="哈希表(Hash Table)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_240" class="md-nav__link">
    记录存储位置与关键字之间存在对应关系
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_241" class="md-nav__link">
    用 表示
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_242" class="md-nav__link">
    优点：查找效率高
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_243" class="md-nav__link">
    缺点：空间效率低
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hash_1" class="md-nav__link">
    冲突：通过Hash函数，不同的关键字映射到同一个地址上
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hash_2" class="md-nav__link">
    hash函数的构造方法
  </a>
  
    <nav class="md-nav" aria-label="hash函数的构造方法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_244" class="md-nav__link">
    需要考虑的因素：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_245" class="md-nav__link">
    执行速度(计算时间)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_246" class="md-nav__link">
    关键字长度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hash-table_3" class="md-nav__link">
    Hash Table的大小
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_247" class="md-nav__link">
    关键字的分布情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_248" class="md-nav__link">
    朝朝频率
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_249" class="md-nav__link">
    主要构造方法 ：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_250" class="md-nav__link">
    直接定址法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_251" class="md-nav__link">
    数字分析法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_252" class="md-nav__link">
    平方取中法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_253" class="md-nav__link">
    折叠法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_254" class="md-nav__link">
    除留余数法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_255" class="md-nav__link">
    随机数法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_256" class="md-nav__link">
    直接定址法 ：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#key_2" class="md-nav__link">
    优点：以关键字key的某个线性函数值为散列地址，不会产生冲突
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_257" class="md-nav__link">
    缺点：要占用连续地址空间，空间效率低
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_258" class="md-nav__link">
    例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_259" class="md-nav__link">
    散列函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_260" class="md-nav__link">
    处理冲突的方法
  </a>
  
    <nav class="md-nav" aria-label="处理冲突的方法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_261" class="md-nav__link">
    除留余数法：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_262" class="md-nav__link">
    为增量序列 表长，且 是个 质数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_263" class="md-nav__link">
    开放定址法 ：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_264" class="md-nav__link">
    基本思想：有冲突时就去寻找下一个空的散列地址，只要表足够大，总能找到空的地址
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_265" class="md-nav__link">
    常用方法：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_266" class="md-nav__link">
    线性探测法 为 ， ， ，
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_267" class="md-nav__link">
    二次探测法 为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_268" class="md-nav__link">
    伪随机数探测法 为伪随机数数列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_269" class="md-nav__link">
    链地址法：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_270" class="md-nav__link">
    基本思想，相同散列地址的记录链成一单链表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_271" class="md-nav__link">
    例：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_272" class="md-nav__link">
    已知一组关键字为 令
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_273" class="md-nav__link">
    链地址法的优点：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_274" class="md-nav__link">
    非同义词不会冲突，无聚集现象
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_275" class="md-nav__link">
    链表上空间动态申请，更适用于表长不确定的情况
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hash-table_4" class="md-nav__link">
    除留余数法构造Hash Table
  </a>
  
    <nav class="md-nav" aria-label="除留余数法构造Hash Table">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_276" class="md-nav__link">
    类型定义：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_277" class="md-nav__link">
    初始化并构造：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_278" class="md-nav__link">
    搜索：
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_279" class="md-nav__link">
    查找效率分析
  </a>
  
    <nav class="md-nav" aria-label="查找效率分析">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#hash-tableasl" class="md-nav__link">
    Hash Table的ASL取决于：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_280" class="md-nav__link">
    散列函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_281" class="md-nav__link">
    处理冲突的方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_282" class="md-nav__link">
    散列表的装填因子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_283" class="md-nav__link">
    表中元素个数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_284" class="md-nav__link">
    表长 越接近 说明发生冲突的可能性越大
  </a>
  
    <nav class="md-nav" aria-label="表长 越接近 说明发生冲突的可能性越大">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#hash-table_5" class="md-nav__link">
    所以说Hash Table的查找效率 既不是 也不是
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_285" class="md-nav__link">
    顺序查找 折半查找 分块查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_286" class="md-nav__link">
    时间
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_287" class="md-nav__link">
    复杂
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_288" class="md-nav__link">
    度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_289" class="md-nav__link">
    与确定所在块的查找方法有关
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_290" class="md-nav__link">
    特点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_291" class="md-nav__link">
    算法简单，对结构无要
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_292" class="md-nav__link">
    求，效率底
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_293" class="md-nav__link">
    对表结构有要求，效
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_294" class="md-nav__link">
    率高
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_295" class="md-nav__link">
    对结构有一定要求，效率介于顺
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_296" class="md-nav__link">
    序查找和折半查找之间
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_297" class="md-nav__link">
    适用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_298" class="md-nav__link">
    情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_299" class="md-nav__link">
    任何结构的线性表，不
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_300" class="md-nav__link">
    经常做插入和删除
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_301" class="md-nav__link">
    有序的顺序表，不经
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_302" class="md-nav__link">
    常做插入和删除
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_303" class="md-nav__link">
    块间有序，块内无序的循序表，
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_304" class="md-nav__link">
    经常做插入和删除
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_305" class="md-nav__link">
    折半查找 二叉排序树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_306" class="md-nav__link">
    时间复
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_307" class="md-nav__link">
    杂度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_308" class="md-nav__link">
    特点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_309" class="md-nav__link">
    有序的顺序表，插入和删除需要移动
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_310" class="md-nav__link">
    大量元素
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_311" class="md-nav__link">
    用二叉链表，插入和删除无需移动元素，只
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_312" class="md-nav__link">
    需修改指针
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_313" class="md-nav__link">
    适用情
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_314" class="md-nav__link">
    况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_315" class="md-nav__link">
    不经常插入删除 经常插入和删除
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_316" class="md-nav__link">
    拉链法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_317" class="md-nav__link">
    线性探测法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_318" class="md-nav__link">
    随机探测法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_319" class="md-nav__link">
    几点结论
  </a>
  
    <nav class="md-nav" aria-label="几点结论">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_320" class="md-nav__link">
    散列表技术具有很好的平均性能，优于一些传统技术
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_321" class="md-nav__link">
    链地址法优于开地址法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_322" class="md-nav__link">
    除留余数法作散列函数优于其他类型函数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_323" class="md-nav__link">
    查找总结
  </a>
  
    <nav class="md-nav" aria-label="查找总结">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_324" class="md-nav__link">
    顺序查找，折半查找，分块查找比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_325" class="md-nav__link">
    折半查找和二叉排序树比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_326" class="md-nav__link">
    哈希表:开地址法和链地址法比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_327" class="md-nav__link">
    开地址法 链地址法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_328" class="md-nav__link">
    空间 无指针域，存储效率高 附加指针域
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_329" class="md-nav__link">
    时间复杂度 有二次聚集现象，查找效率低 无二次聚集现象，查找效率高
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_330" class="md-nav__link">
    插入删除 不易实现 易于实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_331" class="md-nav__link">
    适用情况 表的大小固定，适用于表长无变化 节点动态生成，适用于表长经常变化
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_332" class="md-nav__link">
    排序
  </a>
  
    <nav class="md-nav" aria-label="排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_333" class="md-nav__link">
    排序方法的分类：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_334" class="md-nav__link">
    按数据存储介质：内部排序和外部排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_335" class="md-nav__link">
    内部排序：数据量不大，数据在内存，无需内外存交换数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_336" class="md-nav__link">
    外部排序：数据量较大，数据在外存(文件排序)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_337" class="md-nav__link">
    外部排序时，要将数据分批调入内存来排序，中间结果还要及时存入外存
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_338" class="md-nav__link">
    按比较器个数：串行排序和并行排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_339" class="md-nav__link">
    串行排序：单处理机(同一时刻比较一对元素)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_340" class="md-nav__link">
    并行排序：多处理机(同一时刻比较多对元素)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_341" class="md-nav__link">
    按主要操作：比较排序和基数排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_342" class="md-nav__link">
    比较排序：用比较的方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_343" class="md-nav__link">
    基数排序：仅仅根据数据本身的取值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_344" class="md-nav__link">
    按辅助空间排序：原地排序和非原地排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_345" class="md-nav__link">
    原地排序：辅助空间为 的排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_346" class="md-nav__link">
    非原地排序：辅助空间大于 的排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_347" class="md-nav__link">
    按稳定性：稳定排序和非稳定排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_348" class="md-nav__link">
    稳定排序：任何数值相等的元素，排序以后相对次序不变
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_349" class="md-nav__link">
    排序方法是否稳定，并不能衡量一个排序算法的优劣
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_350" class="md-nav__link">
    按自然性：自然排序和非自然排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_351" class="md-nav__link">
    自然排序：输入数据越有序，排序的速度越快
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_352" class="md-nav__link">
    排序类型定义：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_353" class="md-nav__link">
    直接插入排序
  </a>
  
    <nav class="md-nav" aria-label="直接插入排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_354" class="md-nav__link">
    若有 个元素需要进行排序，令 到 为有序表非递减， 元素与该有序表比较，插入到适当位置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_355" class="md-nav__link">
    为有序表只有一个元素， 与该有序表比较，进行插入，此时有序表变成 到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_356" class="md-nav__link">
    依此进行插入
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_357" class="md-nav__link">
    此时 到 为非递减序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_358" class="md-nav__link">
    代码实现：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_359" class="md-nav__link">
    测试代码：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_360" class="md-nav__link">
    性能分析：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_361" class="md-nav__link">
    最坏情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_362" class="md-nav__link">
    比较的次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_363" class="md-nav__link">
    移动的次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_364" class="md-nav__link">
    平均情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_365" class="md-nav__link">
    比较次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_366" class="md-nav__link">
    移动次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_367" class="md-nav__link">
    最坏情况下
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_368" class="md-nav__link">
    平均
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#binary-insert-sort_1" class="md-nav__link">
    折半插入排序(Binary Insert Sort)
  </a>
  
    <nav class="md-nav" aria-label="折半插入排序(Binary Insert Sort)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#right1" class="md-nav__link">
    在直接插入排序的基础上，对已经排序好的有序表进行折半操作，随着折半的进行，right+1就是插入
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_369" class="md-nav__link">
    的位置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_370" class="md-nav__link">
    折半插入性能：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_371" class="md-nav__link">
    时间复杂度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_372" class="md-nav__link">
    空间复杂度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_373" class="md-nav__link">
    是一种稳定排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_374" class="md-nav__link">
    直接插入和折半插入的比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_375" class="md-nav__link">
    折半插入的比较次数和待排序序列的初始排列无关，仅依赖序列元素个数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_376" class="md-nav__link">
    折半插入减少了比较次数，但是没有减少移动次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_377" class="md-nav__link">
    折半插入平均性能优于直接插入排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_378" class="md-nav__link">
    直接插入在基本有序时，效率更高
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shells-sort_1" class="md-nav__link">
    希尔排序(Shell's Sort)
  </a>
  
    <nav class="md-nav" aria-label="希尔排序(Shell's Sort)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_379" class="md-nav__link">
    希尔排序思路
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_380" class="md-nav__link">
    增量序列 并且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_381" class="md-nav__link">
    对每个 进行间隔插入排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_382" class="md-nav__link">
    例如
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_383" class="md-nav__link">
    则依此对将要排序的序列进行间隔为 ， ， 的直接插入排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_384" class="md-nav__link">
    希尔排序特点：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_385" class="md-nav__link">
    移动位置较大，跳跃式地接近排序后的最终位置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_386" class="md-nav__link">
    最后一次只需要少量移动
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_3" class="md-nav__link">
    增量序列必须是递减的，最后一个必须是 1
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_387" class="md-nav__link">
    增量序列必须是互质的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_388" class="md-nav__link">
    代码实现：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_389" class="md-nav__link">
    测试代码：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_390" class="md-nav__link">
    效率分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_391" class="md-nav__link">
    增量序列 ，相邻元素互质
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_392" class="md-nav__link">
    最坏情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_393" class="md-nav__link">
    猜想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_394" class="md-nav__link">
    增量序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_395" class="md-nav__link">
    或
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_396" class="md-nav__link">
    猜想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_397" class="md-nav__link">
    最坏情况
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_398" class="md-nav__link">
    交换排序
  </a>
  
    <nav class="md-nav" aria-label="交换排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_399" class="md-nav__link">
    冒泡排序
  </a>
  
    <nav class="md-nav" aria-label="冒泡排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_400" class="md-nav__link">
    冒泡排序算法效率分析：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_401" class="md-nav__link">
    最好情况正序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_402" class="md-nav__link">
    比较次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_403" class="md-nav__link">
    移动次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_404" class="md-nav__link">
    最坏情况逆序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_405" class="md-nav__link">
    比较次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_406" class="md-nav__link">
    移动次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_407" class="md-nav__link">
    综上
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_408" class="md-nav__link">
    冒泡排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_409" class="md-nav__link">
    最好
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_410" class="md-nav__link">
    最坏
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_411" class="md-nav__link">
    平均
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_412" class="md-nav__link">
    需要辅助空间一个
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_413" class="md-nav__link">
    冒泡排序是稳定的
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_414" class="md-nav__link">
    快速排序
  </a>
  
    <nav class="md-nav" aria-label="快速排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_415" class="md-nav__link">
    基本思路：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_416" class="md-nav__link">
    选取序列 中第一个元素 作为 ，依此扫描序列，如果 小于 则排在 后面，反之排在前面
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_417" class="md-nav__link">
    此时以 为中心，序列被分成两个子序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_418" class="md-nav__link">
    依此对 进行取 操作，以此类推直到 中只有一个元素，此时 为有序序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_419" class="md-nav__link">
    代码实现:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_420" class="md-nav__link">
    快速排序算法效率：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_421" class="md-nav__link">
    平均效率为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_422" class="md-nav__link">
    快速排序不是原地排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_423" class="md-nav__link">
    需要借助递归来实现，调用栈
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_424" class="md-nav__link">
    平均情况下需要 的栈空间
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_425" class="md-nav__link">
    最快情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_426" class="md-nav__link">
    快速排序不是一种稳定排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_427" class="md-nav__link">
    若对 或 进行快速排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_428" class="md-nav__link">
    以 为中心，必然有一侧的子序列个数为 ，那么此时退化成冒泡排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_429" class="md-nav__link">
    所以快速排序不适用于原本有序或基本有序的序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_430" class="md-nav__link">
    总结
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_431" class="md-nav__link">
    的选取直接影响快排性能
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_432" class="md-nav__link">
    数据次序越乱，快排越快，效率越高
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_433" class="md-nav__link">
    快速排序不是自然排序方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_434" class="md-nav__link">
    改变 的选取方法，至多只能改变算法平均情况下的效率，无法改变最快情况下的效率
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_435" class="md-nav__link">
    即最坏情况
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_436" class="md-nav__link">
    选则排序
  </a>
  
    <nav class="md-nav" aria-label="选则排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_437" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_438" class="md-nav__link">
    算法效率分析:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_439" class="md-nav__link">
    时间复杂度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_440" class="md-nav__link">
    记录移动次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_441" class="md-nav__link">
    最好情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_442" class="md-nav__link">
    最坏情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_443" class="md-nav__link">
    比较次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_444" class="md-nav__link">
    无论待排序处于什么状态，选则排序所需进行的比较次数都相同
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_445" class="md-nav__link">
    算法特点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_446" class="md-nav__link">
    就选则排序本身来讲，是一种稳定的排序方法，稳定取决于是否在在比较时加入等号
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_447" class="md-nav__link">
    可用于链式存储结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_448" class="md-nav__link">
    移动记录次数较少，当每一记录占用空间较多时，此方法比直接插入排序块
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_449" class="md-nav__link">
    堆
  </a>
  
    <nav class="md-nav" aria-label="堆">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_450" class="md-nav__link">
    堆定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_451" class="md-nav__link">
    若 个元素的序列为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_452" class="md-nav__link">
    满足如下条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_453" class="md-nav__link">
    小根堆或 大根堆
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_454" class="md-nav__link">
    从上述定义可知，堆实质上就是一个完全二叉树 二叉树中任意非叶子节点均小于大于它的孩子节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_455" class="md-nav__link">
    如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_4" class="md-nav__link">
    定理1:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_456" class="md-nav__link">
    若有数列 有 个元素，若按照按下标 存入一颗树中，则此颗树为完全二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_3" class="md-nav__link">
    定理2:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_457" class="md-nav__link">
    若有数列 有 个元素，若按照按下标 存入一颗完全二叉树中，令
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_458" class="md-nav__link">
    为堆
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_459" class="md-nav__link">
    根据完全二叉树的性质可知 为序号最大的非叶子节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_460" class="md-nav__link">
    叶子节点本身为堆，所以 到 为堆
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_461" class="md-nav__link">
    初始化堆
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_462" class="md-nav__link">
    若在输出堆顶的最小值最大之后，使剩余 个元素的序列重新组成一个堆
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_463" class="md-nav__link">
    则得到 个元素中的次小值次大值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_464" class="md-nav__link">
    对 执行如上操作，得到一个有序序列，此过程为堆排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_465" class="md-nav__link">
    堆调整
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_466" class="md-nav__link">
    根据定理 可知， 到 为堆，那么只需要判断到 是否为堆
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_467" class="md-nav__link">
    如果 到 不为堆，选取 和 交换，此时 为堆
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_468" class="md-nav__link">
    但是交换了 和 ，无法保证交换后的序列是否为堆，所以还要继续调整
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_469" class="md-nav__link">
    令 继续调整，直到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_470" class="md-nav__link">
    堆排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_471" class="md-nav__link">
    堆初始化虽然完成并且有序，但是 到 并不是有序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_472" class="md-nav__link">
    此时堆顶元素为 交换堆顶元素和 号元素
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_473" class="md-nav__link">
    并且对 到 进行堆调整，此时 号元素为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_474" class="md-nav__link">
    依此类推，继续交换堆顶和 ，并对 到 进行堆调整
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_475" class="md-nav__link">
    直到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_476" class="md-nav__link">
    堆排序算法效率分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_477" class="md-nav__link">
    初始化堆
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_478" class="md-nav__link">
    交换堆顶元素和 元素，并重新堆调整
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_479" class="md-nav__link">
    所以堆排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_480" class="md-nav__link">
    具体推导过程在书中第二版 页
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_481" class="md-nav__link">
    堆排序的特点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_482" class="md-nav__link">
    不是稳定排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_483" class="md-nav__link">
    只能用于顺序结构，不能用于链式结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_484" class="md-nav__link">
    堆排序在最坏情况下时间复杂度也为 ，无论待排序序列是正序还是逆序都一样
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_485" class="md-nav__link">
    初始化堆时，需要比较的次数较多，因此记录较少时不宜采用。堆排序在最坏情况下 ，
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_486" class="md-nav__link">
    相对于快速排序最坏情况 而言是一个优点，当记录较多时效率高
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_487" class="md-nav__link">
    其他类型排序
  </a>
  
    <nav class="md-nav" aria-label="其他类型排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#merge-sort_1" class="md-nav__link">
    并归排序 Merge Sort
  </a>
  
    <nav class="md-nav" aria-label="并归排序 Merge Sort">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_488" class="md-nav__link">
    基本思想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_489" class="md-nav__link">
    若有序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_490" class="md-nav__link">
    其中 为非递减序列 也为非递减序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_491" class="md-nav__link">
    依此比较 取较小值放入新建序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_492" class="md-nav__link">
    依此类推得到的序列 为有序序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_493" class="md-nav__link">
    但是如果一个杂乱无章的序列应该如何应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_494" class="md-nav__link">
    若有序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_495" class="md-nav__link">
    依此对该序列进行二分，直到获得只有一个元素的子序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_496" class="md-nav__link">
    如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_497" class="md-nav__link">
    比较 和 较小值放入 充当 ，较大值则充当 ，此时 为有序序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_498" class="md-nav__link">
    按照此方法递归，可以得到有序序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_499" class="md-nav__link">
    例子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_500" class="md-nav__link">
    实现代码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_501" class="md-nav__link">
    合并两个有序序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_502" class="md-nav__link">
    分割序列并进行合并
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_503" class="md-nav__link">
    函数封装
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_504" class="md-nav__link">
    算法效率
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_505" class="md-nav__link">
    时间复杂度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_506" class="md-nav__link">
    空间复杂度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_507" class="md-nav__link">
    是稳定排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_508" class="md-nav__link">
    可以用于链式存储结构，且不需要附加存储空间，但递归的实现仍要需要开辟相应的工作栈
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_509" class="md-nav__link">
    基数排序
  </a>
  
    <nav class="md-nav" aria-label="基数排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_510" class="md-nav__link">
    前面的算法都是基于比较，而基数排序则不需要比较，通过关键字中的信息进行分类，进行 分配 和 采
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_511" class="md-nav__link">
    集 来实现排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_512" class="md-nav__link">
    如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_513" class="md-nav__link">
    先按照个位排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_514" class="md-nav__link">
    再按照十位排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_515" class="md-nav__link">
    再按百位排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_516" class="md-nav__link">
    数据类型定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_1" class="md-nav__link">
    采用静态链表来对 3 位数字排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_517" class="md-nav__link">
    分配函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_518" class="md-nav__link">
    收集函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_519" class="md-nav__link">
    排序函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_520" class="md-nav__link">
    初始化和输出函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_521" class="md-nav__link">
    排序方法 最好情况 最坏情况 平均情况 空间复杂度 稳定性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_522" class="md-nav__link">
    直接插入排序 稳定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_523" class="md-nav__link">
    折半插入排序 稳定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_524" class="md-nav__link">
    希尔排序 不稳定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_525" class="md-nav__link">
    冒泡排序 稳定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_526" class="md-nav__link">
    简单选择排序 稳定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_527" class="md-nav__link">
    快速排序 不稳定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_528" class="md-nav__link">
    堆排序 不稳定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_529" class="md-nav__link">
    归并排序 稳定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_530" class="md-nav__link">
    基数排序 稳定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_531" class="md-nav__link">
    算法效率
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_532" class="md-nav__link">
    令基数为 有 个记录，每个记录含有 个关键字，则分配需要 ，收集则需要
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_533" class="md-nav__link">
    所以
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_534" class="md-nav__link">
    需要两个长度为 的 数组，且还增加了个 个 元素
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_535" class="md-nav__link">
    所以空间复杂度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_536" class="md-nav__link">
    算法特点：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_537" class="md-nav__link">
    稳定排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_538" class="md-nav__link">
    可用于链式存储结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_539" class="md-nav__link">
    只要基数选取合适，时间复杂度是线性的可以达到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_540" class="md-nav__link">
    有严格的使用要求：需要直到各级关键字的主次关系和取值范围
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_541" class="md-nav__link">
    排序总结
  </a>
  
    <nav class="md-nav" aria-label="排序总结">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_542" class="md-nav__link">
    按照时间性能来区分：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_543" class="md-nav__link">
    有 快速排序，归并排序，堆排序，其中快速排序最好
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_544" class="md-nav__link">
    有 直接插入排序，冒泡排序，简单选择排序，其中直接插入最好
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_545" class="md-nav__link">
    特别是对于关键字近似有序的记录
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_546" class="md-nav__link">
    只有 基数排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_547" class="md-nav__link">
    当待排记录有序时，直接插入排序和冒泡排序能达到 ，而对于快速排序而言，这是最不好的情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_548" class="md-nav__link">
    此时快速排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_549" class="md-nav__link">
    简单选则排序，堆排序，归并排序的效率并不能根据关键字的分布而改变
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_550" class="md-nav__link">
    按空间性能来区分
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_551" class="md-nav__link">
    所有简单排序方法直接插入，冒泡，简单选择排序和堆排序为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_552" class="md-nav__link">
    快速排序为 需要借助栈
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_553" class="md-nav__link">
    归并排序需要辅助空间最多，
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_554" class="md-nav__link">
    链式基数排序需要 ， 数组和 变量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_555" class="md-nav__link">
    按稳定性来区分
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_556" class="md-nav__link">
    快速排序和堆排序不是稳定的方法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h6 id="_1">查找和排序<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h6>
<h6 id="_2">查找表<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h6>
<h6 id="_3">线性表<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h6>
<h6 id="_4">顺序查找<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h6>
<h6 id="_5">算法<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h6>
<h6 id="_6">算法分析<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h6>
<h6 id="_7">如何提高查找效率<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h6>
<h6 id="_8">顺序查找特点<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h6>
<h6 id="binary-search">折半查找(Binary Search)<a class="headerlink" href="#binary-search" title="Permanent link">&para;</a></h6>
<h6 id="-">算法分析--判断树<a class="headerlink" href="#-" title="Permanent link">&para;</a></h6>
<h6 id="_9">折半查找特点<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h6>
<h6 id="blocking-search">分块查找(Blocking Search)<a class="headerlink" href="#blocking-search" title="Permanent link">&para;</a></h6>
<h6 id="_10">算法分析<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h6>
<h6 id="_11">分块查找特点<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h6>
<h6 id="_12">线性表查找方法比较<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h6>
<h6 id="_13">树表<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h6>
<h6 id="binary-sort-tree">二叉排序树(Binary Sort Tree)<a class="headerlink" href="#binary-sort-tree" title="Permanent link">&para;</a></h6>
<h6 id="_14">数据类型定义<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h6>
<h6 id="_15">复习：递归创建二叉树<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h6>
<h6 id="bst">BST查找<a class="headerlink" href="#bst" title="Permanent link">&para;</a></h6>
<h6 id="bst_1">BST查找算法分分析<a class="headerlink" href="#bst_1" title="Permanent link">&para;</a></h6>
<h6 id="bst_2">BST插入<a class="headerlink" href="#bst_2" title="Permanent link">&para;</a></h6>
<h6 id="bst_3">创建BST<a class="headerlink" href="#bst_3" title="Permanent link">&para;</a></h6>
<h6 id="bst_4">BST删除<a class="headerlink" href="#bst_4" title="Permanent link">&para;</a></h6>
<h6 id="avlbalance-binary-tree">AVL树(Balance Binary Tree)<a class="headerlink" href="#avlbalance-binary-tree" title="Permanent link">&para;</a></h6>
<h6 id="ll">LL型旋转(右旋转)<a class="headerlink" href="#ll" title="Permanent link">&para;</a></h6>
<h6 id="rr">RR旋转(左旋转)<a class="headerlink" href="#rr" title="Permanent link">&para;</a></h6>
<h6 id="lr">LR旋转(左右旋转)<a class="headerlink" href="#lr" title="Permanent link">&para;</a></h6>
<h6 id="rl">RL旋转(右左旋转)<a class="headerlink" href="#rl" title="Permanent link">&para;</a></h6>
<h6 id="_16">总结<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h6>
<h6 id="_17">代码实现<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h6>
<h6 id="llrr">左旋转和右旋转(参照LL，RR旋转)<a class="headerlink" href="#llrr" title="Permanent link">&para;</a></h6>
<h6 id="_18">左平衡和右平衡<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h6>
<h6 id="_19">插入节点和及时平衡<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h6>
<h6 id="_20">测试代码<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h6>
<h6 id="hash-table">哈希表(Hash Table)<a class="headerlink" href="#hash-table" title="Permanent link">&para;</a></h6>
<h6 id="hash">hash函数的构造方法<a class="headerlink" href="#hash" title="Permanent link">&para;</a></h6>
<h6 id="_21">处理冲突的方法<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h6>
<h6 id="hash-table_1">除留余数法构造Hash Table<a class="headerlink" href="#hash-table_1" title="Permanent link">&para;</a></h6>
<h6 id="_22">查找效率分析<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h6>
<h6 id="_23">几点结论<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h6>
<h6 id="_24">查找总结<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h6>
<h6 id="_25">排序<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h6>
<h6 id="_26">直接插入排序<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h6>
<h6 id="binary-insert-sort">折半插入排序(Binary Insert Sort)<a class="headerlink" href="#binary-insert-sort" title="Permanent link">&para;</a></h6>
<h6 id="shells-sort">希尔排序(Shell's Sort)<a class="headerlink" href="#shells-sort" title="Permanent link">&para;</a></h6>
<h6 id="_27">交换排序<a class="headerlink" href="#_27" title="Permanent link">&para;</a></h6>
<h6 id="_28">冒泡排序<a class="headerlink" href="#_28" title="Permanent link">&para;</a></h6>
<h6 id="_29">快速排序<a class="headerlink" href="#_29" title="Permanent link">&para;</a></h6>
<h6 id="_30">选则排序<a class="headerlink" href="#_30" title="Permanent link">&para;</a></h6>
<h6 id="_31">堆<a class="headerlink" href="#_31" title="Permanent link">&para;</a></h6>
<h6 id="_32">堆定义<a class="headerlink" href="#_32" title="Permanent link">&para;</a></h6>
<h6 id="1">定理1:<a class="headerlink" href="#1" title="Permanent link">&para;</a></h6>
<h6 id="2">定理2:<a class="headerlink" href="#2" title="Permanent link">&para;</a></h6>
<h6 id="_33">初始化堆<a class="headerlink" href="#_33" title="Permanent link">&para;</a></h6>
<h6 id="_34">堆调整<a class="headerlink" href="#_34" title="Permanent link">&para;</a></h6>
<h6 id="_35">堆排序<a class="headerlink" href="#_35" title="Permanent link">&para;</a></h6>
<h6 id="_36">其他类型排序<a class="headerlink" href="#_36" title="Permanent link">&para;</a></h6>
<h6 id="merge-sort">并归排序 Merge Sort<a class="headerlink" href="#merge-sort" title="Permanent link">&para;</a></h6>
<h6 id="_37">合并两个有序序列<a class="headerlink" href="#_37" title="Permanent link">&para;</a></h6>
<h6 id="_38">分割序列并进行合并<a class="headerlink" href="#_38" title="Permanent link">&para;</a></h6>
<h6 id="_39">函数封装<a class="headerlink" href="#_39" title="Permanent link">&para;</a></h6>
<h6 id="_40">算法效率<a class="headerlink" href="#_40" title="Permanent link">&para;</a></h6>
<h6 id="_41">基数排序<a class="headerlink" href="#_41" title="Permanent link">&para;</a></h6>
<h6 id="_42">数据类型定义<a class="headerlink" href="#_42" title="Permanent link">&para;</a></h6>
<h6 id="_43">分配函数<a class="headerlink" href="#_43" title="Permanent link">&para;</a></h6>
<h6 id="_44">收集函数<a class="headerlink" href="#_44" title="Permanent link">&para;</a></h6>
<h6 id="_45">排序函数<a class="headerlink" href="#_45" title="Permanent link">&para;</a></h6>
<h6 id="_46">初始化和输出函数<a class="headerlink" href="#_46" title="Permanent link">&para;</a></h6>
<h6 id="_47">算法效率<a class="headerlink" href="#_47" title="Permanent link">&para;</a></h6>
<h6 id="_48">排序总结<a class="headerlink" href="#_48" title="Permanent link">&para;</a></h6>
<h1 id="_49">查找和排序<a class="headerlink" href="#_49" title="Permanent link">&para;</a></h1>
<h2 id="_50">查找表<a class="headerlink" href="#_50" title="Permanent link">&para;</a></h2>
<h6 id="_51">关键字<a class="headerlink" href="#_51" title="Permanent link">&para;</a></h6>
<h6 id="_52">主关键字：可唯一标识一个记录的关键字<a class="headerlink" href="#_52" title="Permanent link">&para;</a></h6>
<h6 id="_53">次关键字：用以识别若干记录的关键字<a class="headerlink" href="#_53" title="Permanent link">&para;</a></h6>
<h6 id="_54">查找表分类<a class="headerlink" href="#_54" title="Permanent link">&para;</a></h6>
<h6 id="_55">线性表<a class="headerlink" href="#_55" title="Permanent link">&para;</a></h6>
<h6 id="_56">树表<a class="headerlink" href="#_56" title="Permanent link">&para;</a></h6>
<h6 id="_57">哈希表<a class="headerlink" href="#_57" title="Permanent link">&para;</a></h6>
<h6 id="_58">动态和静态<a class="headerlink" href="#_58" title="Permanent link">&para;</a></h6>
<h6 id="_59">静态：仅作查询，检索<a class="headerlink" href="#_59" title="Permanent link">&para;</a></h6>
<h6 id="_60">动态：作插入和删除操作<a class="headerlink" href="#_60" title="Permanent link">&para;</a></h6>
<h6 id="aslaverage-search-length">平均查找长度ASL(Average Search Length)<a class="headerlink" href="#aslaverage-search-length" title="Permanent link">&para;</a></h6>
<h6 id="_61">关键字的平均比较次数<a class="headerlink" href="#_61" title="Permanent link">&para;</a></h6>
<h6 id="_62">记录的个数表长<a class="headerlink" href="#_62" title="Permanent link">&para;</a></h6>
<h6 id="_63">查找第个元素的概率<a class="headerlink" href="#_63" title="Permanent link">&para;</a></h6>
<h6 id="_64">查找到第个元素需要的比较次数<a class="headerlink" href="#_64" title="Permanent link">&para;</a></h6>
<h2 id="_65">线性表<a class="headerlink" href="#_65" title="Permanent link">&para;</a></h2>
<h2 id="_66">顺序查找<a class="headerlink" href="#_66" title="Permanent link">&para;</a></h2>
<h6 id="_67">应用范围<a class="headerlink" href="#_67" title="Permanent link">&para;</a></h6>
<h6 id="_68">顺序表或线性链表的静态查找<a class="headerlink" href="#_68" title="Permanent link">&para;</a></h6>
<h6 id="_69">表内元素无序<a class="headerlink" href="#_69" title="Permanent link">&para;</a></h6>
<h6 id="_70">类型定义:<a class="headerlink" href="#_70" title="Permanent link">&para;</a></h6>
<h4 id="_71">算法<a class="headerlink" href="#_71" title="Permanent link">&para;</a></h4>
<h6 id="base-0-0">思路:把base数组中 0 号位置预留出来，从最后一个元素出发，依此向 0 号方向比较<a class="headerlink" href="#base-0-0" title="Permanent link">&para;</a></h6>
<h6 id="i0-key-stbasei">可发现此算法中一次循环 i&gt;0; 和 key == ST.base[i] 比较了两次<a class="headerlink" href="#i0-key-stbasei" title="Permanent link">&para;</a></h6>
<h6 id="_72">其他形式：<a class="headerlink" href="#_72" title="Permanent link">&para;</a></h6>
<h6 id="i0-stbaseikey-key">i&gt;0 &amp;&amp; ST.base[i].key != key 同样的比较了两次<a class="headerlink" href="#i0-stbaseikey-key" title="Permanent link">&para;</a></h6>
<h6 id="_73">优化算法<a class="headerlink" href="#_73" title="Permanent link">&para;</a></h6>
<h6 id="0-guard">为数组中 0 号位置添加guard<a class="headerlink" href="#0-guard" title="Permanent link">&para;</a></h6>
<h6 id="stbaseikey-key">可发现循环中 ST.base[i].key!= key; 只比较一次<a class="headerlink" href="#stbaseikey-key" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-0-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-0-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-0-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-0-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-0-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-0-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-0-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-0-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-0-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-0-10">10</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-0-1" name="__codelineno-0-1"></a>typedef int KeyType;
<a id="__codelineno-0-2" name="__codelineno-0-2"></a>typedef char *OtherInfo;
<a id="__codelineno-0-3" name="__codelineno-0-3"></a>typedef struct {
<a id="__codelineno-0-4" name="__codelineno-0-4"></a>KeyType key;
<a id="__codelineno-0-5" name="__codelineno-0-5"></a>OtherInfo other; //储存其他信息
<a id="__codelineno-0-6" name="__codelineno-0-6"></a>} SSTElemType;
<a id="__codelineno-0-7" name="__codelineno-0-7"></a>typedef struct {
<a id="__codelineno-0-8" name="__codelineno-0-8"></a>SSTElemType *base; //存放数组的首地址(0号位置不存放关键字，预留给guard)
<a id="__codelineno-0-9" name="__codelineno-0-9"></a>int length; //当前表长(数组的长度)
<a id="__codelineno-0-10" name="__codelineno-0-10"></a>} SSTable;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-1-1">1</a></span>
<span class="normal"><a href="#__codelineno-1-2">2</a></span>
<span class="normal"><a href="#__codelineno-1-3">3</a></span>
<span class="normal"><a href="#__codelineno-1-4">4</a></span>
<span class="normal"><a href="#__codelineno-1-5">5</a></span>
<span class="normal"><a href="#__codelineno-1-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-1-1" name="__codelineno-1-1"></a>int Search_SS(SSTable ST, KeyType key) {
<a id="__codelineno-1-2" name="__codelineno-1-2"></a>for (int i=ST.length; i&gt; 0 ; i--){
<a id="__codelineno-1-3" name="__codelineno-1-3"></a>f (key == ST.base[i].key) return i;
<a id="__codelineno-1-4" name="__codelineno-1-4"></a>}
<a id="__codelineno-1-5" name="__codelineno-1-5"></a>return 0 ;
<a id="__codelineno-1-6" name="__codelineno-1-6"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-2-1">1</a></span>
<span class="normal"><a href="#__codelineno-2-2">2</a></span>
<span class="normal"><a href="#__codelineno-2-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-2-1" name="__codelineno-2-1"></a>int Search_SS(SSTable ST, KeyType key) {
<a id="__codelineno-2-2" name="__codelineno-2-2"></a>int i;
<a id="__codelineno-2-3" name="__codelineno-2-3"></a>for (i = ST.length; i&gt; 0 &amp;&amp; ST.base[i].key != key; i--); //注意;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-3-1">1</a></span>
<span class="normal"><a href="#__codelineno-3-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-3-1" name="__codelineno-3-1"></a>return i;
<a id="__codelineno-3-2" name="__codelineno-3-2"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-4-1">1</a></span>
<span class="normal"><a href="#__codelineno-4-2">2</a></span>
<span class="normal"><a href="#__codelineno-4-3">3</a></span>
<span class="normal"><a href="#__codelineno-4-4">4</a></span>
<span class="normal"><a href="#__codelineno-4-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-4-1" name="__codelineno-4-1"></a>int Search_SS(SSTable ST, KeyType key) // Sequence Search
<a id="__codelineno-4-2" name="__codelineno-4-2"></a>{
<a id="__codelineno-4-3" name="__codelineno-4-3"></a>ST.base[ 0 ].key = key; //预留 0 号位置，设置guard
<a id="__codelineno-4-4" name="__codelineno-4-4"></a>int i;
<a id="__codelineno-4-5" name="__codelineno-4-5"></a>for (i = ST.length; ST.base[i].key != key; i--); //分号不可以丢
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-5-1">1</a></span>
<span class="normal"><a href="#__codelineno-5-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-5-1" name="__codelineno-5-1"></a>return i;
<a id="__codelineno-5-2" name="__codelineno-5-2"></a>}
</code></pre></div></td></tr></table></div></p>
<h4 id="_74">算法分析<a class="headerlink" href="#_74" title="Permanent link">&para;</a></h4>
<h6 id="_75">观察此图，发现想查到第个位置，需要 次比较<a class="headerlink" href="#_75" title="Permanent link">&para;</a></h6>
<h6 id="_76">查找失败则需要 次比较<a class="headerlink" href="#_76" title="Permanent link">&para;</a></h6>
<h6 id="_77">令<a class="headerlink" href="#_77" title="Permanent link">&para;</a></h6>
<h6 id="_78">所以<a class="headerlink" href="#_78" title="Permanent link">&para;</a></h6>
<h6 id="_79">时间复杂度：<a class="headerlink" href="#_79" title="Permanent link">&para;</a></h6>
<h6 id="_80">空间复杂度需要额外的数组中 号位置<a class="headerlink" href="#_80" title="Permanent link">&para;</a></h6>
<h4 id="_81">如何提高查找效率<a class="headerlink" href="#_81" title="Permanent link">&para;</a></h4>
<h6 id="1_1">1. 按查找概率高低存储<a class="headerlink" href="#1_1" title="Permanent link">&para;</a></h6>
<h6 id="_82">查找概率高，比较次数少<a class="headerlink" href="#_82" title="Permanent link">&para;</a></h6>
<h6 id="_83">查找概率低，比较次数多<a class="headerlink" href="#_83" title="Permanent link">&para;</a></h6>
<h6 id="2_1">2. 当查找概率无法确定时<a class="headerlink" href="#2_1" title="Permanent link">&para;</a></h6>
<h6 id="_84">按查找概率动态调整<a class="headerlink" href="#_84" title="Permanent link">&para;</a></h6>
<h6 id="key">在每个key中增设一个访问频度域<a class="headerlink" href="#key" title="Permanent link">&para;</a></h6>
<h6 id="_85">始终保持频度域按非递增，有序的次序排列<a class="headerlink" href="#_85" title="Permanent link">&para;</a></h6>
<h6 id="key_1">每次查找后，讲刚查到的key数据移至表头<a class="headerlink" href="#key_1" title="Permanent link">&para;</a></h6>
<h4 id="_86">顺序查找特点<a class="headerlink" href="#_86" title="Permanent link">&para;</a></h4>
<h6 id="_87">优点：算法简单，逻辑次序无要求，不同存储结构均适用<a class="headerlink" href="#_87" title="Permanent link">&para;</a></h6>
<h6 id="asl">缺点：ASL太长，时间效率低<a class="headerlink" href="#asl" title="Permanent link">&para;</a></h6>
<h3 id="binary-search_1">折半查找(Binary Search)<a class="headerlink" href="#binary-search_1" title="Permanent link">&para;</a></h3>
<h6 id="_88">前置条件：集合中的元素按递增的顺序排列<a class="headerlink" href="#_88" title="Permanent link">&para;</a></h6>
<h6 id="_89">方法：每次将集合中的元素缩小一半<a class="headerlink" href="#_89" title="Permanent link">&para;</a></h6>
<h6 id="lowhighleftright">需要变量 low,high或left,right<a class="headerlink" href="#lowhighleftright" title="Permanent link">&para;</a></h6>
<h6 id="lowhigh">由图可知，如果查找的元素不在集合中，那么最终的结果为 low&gt;high,即循环的条件为<a class="headerlink" href="#lowhigh" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-6-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-6-1" name="__codelineno-6-1"></a>while(low&lt;=high)
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-7-1">1</a></span>
<span class="normal"><a href="#__codelineno-7-2">2</a></span>
<span class="normal"><a href="#__codelineno-7-3">3</a></span>
<span class="normal"><a href="#__codelineno-7-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-7-1" name="__codelineno-7-1"></a>int Search_BS(SSTable ST, KeyType key) {
<a id="__codelineno-7-2" name="__codelineno-7-2"></a>int left = 1 ; //确定左区间
<a id="__codelineno-7-3" name="__codelineno-7-3"></a>int right = ST.length; //确定又区间
<a id="__codelineno-7-4" name="__codelineno-7-4"></a>int mid = (left + right) / 2 ;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-8-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-8-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-8-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-8-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-8-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-8-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-8-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-8-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-8-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-8-10">10</a></span>
<span class="normal"><a href="#__codelineno-8-11">11</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-8-1" name="__codelineno-8-1"></a>while (left &lt;= right) {
<a id="__codelineno-8-2" name="__codelineno-8-2"></a>if (key == ST.base[mid].key)
<a id="__codelineno-8-3" name="__codelineno-8-3"></a>return mid;
<a id="__codelineno-8-4" name="__codelineno-8-4"></a>else if (key &gt; ST.base[mid].key) { //如果搜索元素大于中间位置元素
<a id="__codelineno-8-5" name="__codelineno-8-5"></a>left = mid + 1 ;
<a id="__codelineno-8-6" name="__codelineno-8-6"></a>mid = (left + right) / 2 ;
<a id="__codelineno-8-7" name="__codelineno-8-7"></a>} else { //如果搜索元素小于中间位置
<a id="__codelineno-8-8" name="__codelineno-8-8"></a>right = mid - 1 ;
<a id="__codelineno-8-9" name="__codelineno-8-9"></a>mid = (left + right) / 2 ;
<a id="__codelineno-8-10" name="__codelineno-8-10"></a>}
<a id="__codelineno-8-11" name="__codelineno-8-11"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-9-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-9-1" name="__codelineno-9-1"></a>return 0 ;
</code></pre></div></td></tr></table></div></p>
<h4 id="-_1">算法分析--判断树<a class="headerlink" href="#-_1" title="Permanent link">&para;</a></h4>
<h6 id="_90">二叉树性质<a class="headerlink" href="#_90" title="Permanent link">&para;</a></h6>
<h6 id="_91">节点数<a class="headerlink" href="#_91" title="Permanent link">&para;</a></h6>
<h6 id="_92">高度<a class="headerlink" href="#_92" title="Permanent link">&para;</a></h6>
<h6 id="_93">第 层节点个数<a class="headerlink" href="#_93" title="Permanent link">&para;</a></h6>
<h6 id="_94">可以把该搜索过程抽象成一颗二叉树，在数组中的位置表示节点<a class="headerlink" href="#_94" title="Permanent link">&para;</a></h6>
<h6 id="_95">可以看出该二叉树的 为<a class="headerlink" href="#_95" title="Permanent link">&para;</a></h6>
<h6 id="_96">那么该二叉树的节点数为 即<a class="headerlink" href="#_96" title="Permanent link">&para;</a></h6>
<h6 id="_97">由此可见，找到元素所在位置经过的路径就是需要的比较次数<a class="headerlink" href="#_97" title="Permanent link">&para;</a></h6>
<h6 id="lowhigh_1">方形节点代表着外部节点，如果到达方形节点则表示查找失败，即 low&gt;high<a class="headerlink" href="#lowhigh_1" title="Permanent link">&para;</a></h6>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-10-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-10-1" name="__codelineno-10-1"></a>}
</code></pre></div></td></tr></table></div>
<h6 id="_98">为了方便讨论，设一个数组中有 个元素<a class="headerlink" href="#_98" title="Permanent link">&para;</a></h6>
<h6 id="_99">令每个元素找到的概率相等<a class="headerlink" href="#_99" title="Permanent link">&para;</a></h6>
<h6 id="_100">转化成高度<a class="headerlink" href="#_100" title="Permanent link">&para;</a></h6>
<h6 id="_101">推导<a class="headerlink" href="#_101" title="Permanent link">&para;</a></h6>
<h6 id="_102">假设有 则有数列<a class="headerlink" href="#_102" title="Permanent link">&para;</a></h6>
<h6 id="_103">令 则有数列<a class="headerlink" href="#_103" title="Permanent link">&para;</a></h6>
<h6 id="_104">由 可知<a class="headerlink" href="#_104" title="Permanent link">&para;</a></h6>
<h4 id="_105">折半查找特点<a class="headerlink" href="#_105" title="Permanent link">&para;</a></h4>
<h6 id="_106">优点：效率比顺序查找高<a class="headerlink" href="#_106" title="Permanent link">&para;</a></h6>
<h6 id="_107">缺点：只适用于有序表，且仅限于顺序存储结构(对链表无效)<a class="headerlink" href="#_107" title="Permanent link">&para;</a></h6>
<h3 id="blocking-search_1">分块查找(Blocking Search)<a class="headerlink" href="#blocking-search_1" title="Permanent link">&para;</a></h3>
<h6 id="_108">将表分为几块，并且分块有序，块内可以无序，如下图<a class="headerlink" href="#_108" title="Permanent link">&para;</a></h6>
<h6 id="_109">把所有抽象成一个数组，数组内元素是最大关键字，对块进行折半查找，对块内进行顺序查找<a class="headerlink" href="#_109" title="Permanent link">&para;</a></h6>
<h6 id="_110">数据类型定义：<a class="headerlink" href="#_110" title="Permanent link">&para;</a></h6>
<h6 id="_111">算法实现<a class="headerlink" href="#_111" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-11-1">1</a></span>
<span class="normal"><a href="#__codelineno-11-2">2</a></span>
<span class="normal"><a href="#__codelineno-11-3">3</a></span>
<span class="normal"><a href="#__codelineno-11-4">4</a></span>
<span class="normal"><a href="#__codelineno-11-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-11-1" name="__codelineno-11-1"></a>#define MAXBLOCK 20
<a id="__codelineno-11-2" name="__codelineno-11-2"></a>typedef struct {
<a id="__codelineno-11-3" name="__codelineno-11-3"></a>KeyType MaxKey;
<a id="__codelineno-11-4" name="__codelineno-11-4"></a>int start, end;
<a id="__codelineno-11-5" name="__codelineno-11-5"></a>} IndexElemType;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-12-1">1</a></span>
<span class="normal"><a href="#__codelineno-12-2">2</a></span>
<span class="normal"><a href="#__codelineno-12-3">3</a></span>
<span class="normal"><a href="#__codelineno-12-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-12-1" name="__codelineno-12-1"></a>typedef struct __IndexTbale {
<a id="__codelineno-12-2" name="__codelineno-12-2"></a>IndexElemType index[MAXBLOCK];
<a id="__codelineno-12-3" name="__codelineno-12-3"></a>int length;
<a id="__codelineno-12-4" name="__codelineno-12-4"></a>} IndexTable;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-13-1">1</a></span>
<span class="normal"><a href="#__codelineno-13-2">2</a></span>
<span class="normal"><a href="#__codelineno-13-3">3</a></span>
<span class="normal"><a href="#__codelineno-13-4">4</a></span>
<span class="normal"><a href="#__codelineno-13-5">5</a></span>
<span class="normal"><a href="#__codelineno-13-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-13-1" name="__codelineno-13-1"></a>IndexTable INDEXTABLE; //全局变量索引表，调用BlockSearch的时候需要extern声明
<a id="__codelineno-13-2" name="__codelineno-13-2"></a>int BlockSearch(KeyType *a, KeyType key) //此函数，默认不使用数组中 0 号下标，从数组下标 1 开
<a id="__codelineno-13-3" name="__codelineno-13-3"></a>始
<a id="__codelineno-13-4" name="__codelineno-13-4"></a>{
<a id="__codelineno-13-5" name="__codelineno-13-5"></a>int left = 1 ;
<a id="__codelineno-13-6" name="__codelineno-13-6"></a>int right = INDEXTABLE.length;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-14-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-14-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-14-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-14-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-14-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-14-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-14-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-14-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-14-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-14-10">10</a></span>
<span class="normal"><a href="#__codelineno-14-11">11</a></span>
<span class="normal"><a href="#__codelineno-14-12">12</a></span>
<span class="normal"><a href="#__codelineno-14-13">13</a></span>
<span class="normal"><a href="#__codelineno-14-14">14</a></span>
<span class="normal"><a href="#__codelineno-14-15">15</a></span>
<span class="normal"><a href="#__codelineno-14-16">16</a></span>
<span class="normal"><a href="#__codelineno-14-17">17</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-14-1" name="__codelineno-14-1"></a>while (left &lt;= right) {
<a id="__codelineno-14-2" name="__codelineno-14-2"></a>int mid = (left + right) / 2 ;
<a id="__codelineno-14-3" name="__codelineno-14-3"></a>if (key &lt;=
<a id="__codelineno-14-4" name="__codelineno-14-4"></a>INDEXTABLE.index[mid].MaxKey) { //如果小于mid,则需要判断是否大于mid-
<a id="__codelineno-14-5" name="__codelineno-14-5"></a>if (key &gt;
<a id="__codelineno-14-6" name="__codelineno-14-6"></a>INDEXTABLE.index[mid - 1 ].MaxKey) { //如果大于mid-1 说明在mid所在块
<a id="__codelineno-14-7" name="__codelineno-14-7"></a>for (int i = INDEXTABLE.index[mid].start;
<a id="__codelineno-14-8" name="__codelineno-14-8"></a>i &lt;= INDEXTABLE.index[mid].end; i++) {
<a id="__codelineno-14-9" name="__codelineno-14-9"></a>if (key == a[i])
<a id="__codelineno-14-10" name="__codelineno-14-10"></a>return i; //进行顺序搜索
<a id="__codelineno-14-11" name="__codelineno-14-11"></a>}
<a id="__codelineno-14-12" name="__codelineno-14-12"></a>return 0 ; //没找到返回 0
<a id="__codelineno-14-13" name="__codelineno-14-13"></a>} else { //小于等于mid-1 则需要进行下次的折半查找
<a id="__codelineno-14-14" name="__codelineno-14-14"></a>right = mid - 1 ;
<a id="__codelineno-14-15" name="__codelineno-14-15"></a>}
<a id="__codelineno-14-16" name="__codelineno-14-16"></a>} else { // key大于mid，进行下一次折半查找
<a id="__codelineno-14-17" name="__codelineno-14-17"></a>left = mid + 1 ;
</code></pre></div></td></tr></table></div></p>
<h6 id="_112">测试案例<a class="headerlink" href="#_112" title="Permanent link">&para;</a></h6>
<h4 id="_113">算法分析<a class="headerlink" href="#_113" title="Permanent link">&para;</a></h4>
<h6 id="_114">为对 进行的折半查找， 为对块内进行的顺序查找， 为每一块内元素个数<a class="headerlink" href="#_114" title="Permanent link">&para;</a></h6>
<h6 id="_115">例如当 时<a class="headerlink" href="#_115" title="Permanent link">&para;</a></h6>
<h6 id="_116">折半查找为 顺序查找为<a class="headerlink" href="#_116" title="Permanent link">&para;</a></h6>
<h4 id="_117">分块查找特点<a class="headerlink" href="#_117" title="Permanent link">&para;</a></h4>
<h6 id="_118">优点：插入和删除比较容易，无需进行大量移动<a class="headerlink" href="#_118" title="Permanent link">&para;</a></h6>
<h6 id="indextable">缺点：要增加一个indextable数组(索引表)的储存空间并对初始索引进行排序运算<a class="headerlink" href="#indextable" title="Permanent link">&para;</a></h6>
<h6 id="_119">使用情况：如果线性表要快速查找且又经常动态变化，则可采用分块查找<a class="headerlink" href="#_119" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-15-1">1</a></span>
<span class="normal"><a href="#__codelineno-15-2">2</a></span>
<span class="normal"><a href="#__codelineno-15-3">3</a></span>
<span class="normal"><a href="#__codelineno-15-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-15-1" name="__codelineno-15-1"></a>}
<a id="__codelineno-15-2" name="__codelineno-15-2"></a>}
<a id="__codelineno-15-3" name="__codelineno-15-3"></a>return 0 ; // while循环后依旧没有return，说明没有找到，返回 0
<a id="__codelineno-15-4" name="__codelineno-15-4"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-16-1">1</a></span>
<span class="normal"><a href="#__codelineno-16-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-16-1" name="__codelineno-16-1"></a>#include &quot;SSTable.h&quot;
<a id="__codelineno-16-2" name="__codelineno-16-2"></a>extern IndexTable INDEXTABLE;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-17-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-17-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-17-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-17-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-17-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-17-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-17-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-17-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-17-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-17-10">10</a></span>
<span class="normal"><a href="#__codelineno-17-11">11</a></span>
<span class="normal"><a href="#__codelineno-17-12">12</a></span>
<span class="normal"><a href="#__codelineno-17-13">13</a></span>
<span class="normal"><a href="#__codelineno-17-14">14</a></span>
<span class="normal"><a href="#__codelineno-17-15">15</a></span>
<span class="normal"><a href="#__codelineno-17-16">16</a></span>
<span class="normal"><a href="#__codelineno-17-17">17</a></span>
<span class="normal"><a href="#__codelineno-17-18">18</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-17-1" name="__codelineno-17-1"></a>int main(void) {
<a id="__codelineno-17-2" name="__codelineno-17-2"></a>KeyType a[ 19 ] = { 0 , 22 , 12 , 13 , 8 , 9 , 20 , 33 , 42 , 44 ,
<a id="__codelineno-17-3" name="__codelineno-17-3"></a>38 , 24 , 48 , 60 , 58 , 74 , 49 , 86 , 53 };
<a id="__codelineno-17-4" name="__codelineno-17-4"></a>//不计入 0 号元素，初始化时 0 号位置为 0
<a id="__codelineno-17-5" name="__codelineno-17-5"></a>INDEXTABLE.length = 3 ;
<a id="__codelineno-17-6" name="__codelineno-17-6"></a>INDEXTABLE.index[ 1 ].start = 1 , INDEXTABLE.index[ 1 ].end = 6 ,
<a id="__codelineno-17-7" name="__codelineno-17-7"></a>INDEXTABLE.index[ 1 ].MaxKey = 22 ;
<a id="__codelineno-17-8" name="__codelineno-17-8"></a>INDEXTABLE.index[ 2 ].start = 7 , INDEXTABLE.index[ 2 ].end = 12 ,
<a id="__codelineno-17-9" name="__codelineno-17-9"></a>INDEXTABLE.index[ 2 ].MaxKey = 48 ;
<a id="__codelineno-17-10" name="__codelineno-17-10"></a>INDEXTABLE.index[ 3 ].start = 13 , INDEXTABLE.index[ 3 ].end = 18 ,
<a id="__codelineno-17-11" name="__codelineno-17-11"></a>INDEXTABLE.index[ 3 ].MaxKey = 86 ;
<a id="__codelineno-17-12" name="__codelineno-17-12"></a>printf(&quot;%d\n&quot;, BlockSearch(a, 86 ));
<a id="__codelineno-17-13" name="__codelineno-17-13"></a>system(&quot;pause&quot;);
<a id="__codelineno-17-14" name="__codelineno-17-14"></a>return 0 ;
<a id="__codelineno-17-15" name="__codelineno-17-15"></a>}
<a id="__codelineno-17-16" name="__codelineno-17-16"></a>/*
<a id="__codelineno-17-17" name="__codelineno-17-17"></a>22 12 13 8 9 20 33 42 44 38 24 48 60 58 74 49 86 53
<a id="__codelineno-17-18" name="__codelineno-17-18"></a>*/
</code></pre></div></td></tr></table></div></p>
<h6 id="_120">顺序查找 折半查找 分块查找<a class="headerlink" href="#_120" title="Permanent link">&para;</a></h6>
<h6 id="asl_1">ASL 最大 最小 适中<a class="headerlink" href="#asl_1" title="Permanent link">&para;</a></h6>
<h6 id="ok">结构 有序表，无需表OK 仅有序表 分块有序<a class="headerlink" href="#ok" title="Permanent link">&para;</a></h6>
<h6 id="ok-no-ok">存储结构 循序表，链表OK 链表NO 顺序表，链表OK<a class="headerlink" href="#ok-no-ok" title="Permanent link">&para;</a></h6>
<h3 id="_121">线性表查找方法比较<a class="headerlink" href="#_121" title="Permanent link">&para;</a></h3>
<h3 id="_122">树表<a class="headerlink" href="#_122" title="Permanent link">&para;</a></h3>
<h6 id="_123">当表插入，删除操作频繁时，为维护表的有序性，需要移动表中很多记录，有一种方法就是改用动态<a class="headerlink" href="#_123" title="Permanent link">&para;</a></h6>
<h6 id="-_2">查找表--树表<a class="headerlink" href="#-_2" title="Permanent link">&para;</a></h6>
<h6 id="keykey">对于给定的key值，若表中存在则成功返回，若不存在则插入一个等于key值的记录<a class="headerlink" href="#keykey" title="Permanent link">&para;</a></h6>
<h6 id="_124">树表分为：<a class="headerlink" href="#_124" title="Permanent link">&para;</a></h6>
<h6 id="_125">二叉排序树<a class="headerlink" href="#_125" title="Permanent link">&para;</a></h6>
<h6 id="_126">平衡二叉树<a class="headerlink" href="#_126" title="Permanent link">&para;</a></h6>
<h6 id="_127">红黑树<a class="headerlink" href="#_127" title="Permanent link">&para;</a></h6>
<h6 id="b-">B-树<a class="headerlink" href="#b-" title="Permanent link">&para;</a></h6>
<h6 id="b">B+树<a class="headerlink" href="#b" title="Permanent link">&para;</a></h6>
<h6 id="_128">建树<a class="headerlink" href="#_128" title="Permanent link">&para;</a></h6>
<h6 id="_129">此笔记暂时只记录 二叉排序树 和 平衡二叉树<a class="headerlink" href="#_129" title="Permanent link">&para;</a></h6>
<h3 id="binary-sort-tree_1">二叉排序树(Binary Sort Tree)<a class="headerlink" href="#binary-sort-tree_1" title="Permanent link">&para;</a></h3>
<h6 id="_130">定义：<a class="headerlink" href="#_130" title="Permanent link">&para;</a></h6>
<h6 id="_131">若其左子树非空，则左子树上所有节点的值均小于根节点的值<a class="headerlink" href="#_131" title="Permanent link">&para;</a></h6>
<h6 id="_132">若其右子树非空，则右子树上所有节点的值均大于等于根节点的值<a class="headerlink" href="#_132" title="Permanent link">&para;</a></h6>
<h6 id="_133">其左右子树本身又是一颗二叉排序树<a class="headerlink" href="#_133" title="Permanent link">&para;</a></h6>
<h6 id="_134">如下图<a class="headerlink" href="#_134" title="Permanent link">&para;</a></h6>
<h6 id="_135">如果中序遍历非空二叉排序树，所得到的元素数据序列是一个递增有序数列<a class="headerlink" href="#_135" title="Permanent link">&para;</a></h6>
<h4 id="_136">数据类型定义<a class="headerlink" href="#_136" title="Permanent link">&para;</a></h4>
<h4 id="_137">复习：递归创建二叉树<a class="headerlink" href="#_137" title="Permanent link">&para;</a></h4>
<h6 id="pre-orderpost-orderin-order">可以按照Pre-order或Post-order创建二叉树，但是无法按照In-order创建。<a class="headerlink" href="#pre-orderpost-orderin-order" title="Permanent link">&para;</a></h6>
<h6 id="prepostin-order">这是因为在Pre和Post中连续的虚空节点可以确定唯一的叶子节点，但是In-order不能。<a class="headerlink" href="#prepostin-order" title="Permanent link">&para;</a></h6>
<h4 id="bst_5">BST查找<a class="headerlink" href="#bst_5" title="Permanent link">&para;</a></h4>
<h6 id="_138">若关键字等于根节点，成功<a class="headerlink" href="#_138" title="Permanent link">&para;</a></h6>
<h6 id="_139">否则：<a class="headerlink" href="#_139" title="Permanent link">&para;</a></h6>
<h6 id="_140">若小于根节点，查其左子树<a class="headerlink" href="#_140" title="Permanent link">&para;</a></h6>
<h6 id="_141">若大于等于根节点，查起右子树<a class="headerlink" href="#_141" title="Permanent link">&para;</a></h6>
<h6 id="_142">依此递归<a class="headerlink" href="#_142" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-18-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-18-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-18-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-18-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-18-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-18-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-18-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-18-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-18-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-18-10">10</a></span>
<span class="normal"><a href="#__codelineno-18-11">11</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-18-1" name="__codelineno-18-1"></a>#define ENDFLAG 0 //输入结束符
<a id="__codelineno-18-2" name="__codelineno-18-2"></a>typedef int BSTKeyType;
<a id="__codelineno-18-3" name="__codelineno-18-3"></a>typedef char *BSTOtherInfo;
<a id="__codelineno-18-4" name="__codelineno-18-4"></a>typedef struct __BSTElemType {
<a id="__codelineno-18-5" name="__codelineno-18-5"></a>BSTKeyType key;
<a id="__codelineno-18-6" name="__codelineno-18-6"></a>BSTOtherInfo other;
<a id="__codelineno-18-7" name="__codelineno-18-7"></a>} BSTElemType;
<a id="__codelineno-18-8" name="__codelineno-18-8"></a>typedef struct __BSTNode {
<a id="__codelineno-18-9" name="__codelineno-18-9"></a>BSTElemType data;
<a id="__codelineno-18-10" name="__codelineno-18-10"></a>__BSTNode *lchild, *rchild;
<a id="__codelineno-18-11" name="__codelineno-18-11"></a>} BSTNode, *BSTree;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-19-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-19-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-19-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-19-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-19-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-19-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-19-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-19-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-19-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-19-10">10</a></span>
<span class="normal"><a href="#__codelineno-19-11">11</a></span>
<span class="normal"><a href="#__codelineno-19-12">12</a></span>
<span class="normal"><a href="#__codelineno-19-13">13</a></span>
<span class="normal"><a href="#__codelineno-19-14">14</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-19-1" name="__codelineno-19-1"></a>Status CreatBTree(BSTree *T) {
<a id="__codelineno-19-2" name="__codelineno-19-2"></a>BSTKeyType key;
<a id="__codelineno-19-3" name="__codelineno-19-3"></a>scanf(&quot; %d&quot;, &amp;key);
<a id="__codelineno-19-4" name="__codelineno-19-4"></a>if ( 0 == key)
<a id="__codelineno-19-5" name="__codelineno-19-5"></a>*T = NULL;
<a id="__codelineno-19-6" name="__codelineno-19-6"></a>else {
<a id="__codelineno-19-7" name="__codelineno-19-7"></a>if (!(*T = (BSTree)malloc(sizeof(BSTNode))))
<a id="__codelineno-19-8" name="__codelineno-19-8"></a>exit(OVERFLOW);
<a id="__codelineno-19-9" name="__codelineno-19-9"></a>(*T)-&gt;data.key = key;
<a id="__codelineno-19-10" name="__codelineno-19-10"></a>CreatBTree(&amp;(*T)-&gt;lchild);
<a id="__codelineno-19-11" name="__codelineno-19-11"></a>CreatBTree(&amp;(*T)-&gt;rchild);
<a id="__codelineno-19-12" name="__codelineno-19-12"></a>}
<a id="__codelineno-19-13" name="__codelineno-19-13"></a>return OK;
<a id="__codelineno-19-14" name="__codelineno-19-14"></a>}
</code></pre></div></td></tr></table></div></p>
<h4 id="bst_6">BST查找算法分分析<a class="headerlink" href="#bst_6" title="Permanent link">&para;</a></h4>
<h6 id="bst_7">BST查找算法类似于折半查找，每个节点的比较次数和所在层次有关，所及<a class="headerlink" href="#bst_7" title="Permanent link">&para;</a></h6>
<h6 id="n">含有n个节点的二叉排序树的平均查找长度与此二叉树的形态有关，如下图<a class="headerlink" href="#n" title="Permanent link">&para;</a></h6>
<h6 id="asl_2">节点数一样，但ASL显然不同<a class="headerlink" href="#asl_2" title="Permanent link">&para;</a></h6>
<h6 id="_143">的 折半查找<a class="headerlink" href="#_143" title="Permanent link">&para;</a></h6>
<h6 id="_144">的 顺序查找<a class="headerlink" href="#_144" title="Permanent link">&para;</a></h6>
<h6 id="_145">所以说在创建二叉排序树的时候，尽量要让此二叉树形状均匀<a class="headerlink" href="#_145" title="Permanent link">&para;</a></h6>
<h4 id="bst_8">BST插入<a class="headerlink" href="#bst_8" title="Permanent link">&para;</a></h4>
<h6 id="bst_9">BST插入算法和线性表的插入算法不同，不需要具体位置<a class="headerlink" href="#bst_9" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-20-1">1</a></span>
<span class="normal"><a href="#__codelineno-20-2">2</a></span>
<span class="normal"><a href="#__codelineno-20-3">3</a></span>
<span class="normal"><a href="#__codelineno-20-4">4</a></span>
<span class="normal"><a href="#__codelineno-20-5">5</a></span>
<span class="normal"><a href="#__codelineno-20-6">6</a></span>
<span class="normal"><a href="#__codelineno-20-7">7</a></span>
<span class="normal"><a href="#__codelineno-20-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-20-1" name="__codelineno-20-1"></a>BSTree Search_BST(BSTree T, BSTKeyType key) {
<a id="__codelineno-20-2" name="__codelineno-20-2"></a>if (!(T) || key == T-&gt;data.key)
<a id="__codelineno-20-3" name="__codelineno-20-3"></a>return T;
<a id="__codelineno-20-4" name="__codelineno-20-4"></a>else if (key &lt; T-&gt;data.key)
<a id="__codelineno-20-5" name="__codelineno-20-5"></a>return Search_BST(T-&gt;lchild, key);
<a id="__codelineno-20-6" name="__codelineno-20-6"></a>else
<a id="__codelineno-20-7" name="__codelineno-20-7"></a>return Search_BST(T-&gt;rchild, key);
<a id="__codelineno-20-8" name="__codelineno-20-8"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-21-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-21-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-21-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-21-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-21-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-21-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-21-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-21-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-21-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-21-10">10</a></span>
<span class="normal"><a href="#__codelineno-21-11">11</a></span>
<span class="normal"><a href="#__codelineno-21-12">12</a></span>
<span class="normal"><a href="#__codelineno-21-13">13</a></span>
<span class="normal"><a href="#__codelineno-21-14">14</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-21-1" name="__codelineno-21-1"></a>void Insert_BST(BSTree *T, BSTKeyType e) {
<a id="__codelineno-21-2" name="__codelineno-21-2"></a>if (NULL == *T) {
<a id="__codelineno-21-3" name="__codelineno-21-3"></a>//如果当前节点为空， 则表示找到合适位置，创建新节点
<a id="__codelineno-21-4" name="__codelineno-21-4"></a>*T = (BSTree)malloc(sizeof(BSTNode));
<a id="__codelineno-21-5" name="__codelineno-21-5"></a>(*T)-&gt;data.key = e;
<a id="__codelineno-21-6" name="__codelineno-21-6"></a>(*T)-&gt;lchild = (*T)-&gt;rchild = NULL;
<a id="__codelineno-21-7" name="__codelineno-21-7"></a>} else if (e &lt; (*T)-&gt;data.key) {
<a id="__codelineno-21-8" name="__codelineno-21-8"></a>//表示位置在T树的左子树
<a id="__codelineno-21-9" name="__codelineno-21-9"></a>Insert_BST(&amp;((*T)-&gt;lchild), e);
<a id="__codelineno-21-10" name="__codelineno-21-10"></a>} else if (e &gt; (*T)-&gt;data.key) {
<a id="__codelineno-21-11" name="__codelineno-21-11"></a>//在T树的右子树
<a id="__codelineno-21-12" name="__codelineno-21-12"></a>Insert_BST(&amp;((*T)-&gt;rchild), e);
<a id="__codelineno-21-13" name="__codelineno-21-13"></a>}
<a id="__codelineno-21-14" name="__codelineno-21-14"></a>}
</code></pre></div></td></tr></table></div></p>
<h6 id="_146">测试代码<a class="headerlink" href="#_146" title="Permanent link">&para;</a></h6>
<h4 id="bst_10">创建BST<a class="headerlink" href="#bst_10" title="Permanent link">&para;</a></h4>
<h6 id="t">若从一颗空树T出发，依次插入节点，那么可以创建一个二叉排序树<a class="headerlink" href="#t" title="Permanent link">&para;</a></h6>
<h6 id="_147">测试代码<a class="headerlink" href="#_147" title="Permanent link">&para;</a></h6>
<h6 id="_148">如下图<a class="headerlink" href="#_148" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-22-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-22-1" name="__codelineno-22-1"></a>#include &quot;BSTree.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-23-1">1</a></span>
<span class="normal"><a href="#__codelineno-23-2">2</a></span>
<span class="normal"><a href="#__codelineno-23-3">3</a></span>
<span class="normal"><a href="#__codelineno-23-4">4</a></span>
<span class="normal"><a href="#__codelineno-23-5">5</a></span>
<span class="normal"><a href="#__codelineno-23-6">6</a></span>
<span class="normal"><a href="#__codelineno-23-7">7</a></span>
<span class="normal"><a href="#__codelineno-23-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-23-1" name="__codelineno-23-1"></a>int main(void) {
<a id="__codelineno-23-2" name="__codelineno-23-2"></a>BSTree T = NULL;
<a id="__codelineno-23-3" name="__codelineno-23-3"></a>CreatBTree(&amp;T); //以先序遍历的顺序创建二叉树， 0 表示为虚空节点
<a id="__codelineno-23-4" name="__codelineno-23-4"></a>Insert_BST(&amp;T, 66 );
<a id="__codelineno-23-5" name="__codelineno-23-5"></a>InOrder_BST(T);
<a id="__codelineno-23-6" name="__codelineno-23-6"></a>system(&quot;pause&quot;);
<a id="__codelineno-23-7" name="__codelineno-23-7"></a>return 0 ;
<a id="__codelineno-23-8" name="__codelineno-23-8"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-24-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-24-1" name="__codelineno-24-1"></a>//// 45 12 3 0 0 37 24 0 0 0 53 0 100 61 0 90 78 0 0 0 0
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-25-1">1</a></span>
<span class="normal"><a href="#__codelineno-25-2">2</a></span>
<span class="normal"><a href="#__codelineno-25-3">3</a></span>
<span class="normal"><a href="#__codelineno-25-4">4</a></span>
<span class="normal"><a href="#__codelineno-25-5">5</a></span>
<span class="normal"><a href="#__codelineno-25-6">6</a></span>
<span class="normal"><a href="#__codelineno-25-7">7</a></span>
<span class="normal"><a href="#__codelineno-25-8">8</a></span>
<span class="normal"><a href="#__codelineno-25-9">9</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-25-1" name="__codelineno-25-1"></a>void Creat_BST(BSTree *T) {
<a id="__codelineno-25-2" name="__codelineno-25-2"></a>*T = NULL; //初始化为NULL，以便Inser——BST可以运行
<a id="__codelineno-25-3" name="__codelineno-25-3"></a>BSTKeyType key;
<a id="__codelineno-25-4" name="__codelineno-25-4"></a>scanf(&quot; %d&quot;, &amp;key);
<a id="__codelineno-25-5" name="__codelineno-25-5"></a>while (key != ENDFLAG) { // ENDFALG 为 0
<a id="__codelineno-25-6" name="__codelineno-25-6"></a>Insert_BST(T, key);
<a id="__codelineno-25-7" name="__codelineno-25-7"></a>scanf(&quot; %d&quot;, &amp;key); //注意：while内部必须要有输入
<a id="__codelineno-25-8" name="__codelineno-25-8"></a>}
<a id="__codelineno-25-9" name="__codelineno-25-9"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-26-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-26-1" name="__codelineno-26-1"></a>#include &quot;BSTree.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-27-1">1</a></span>
<span class="normal"><a href="#__codelineno-27-2">2</a></span>
<span class="normal"><a href="#__codelineno-27-3">3</a></span>
<span class="normal"><a href="#__codelineno-27-4">4</a></span>
<span class="normal"><a href="#__codelineno-27-5">5</a></span>
<span class="normal"><a href="#__codelineno-27-6">6</a></span>
<span class="normal"><a href="#__codelineno-27-7">7</a></span>
<span class="normal"><a href="#__codelineno-27-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-27-1" name="__codelineno-27-1"></a>int main(void) {
<a id="__codelineno-27-2" name="__codelineno-27-2"></a>BSTree T = NULL;
<a id="__codelineno-27-3" name="__codelineno-27-3"></a>Creat_BST(&amp;T);
<a id="__codelineno-27-4" name="__codelineno-27-4"></a>// Insert_BST(&amp;T, 66);
<a id="__codelineno-27-5" name="__codelineno-27-5"></a>InOrder_BST(T);
<a id="__codelineno-27-6" name="__codelineno-27-6"></a>system(&quot;pause&quot;);
<a id="__codelineno-27-7" name="__codelineno-27-7"></a>return 0 ;
<a id="__codelineno-27-8" name="__codelineno-27-8"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-28-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-28-1" name="__codelineno-28-1"></a>// 45 24 53 12 90 0
</code></pre></div></td></tr></table></div></p>
<h6 id="_149">注意：<a class="headerlink" href="#_149" title="Permanent link">&para;</a></h6>
<h6 id="_150">不同序列产生的二叉排序树的形态不一样<a class="headerlink" href="#_150" title="Permanent link">&para;</a></h6>
<h6 id="45-24-53-12-90-12-24-45-90-53">45 24 53 12 90(如上图)和 12 24 45 90 53(如下图)中序遍历的顺序一样，但是形态不一样<a class="headerlink" href="#45-24-53-12-90-12-24-45-90-53" title="Permanent link">&para;</a></h6>
<h6 id="_151">已知插入的 为 ，一共有个节点则需要 次循环<a class="headerlink" href="#_151" title="Permanent link">&para;</a></h6>
<h6 id="_152">所以创建时间效率为<a class="headerlink" href="#_152" title="Permanent link">&para;</a></h6>
<h4 id="bst_11">BST删除<a class="headerlink" href="#bst_11" title="Permanent link">&para;</a></h4>
<h6 id="bst_12">从BST删除一个节点，不能把以该节点为根的子树都删除，只能删除该节点，并且还要保证删除后的<a class="headerlink" href="#bst_12" title="Permanent link">&para;</a></h6>
<h6 id="bst_13">二叉树仍然为BST<a class="headerlink" href="#bst_13" title="Permanent link">&para;</a></h6>
<h6 id="bst_14">BST的删除操作分为三种情况<a class="headerlink" href="#bst_14" title="Permanent link">&para;</a></h6>
<h6 id="ppfpf">令被删除节点的地址为p，p的双亲结点为f且p为f的左孩子<a class="headerlink" href="#ppfpf" title="Permanent link">&para;</a></h6>
<h6 id="pf-lchild-null">当p为叶子节点时，f-&gt;lchild = NULL;<a class="headerlink" href="#pf-lchild-null" title="Permanent link">&para;</a></h6>
<h6 id="pf-lchild-p-lchild-f-lchild-p-rchild">当p只有一个左子树或右子树时，f-&gt;lchild = p-&gt;lchild; 或 f-&gt;lchild = p-&gt;rchild;<a class="headerlink" href="#pf-lchild-p-lchild-f-lchild-p-rchild" title="Permanent link">&para;</a></h6>
<h6 id="p">当p拥有左右子树时,此种情况较为复杂，需要具体分析<a class="headerlink" href="#p" title="Permanent link">&para;</a></h6>
<h6 id="mmm">前置知识，若已知一个二叉排序树的节点m，m的直接前驱节点为m的左子树上右分支最后一个右孩<a class="headerlink" href="#mmm" title="Permanent link">&para;</a></h6>
<h6 id="_153">子为空的节点，如下图<a class="headerlink" href="#_153" title="Permanent link">&para;</a></h6>
<h6 id="nnmn">由图可知，n没有右孩子(如果n一旦有了有孩子，那么m的直接前驱必然会发生变化)，但n可以有左孩<a class="headerlink" href="#nnmn" title="Permanent link">&para;</a></h6>
<h6 id="nm">子(即使有左孩子也并不影响n是m的直接前驱)<a class="headerlink" href="#nm" title="Permanent link">&para;</a></h6>
<h6 id="n_1">同时也要考虑n的左子树没有右分支的情况，如下图<a class="headerlink" href="#n_1" title="Permanent link">&para;</a></h6>
<h6 id="nmn">由图可知，如果n没有右分支，那么m的直接前驱为n<a class="headerlink" href="#nmn" title="Permanent link">&para;</a></h6>
<h6 id="m">利用对称性可知直接后继节点则为：m的右子树上左分支上最后一个左孩子为空的节点<a class="headerlink" href="#m" title="Permanent link">&para;</a></h6>
<h6 id="_154">考虑下图：<a class="headerlink" href="#_154" title="Permanent link">&para;</a></h6>
<h6 id="_155">中序遍历所得到的序列为:<a class="headerlink" href="#_155" title="Permanent link">&para;</a></h6>
<h6 id="p-sp-p-s">由图可知 P 的直接前驱为 S，如果把序列中P删除并且 P 的数据用 S 代替<a class="headerlink" href="#p-sp-p-s" title="Permanent link">&para;</a></h6>
<h6 id="q-">此时 变成了 的直接前驱为 的右子树上的左分支最后一个左孩子为空的节点为 即 Q-<a class="headerlink" href="#q-" title="Permanent link">&para;</a></h6>
<blockquote>
<p>right = S-&gt;left</p>
</blockquote>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-29-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-29-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-29-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-29-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-29-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-29-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-29-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-29-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-29-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-29-10">10</a></span>
<span class="normal"><a href="#__codelineno-29-11">11</a></span>
<span class="normal"><a href="#__codelineno-29-12">12</a></span>
<span class="normal"><a href="#__codelineno-29-13">13</a></span>
<span class="normal"><a href="#__codelineno-29-14">14</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-29-1" name="__codelineno-29-1"></a>void Delete_BST(BSTree *T, BSTKeyType key) {
<a id="__codelineno-29-2" name="__codelineno-29-2"></a>BSTree p = *T;
<a id="__codelineno-29-3" name="__codelineno-29-3"></a>BSTree parent = NULL;
<a id="__codelineno-29-4" name="__codelineno-29-4"></a>while (p) { //若循环结束则直接return，说明没找key
<a id="__codelineno-29-5" name="__codelineno-29-5"></a>if (p-&gt;data.key == key)
<a id="__codelineno-29-6" name="__codelineno-29-6"></a>break; //退出循环此时p指向要删除节点
<a id="__codelineno-29-7" name="__codelineno-29-7"></a>else if (key &lt; p-&gt;data.key) {
<a id="__codelineno-29-8" name="__codelineno-29-8"></a>parent = p; //通过比较key值定位要删除节点
<a id="__codelineno-29-9" name="__codelineno-29-9"></a>p = p-&gt;lchild;
<a id="__codelineno-29-10" name="__codelineno-29-10"></a>} else {
<a id="__codelineno-29-11" name="__codelineno-29-11"></a>parent = p;
<a id="__codelineno-29-12" name="__codelineno-29-12"></a>p = p-&gt;rchild;
<a id="__codelineno-29-13" name="__codelineno-29-13"></a>}
<a id="__codelineno-29-14" name="__codelineno-29-14"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-30-1">1</a></span>
<span class="normal"><a href="#__codelineno-30-2">2</a></span>
<span class="normal"><a href="#__codelineno-30-3">3</a></span>
<span class="normal"><a href="#__codelineno-30-4">4</a></span>
<span class="normal"><a href="#__codelineno-30-5">5</a></span>
<span class="normal"><a href="#__codelineno-30-6">6</a></span>
<span class="normal"><a href="#__codelineno-30-7">7</a></span>
<span class="normal"><a href="#__codelineno-30-8">8</a></span>
<span class="normal"><a href="#__codelineno-30-9">9</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-30-1" name="__codelineno-30-1"></a>if (!p) {
<a id="__codelineno-30-2" name="__codelineno-30-2"></a>return;
<a id="__codelineno-30-3" name="__codelineno-30-3"></a>}
<a id="__codelineno-30-4" name="__codelineno-30-4"></a>//当控制来到次行时，说明p指向了要删除的节点
<a id="__codelineno-30-5" name="__codelineno-30-5"></a>BSTree pfree;
<a id="__codelineno-30-6" name="__codelineno-30-6"></a>BSTree node;
<a id="__codelineno-30-7" name="__codelineno-30-7"></a>if (p-&gt;lchild &amp;&amp; p-&gt;rchild) { //第一种情况 p的左右子树不为空
<a id="__codelineno-30-8" name="__codelineno-30-8"></a>BSTree prior = p-&gt;lchild; // p的直接前驱一定在p的左子树上，所以prior = p的左孩子
<a id="__codelineno-30-9" name="__codelineno-30-9"></a>BSTree parent_prior = p; //需要一个节点来定位prior的双亲结点
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-31-1">1</a></span>
<span class="normal"><a href="#__codelineno-31-2">2</a></span>
<span class="normal"><a href="#__codelineno-31-3">3</a></span>
<span class="normal"><a href="#__codelineno-31-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-31-1" name="__codelineno-31-1"></a>while (prior-&gt;rchild) { //在右分支上寻找要删除节点p的直接前驱
<a id="__codelineno-31-2" name="__codelineno-31-2"></a>parent_prior = prior;
<a id="__codelineno-31-3" name="__codelineno-31-3"></a>prior = prior-&gt;rchild;
<a id="__codelineno-31-4" name="__codelineno-31-4"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-32-1">1</a></span>
<span class="normal"><a href="#__codelineno-32-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-32-1" name="__codelineno-32-1"></a>p-&gt;data.key = prior-&gt;data.key; //把前驱节点的值赋给要删除节点
<a id="__codelineno-32-2" name="__codelineno-32-2"></a>//此时问题转化成了：在保持序列顺序的前提下，如果链接二叉排序树
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-33-1">1</a></span>
<span class="normal"><a href="#__codelineno-33-2">2</a></span>
<span class="normal"><a href="#__codelineno-33-3">3</a></span>
<span class="normal"><a href="#__codelineno-33-4">4</a></span>
<span class="normal"><a href="#__codelineno-33-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-33-1" name="__codelineno-33-1"></a>if (parent_prior != p) {
<a id="__codelineno-33-2" name="__codelineno-33-2"></a>parent_prior-&gt;rchild = prior-&gt;lchild;
<a id="__codelineno-33-3" name="__codelineno-33-3"></a>} else { //此种情况p的直接前驱为p的左孩子，
<a id="__codelineno-33-4" name="__codelineno-33-4"></a>parent_prior-&gt;lchild = prior-&gt;lchild;
<a id="__codelineno-33-5" name="__codelineno-33-5"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-34-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-34-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-34-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-34-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-34-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-34-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-34-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-34-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-34-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-34-10">10</a></span>
<span class="normal"><a href="#__codelineno-34-11">11</a></span>
<span class="normal"><a href="#__codelineno-34-12">12</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-34-1" name="__codelineno-34-1"></a>free(prior);
<a id="__codelineno-34-2" name="__codelineno-34-2"></a>return;
<a id="__codelineno-34-3" name="__codelineno-34-3"></a>} else if (!p-&gt;lchild) {
<a id="__codelineno-34-4" name="__codelineno-34-4"></a>pfree = p; // pfree用于存放 要删除节点的地址
<a id="__codelineno-34-5" name="__codelineno-34-5"></a>node = p-&gt;rchild; // node存放需要链接节点的地址
<a id="__codelineno-34-6" name="__codelineno-34-6"></a>} else if (!p-&gt;rchild) {
<a id="__codelineno-34-7" name="__codelineno-34-7"></a>pfree = p;
<a id="__codelineno-34-8" name="__codelineno-34-8"></a>node = p-&gt;lchild;
<a id="__codelineno-34-9" name="__codelineno-34-9"></a>}
<a id="__codelineno-34-10" name="__codelineno-34-10"></a>//当控制来到此行时，pfree保存要删除节点的地址，node存放需要连接的节点地址
<a id="__codelineno-34-11" name="__codelineno-34-11"></a>if (!parent) { //如果parent域仍然为空，说明要删除的节点为根节点
<a id="__codelineno-34-12" name="__codelineno-34-12"></a>*T = node;
</code></pre></div></td></tr></table></div></p>
<h6 id="_156">测试代码<a class="headerlink" href="#_156" title="Permanent link">&para;</a></h6>
<h3 id="avlbalance-binary-tree_1">AVL树(Balance Binary Tree)<a class="headerlink" href="#avlbalance-binary-tree_1" title="Permanent link">&para;</a></h3>
<h6 id="avl">平衡二叉树排序树(AVL树)：<a class="headerlink" href="#avl" title="Permanent link">&para;</a></h6>
<h6 id="_157">需要满足如下的三个性质:<a class="headerlink" href="#_157" title="Permanent link">&para;</a></h6>
<h6 id="_158">有一个树 ，令 的左子树的高度为 ，右子树高度为<a class="headerlink" href="#_158" title="Permanent link">&para;</a></h6>
<h6 id="_159">平衡因子<a class="headerlink" href="#_159" title="Permanent link">&para;</a></h6>
<h6 id="_160">的左右子树也为平衡二叉排序树<a class="headerlink" href="#_160" title="Permanent link">&para;</a></h6>
<h6 id="_161">如果插入节点使得<a class="headerlink" href="#_161" title="Permanent link">&para;</a></h6>
<h6 id="_162">则必须旋转 为 的节点<a class="headerlink" href="#_162" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-35-1">1</a></span>
<span class="normal"><a href="#__codelineno-35-2">2</a></span>
<span class="normal"><a href="#__codelineno-35-3">3</a></span>
<span class="normal"><a href="#__codelineno-35-4">4</a></span>
<span class="normal"><a href="#__codelineno-35-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-35-1" name="__codelineno-35-1"></a>} else if (parent-&gt;rchild == p) {
<a id="__codelineno-35-2" name="__codelineno-35-2"></a>parent-&gt;rchild = node;
<a id="__codelineno-35-3" name="__codelineno-35-3"></a>} else {
<a id="__codelineno-35-4" name="__codelineno-35-4"></a>parent-&gt;lchild = node;
<a id="__codelineno-35-5" name="__codelineno-35-5"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-36-1">1</a></span>
<span class="normal"><a href="#__codelineno-36-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-36-1" name="__codelineno-36-1"></a>free(pfree);
<a id="__codelineno-36-2" name="__codelineno-36-2"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-37-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-37-1" name="__codelineno-37-1"></a>#include &quot;BSTree.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-38-1">1</a></span>
<span class="normal"><a href="#__codelineno-38-2">2</a></span>
<span class="normal"><a href="#__codelineno-38-3">3</a></span>
<span class="normal"><a href="#__codelineno-38-4">4</a></span>
<span class="normal"><a href="#__codelineno-38-5">5</a></span>
<span class="normal"><a href="#__codelineno-38-6">6</a></span>
<span class="normal"><a href="#__codelineno-38-7">7</a></span>
<span class="normal"><a href="#__codelineno-38-8">8</a></span>
<span class="normal"><a href="#__codelineno-38-9">9</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-38-1" name="__codelineno-38-1"></a>int main(void) {
<a id="__codelineno-38-2" name="__codelineno-38-2"></a>BSTree T = NULL;
<a id="__codelineno-38-3" name="__codelineno-38-3"></a>Creat_BST(&amp;T);
<a id="__codelineno-38-4" name="__codelineno-38-4"></a>Delete_BST(&amp;T, 53 );
<a id="__codelineno-38-5" name="__codelineno-38-5"></a>Delete_BST(&amp;T, 12 );
<a id="__codelineno-38-6" name="__codelineno-38-6"></a>InOrder_BST(T);
<a id="__codelineno-38-7" name="__codelineno-38-7"></a>system(&quot;pause&quot;);
<a id="__codelineno-38-8" name="__codelineno-38-8"></a>return 0 ;
<a id="__codelineno-38-9" name="__codelineno-38-9"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-39-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-39-1" name="__codelineno-39-1"></a>// 45 24 53 12 90 0
</code></pre></div></td></tr></table></div></p>
<h6 id="1_2">定理 1 ：<a class="headerlink" href="#1_2" title="Permanent link">&para;</a></h6>
<h6 id="_163">若一个 树 在添加一个节点 后， 则 的双亲结点 的 不能为 叶子节点除外<a class="headerlink" href="#_163" title="Permanent link">&para;</a></h6>
<h6 id="_164">令一颗 树 在添加一个节点 后 ，且 的双亲节点 的<a class="headerlink" href="#_164" title="Permanent link">&para;</a></h6>
<h6 id="_165">若删去 节点，则 的高度并未发生变化，且 未发生变化<a class="headerlink" href="#_165" title="Permanent link">&para;</a></h6>
<h6 id="_166">即 说明 在添加 节点之前不是 树<a class="headerlink" href="#_166" title="Permanent link">&para;</a></h6>
<h6 id="_167">不是一颗 树<a class="headerlink" href="#_167" title="Permanent link">&para;</a></h6>
<h4 id="ll_1">LL型旋转(右旋转)<a class="headerlink" href="#ll_1" title="Permanent link">&para;</a></h4>
<h6 id="_168">情况<a class="headerlink" href="#_168" title="Permanent link">&para;</a></h6>
<h6 id="_169">且 ，以 的左孩子 为中心，向右旋转<a class="headerlink" href="#_169" title="Permanent link">&para;</a></h6>
<h6 id="_170">如下图 为插入节点<a class="headerlink" href="#_170" title="Permanent link">&para;</a></h6>
<h6 id="2_2">定理 2<a class="headerlink" href="#2_2" title="Permanent link">&para;</a></h6>
<h6 id="_171">即将进行 旋转的树 ， 且<a class="headerlink" href="#_171" title="Permanent link">&para;</a></h6>
<h6 id="_172">则旋转后<a class="headerlink" href="#_172" title="Permanent link">&para;</a></h6>
<h6 id="_173">情况<a class="headerlink" href="#_173" title="Permanent link">&para;</a></h6>
<h6 id="_174">且 以 的左孩子 为中心向右旋转，此时 成为 的左孩子， 称成为 的左孩子<a class="headerlink" href="#_174" title="Permanent link">&para;</a></h6>
<h6 id="_175">则 节点脱落 使 成为 的右孩子<a class="headerlink" href="#_175" title="Permanent link">&para;</a></h6>
<h6 id="_176">如下图 为插入节点<a class="headerlink" href="#_176" title="Permanent link">&para;</a></h6>
<h6 id="3">定理 3<a class="headerlink" href="#3" title="Permanent link">&para;</a></h6>
<h6 id="_177">即将进行 旋转的树 ， 且<a class="headerlink" href="#_177" title="Permanent link">&para;</a></h6>
<h6 id="_178">则旋转后<a class="headerlink" href="#_178" title="Permanent link">&para;</a></h6>
<h4 id="rr_1">RR旋转(左旋转)<a class="headerlink" href="#rr_1" title="Permanent link">&para;</a></h4>
<h6 id="_179">情况<a class="headerlink" href="#_179" title="Permanent link">&para;</a></h6>
<h6 id="_180">且 ，以 的右孩子 为中心，向左旋转<a class="headerlink" href="#_180" title="Permanent link">&para;</a></h6>
<h6 id="_181">如下图 为插入节点<a class="headerlink" href="#_181" title="Permanent link">&para;</a></h6>
<h6 id="4">定理 4<a class="headerlink" href="#4" title="Permanent link">&para;</a></h6>
<h6 id="_182">即将进行 旋转的树 ， 且<a class="headerlink" href="#_182" title="Permanent link">&para;</a></h6>
<h6 id="_183">则旋转后<a class="headerlink" href="#_183" title="Permanent link">&para;</a></h6>
<h6 id="_184">情况<a class="headerlink" href="#_184" title="Permanent link">&para;</a></h6>
<h6 id="_185">且 以 的右孩子 为中心向左旋转，此时 成为 的右孩子， 称成为 的左孩子<a class="headerlink" href="#_185" title="Permanent link">&para;</a></h6>
<h6 id="_186">则 节点脱落使 成为 的右孩子<a class="headerlink" href="#_186" title="Permanent link">&para;</a></h6>
<h6 id="_187">如下图 为插入节点<a class="headerlink" href="#_187" title="Permanent link">&para;</a></h6>
<h6 id="5">定理 5<a class="headerlink" href="#5" title="Permanent link">&para;</a></h6>
<h6 id="_188">即将进行 旋转的树 ， 且<a class="headerlink" href="#_188" title="Permanent link">&para;</a></h6>
<h6 id="_189">则旋转后<a class="headerlink" href="#_189" title="Permanent link">&para;</a></h6>
<h4 id="lr_1">LR旋转(左右旋转)<a class="headerlink" href="#lr_1" title="Permanent link">&para;</a></h4>
<h6 id="_190">情况<a class="headerlink" href="#_190" title="Permanent link">&para;</a></h6>
<h6 id="_191">即将进行旋转的树 且 ，则 旋转 ，再 旋转<a class="headerlink" href="#_191" title="Permanent link">&para;</a></h6>
<h6 id="_192">如下图， 为插入节点<a class="headerlink" href="#_192" title="Permanent link">&para;</a></h6>
<h6 id="6">定理 6<a class="headerlink" href="#6" title="Permanent link">&para;</a></h6>
<h6 id="_193">即将进行 旋转的树 ， 且<a class="headerlink" href="#_193" title="Permanent link">&para;</a></h6>
<h6 id="_194">则 旋转后<a class="headerlink" href="#_194" title="Permanent link">&para;</a></h6>
<h6 id="_195">情况<a class="headerlink" href="#_195" title="Permanent link">&para;</a></h6>
<h6 id="_196">节点 有右孩子 ，即<a class="headerlink" href="#_196" title="Permanent link">&para;</a></h6>
<h6 id="_197">即将进行旋转的树 且 ，则 旋转 节点脱落，再 旋转 ，使 成为 的左孩子<a class="headerlink" href="#_197" title="Permanent link">&para;</a></h6>
<h6 id="_198">如下图， 为插入节点<a class="headerlink" href="#_198" title="Permanent link">&para;</a></h6>
<h6 id="7">定理 7<a class="headerlink" href="#7" title="Permanent link">&para;</a></h6>
<h6 id="_199">即将进行 旋转的树 ， 且<a class="headerlink" href="#_199" title="Permanent link">&para;</a></h6>
<h6 id="_200">则 旋转后<a class="headerlink" href="#_200" title="Permanent link">&para;</a></h6>
<h6 id="_201">情况<a class="headerlink" href="#_201" title="Permanent link">&para;</a></h6>
<h6 id="_202">节点 有左孩子 ，即<a class="headerlink" href="#_202" title="Permanent link">&para;</a></h6>
<h6 id="_203">即将进行 旋转的树 且 ，则 旋转 节点脱落，再 旋转 ，使 成为 的有孩子<a class="headerlink" href="#_203" title="Permanent link">&para;</a></h6>
<h6 id="_204">如下图， 为插入节点<a class="headerlink" href="#_204" title="Permanent link">&para;</a></h6>
<h6 id="8">定理 8<a class="headerlink" href="#8" title="Permanent link">&para;</a></h6>
<h6 id="_205">即将进行 旋转的树 ， 且<a class="headerlink" href="#_205" title="Permanent link">&para;</a></h6>
<h6 id="_206">则 旋转后<a class="headerlink" href="#_206" title="Permanent link">&para;</a></h6>
<h4 id="rl_1">RL旋转(右左旋转)<a class="headerlink" href="#rl_1" title="Permanent link">&para;</a></h4>
<h6 id="_207">情况<a class="headerlink" href="#_207" title="Permanent link">&para;</a></h6>
<h6 id="_208">即将进行 旋转的树 且 ，则 旋转 ，再 旋转<a class="headerlink" href="#_208" title="Permanent link">&para;</a></h6>
<h6 id="_209">如下图， 为插入节点<a class="headerlink" href="#_209" title="Permanent link">&para;</a></h6>
<h6 id="9">定理 9<a class="headerlink" href="#9" title="Permanent link">&para;</a></h6>
<h6 id="_210">即将进行 旋转的树 ， 且<a class="headerlink" href="#_210" title="Permanent link">&para;</a></h6>
<h6 id="_211">则 旋转后<a class="headerlink" href="#_211" title="Permanent link">&para;</a></h6>
<h6 id="_212">情况<a class="headerlink" href="#_212" title="Permanent link">&para;</a></h6>
<h6 id="_213">节点 有左孩子 ，即<a class="headerlink" href="#_213" title="Permanent link">&para;</a></h6>
<h6 id="_214">即将进行 旋转的树 且 ，则 旋转 节点脱落，再 旋转 ，使 成为 的左孩子<a class="headerlink" href="#_214" title="Permanent link">&para;</a></h6>
<h6 id="_215">如下图， 为插入节点<a class="headerlink" href="#_215" title="Permanent link">&para;</a></h6>
<h6 id="10">定理 10<a class="headerlink" href="#10" title="Permanent link">&para;</a></h6>
<h6 id="_216">即将进行 旋转的树 ， 且<a class="headerlink" href="#_216" title="Permanent link">&para;</a></h6>
<h6 id="_217">则 旋转后<a class="headerlink" href="#_217" title="Permanent link">&para;</a></h6>
<h6 id="_218">情况<a class="headerlink" href="#_218" title="Permanent link">&para;</a></h6>
<h6 id="_219">节点 有右孩子 ，即<a class="headerlink" href="#_219" title="Permanent link">&para;</a></h6>
<h6 id="_220">即将进行 旋转的树 且 ，则 旋转 节点脱落，再 旋转 ，使 成为 的左孩子<a class="headerlink" href="#_220" title="Permanent link">&para;</a></h6>
<h6 id="_221">如下图， 为插入节点<a class="headerlink" href="#_221" title="Permanent link">&para;</a></h6>
<h6 id="11">定理 11<a class="headerlink" href="#11" title="Permanent link">&para;</a></h6>
<h6 id="_222">即将进行 旋转的树 ， 且<a class="headerlink" href="#_222" title="Permanent link">&para;</a></h6>
<h6 id="_223">则 旋转后<a class="headerlink" href="#_223" title="Permanent link">&para;</a></h6>
<h4 id="_224">总结<a class="headerlink" href="#_224" title="Permanent link">&para;</a></h4>
<h6 id="_225">如果一个 树 参入一个节点使得 的某个子树的 ，则需要对该子树进行旋转<a class="headerlink" href="#_225" title="Permanent link">&para;</a></h6>
<h6 id="_226">令这颗子树为<a class="headerlink" href="#_226" title="Permanent link">&para;</a></h6>
<h6 id="_227">如果 ，且 的左子树 为 ，则对 进行 旋转<a class="headerlink" href="#_227" title="Permanent link">&para;</a></h6>
<h6 id="_228">如果 ，且 的左子树 为 ，则对 进行 旋转<a class="headerlink" href="#_228" title="Permanent link">&para;</a></h6>
<h6 id="_229">如果 ，且 的左子树 为 ，则对 进行 旋转<a class="headerlink" href="#_229" title="Permanent link">&para;</a></h6>
<h6 id="_230">如果 ，且 的左子树 为 ，则对 进行 旋转<a class="headerlink" href="#_230" title="Permanent link">&para;</a></h6>
<h4 id="_231">代码实现<a class="headerlink" href="#_231" title="Permanent link">&para;</a></h4>
<h6 id="_232">数据类型：<a class="headerlink" href="#_232" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-40-1">1</a></span>
<span class="normal"><a href="#__codelineno-40-2">2</a></span>
<span class="normal"><a href="#__codelineno-40-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-40-1" name="__codelineno-40-1"></a>#define LH 1 //平衡因子 1
<a id="__codelineno-40-2" name="__codelineno-40-2"></a>#define EH 0 //平衡因子 0
<a id="__codelineno-40-3" name="__codelineno-40-3"></a>#define RH -1 //平衡因子-1
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-41-1">1</a></span>
<span class="normal"><a href="#__codelineno-41-2">2</a></span>
<span class="normal"><a href="#__codelineno-41-3">3</a></span>
<span class="normal"><a href="#__codelineno-41-4">4</a></span>
<span class="normal"><a href="#__codelineno-41-5">5</a></span>
<span class="normal"><a href="#__codelineno-41-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-41-1" name="__codelineno-41-1"></a>typedef int AVLElemtype;
<a id="__codelineno-41-2" name="__codelineno-41-2"></a>typedef struct __AVLNode {
<a id="__codelineno-41-3" name="__codelineno-41-3"></a>AVLElemtype key;
<a id="__codelineno-41-4" name="__codelineno-41-4"></a>int bf; // balence factor
<a id="__codelineno-41-5" name="__codelineno-41-5"></a>__AVLNode *lchild, *rchild;
<a id="__codelineno-41-6" name="__codelineno-41-6"></a>} AVLNode, *AVLTree;
</code></pre></div></td></tr></table></div></p>
<h6 id="llrr_1">左旋转和右旋转(参照LL，RR旋转)<a class="headerlink" href="#llrr_1" title="Permanent link">&para;</a></h6>
<h6 id="_233">左旋转树 代表着：以 的右孩子为中心，向左旋转<a class="headerlink" href="#_233" title="Permanent link">&para;</a></h6>
<h6 id="_234">右旋转树 代表着：以 的左孩子为中心，向右旋转<a class="headerlink" href="#_234" title="Permanent link">&para;</a></h6>
<h4 id="_235">左平衡和右平衡<a class="headerlink" href="#_235" title="Permanent link">&para;</a></h4>
<h6 id="lllrrrrl">根据总结可知，大体上可以分成左平衡(LL,LR)和右平衡(RR,RL)<a class="headerlink" href="#lllrrrrl" title="Permanent link">&para;</a></h6>
<h6 id="_236">左平衡<a class="headerlink" href="#_236" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-42-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-42-1" name="__codelineno-42-1"></a>#include &quot;AVLTree.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-43-1">1</a></span>
<span class="normal"><a href="#__codelineno-43-2">2</a></span>
<span class="normal"><a href="#__codelineno-43-3">3</a></span>
<span class="normal"><a href="#__codelineno-43-4">4</a></span>
<span class="normal"><a href="#__codelineno-43-5">5</a></span>
<span class="normal"><a href="#__codelineno-43-6">6</a></span>
<span class="normal"><a href="#__codelineno-43-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-43-1" name="__codelineno-43-1"></a>void LeftRotate(AVLTree *T) {
<a id="__codelineno-43-2" name="__codelineno-43-2"></a>AVLTree Rchild = (*T)-&gt;rchild; // Rchild代表T的右孩子
<a id="__codelineno-43-3" name="__codelineno-43-3"></a>(*T)-&gt;rchild = Rchild-&gt;lchild; //参照RR旋转
<a id="__codelineno-43-4" name="__codelineno-43-4"></a>Rchild-&gt;lchild = *T; //旋转后T成为Rchild的左孩子(定理3)
<a id="__codelineno-43-5" name="__codelineno-43-5"></a>*T = Rchild;
<a id="__codelineno-43-6" name="__codelineno-43-6"></a>//! 上行代码不可省略，如果省略，则只改动了节点间的关系，而未改变指针之间的关系
<a id="__codelineno-43-7" name="__codelineno-43-7"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-44-1">1</a></span>
<span class="normal"><a href="#__codelineno-44-2">2</a></span>
<span class="normal"><a href="#__codelineno-44-3">3</a></span>
<span class="normal"><a href="#__codelineno-44-4">4</a></span>
<span class="normal"><a href="#__codelineno-44-5">5</a></span>
<span class="normal"><a href="#__codelineno-44-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-44-1" name="__codelineno-44-1"></a>void RightRotate(AVLTree *T) {
<a id="__codelineno-44-2" name="__codelineno-44-2"></a>AVLTree Lchild = (*T)-&gt;lchild;
<a id="__codelineno-44-3" name="__codelineno-44-3"></a>(*T)-&gt;lchild = Lchild-&gt;rchild;
<a id="__codelineno-44-4" name="__codelineno-44-4"></a>Lchild-&gt;rchild = *T;
<a id="__codelineno-44-5" name="__codelineno-44-5"></a>*T = Lchild;
<a id="__codelineno-44-6" name="__codelineno-44-6"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-45-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-45-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-45-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-45-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-45-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-45-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-45-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-45-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-45-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-45-10">10</a></span>
<span class="normal"><a href="#__codelineno-45-11">11</a></span>
<span class="normal"><a href="#__codelineno-45-12">12</a></span>
<span class="normal"><a href="#__codelineno-45-13">13</a></span>
<span class="normal"><a href="#__codelineno-45-14">14</a></span>
<span class="normal"><a href="#__codelineno-45-15">15</a></span>
<span class="normal"><a href="#__codelineno-45-16">16</a></span>
<span class="normal"><a href="#__codelineno-45-17">17</a></span>
<span class="normal"><a href="#__codelineno-45-18">18</a></span>
<span class="normal"><a href="#__codelineno-45-19">19</a></span>
<span class="normal"><a href="#__codelineno-45-20">20</a></span>
<span class="normal"><a href="#__codelineno-45-21">21</a></span>
<span class="normal"><a href="#__codelineno-45-22">22</a></span>
<span class="normal"><a href="#__codelineno-45-23">23</a></span>
<span class="normal"><a href="#__codelineno-45-24">24</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-45-1" name="__codelineno-45-1"></a>void LeftBalance(AVLTree *T) {
<a id="__codelineno-45-2" name="__codelineno-45-2"></a>AVLTree L = (*T)-&gt;lchild; // L-&gt;bf绝对不可能为EH(定理1)
<a id="__codelineno-45-3" name="__codelineno-45-3"></a>AVLTree Lr; // T的左孩子的右孩子
<a id="__codelineno-45-4" name="__codelineno-45-4"></a>switch (L-&gt;bf) {
<a id="__codelineno-45-5" name="__codelineno-45-5"></a>// LL 旋转
<a id="__codelineno-45-6" name="__codelineno-45-6"></a>case LH:
<a id="__codelineno-45-7" name="__codelineno-45-7"></a>//! 定理 2
<a id="__codelineno-45-8" name="__codelineno-45-8"></a>(*T)-&gt;bf = L-&gt;bf = EH;
<a id="__codelineno-45-9" name="__codelineno-45-9"></a>//! 此行的上下两行不可对调
<a id="__codelineno-45-10" name="__codelineno-45-10"></a>RightRotate(T);
<a id="__codelineno-45-11" name="__codelineno-45-11"></a>break;
<a id="__codelineno-45-12" name="__codelineno-45-12"></a>case RH:
<a id="__codelineno-45-13" name="__codelineno-45-13"></a>// LR旋转
<a id="__codelineno-45-14" name="__codelineno-45-14"></a>Lr = L-&gt;rchild; //
<a id="__codelineno-45-15" name="__codelineno-45-15"></a>switch (Lr-&gt;bf) {
<a id="__codelineno-45-16" name="__codelineno-45-16"></a>case LH:
<a id="__codelineno-45-17" name="__codelineno-45-17"></a>//定理 8
<a id="__codelineno-45-18" name="__codelineno-45-18"></a>(*T)-&gt;bf = RH;
<a id="__codelineno-45-19" name="__codelineno-45-19"></a>L-&gt;bf = EH;
<a id="__codelineno-45-20" name="__codelineno-45-20"></a>break;
<a id="__codelineno-45-21" name="__codelineno-45-21"></a>case EH:
<a id="__codelineno-45-22" name="__codelineno-45-22"></a>//定理 6
<a id="__codelineno-45-23" name="__codelineno-45-23"></a>(*T)-&gt;bf = L-&gt;bf = EH;
<a id="__codelineno-45-24" name="__codelineno-45-24"></a>break;
</code></pre></div></td></tr></table></div></p>
<h6 id="_237">右平衡<a class="headerlink" href="#_237" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-46-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-46-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-46-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-46-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-46-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-46-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-46-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-46-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-46-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-46-10">10</a></span>
<span class="normal"><a href="#__codelineno-46-11">11</a></span>
<span class="normal"><a href="#__codelineno-46-12">12</a></span>
<span class="normal"><a href="#__codelineno-46-13">13</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-46-1" name="__codelineno-46-1"></a>case RH:
<a id="__codelineno-46-2" name="__codelineno-46-2"></a>//定理 7
<a id="__codelineno-46-3" name="__codelineno-46-3"></a>(*T)-&gt;bf = EH;
<a id="__codelineno-46-4" name="__codelineno-46-4"></a>L-&gt;bf = LH;
<a id="__codelineno-46-5" name="__codelineno-46-5"></a>break;
<a id="__codelineno-46-6" name="__codelineno-46-6"></a>}
<a id="__codelineno-46-7" name="__codelineno-46-7"></a>//根据定理 6 ， 7 ， 8 可知，旋转后Lr的BF必定为 0
<a id="__codelineno-46-8" name="__codelineno-46-8"></a>Lr-&gt;bf = EH;
<a id="__codelineno-46-9" name="__codelineno-46-9"></a>LeftRotate(&amp;(*T)-&gt;lchild);
<a id="__codelineno-46-10" name="__codelineno-46-10"></a>RightRotate(T);
<a id="__codelineno-46-11" name="__codelineno-46-11"></a>break;
<a id="__codelineno-46-12" name="__codelineno-46-12"></a>}
<a id="__codelineno-46-13" name="__codelineno-46-13"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-47-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-47-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-47-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-47-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-47-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-47-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-47-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-47-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-47-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-47-10">10</a></span>
<span class="normal"><a href="#__codelineno-47-11">11</a></span>
<span class="normal"><a href="#__codelineno-47-12">12</a></span>
<span class="normal"><a href="#__codelineno-47-13">13</a></span>
<span class="normal"><a href="#__codelineno-47-14">14</a></span>
<span class="normal"><a href="#__codelineno-47-15">15</a></span>
<span class="normal"><a href="#__codelineno-47-16">16</a></span>
<span class="normal"><a href="#__codelineno-47-17">17</a></span>
<span class="normal"><a href="#__codelineno-47-18">18</a></span>
<span class="normal"><a href="#__codelineno-47-19">19</a></span>
<span class="normal"><a href="#__codelineno-47-20">20</a></span>
<span class="normal"><a href="#__codelineno-47-21">21</a></span>
<span class="normal"><a href="#__codelineno-47-22">22</a></span>
<span class="normal"><a href="#__codelineno-47-23">23</a></span>
<span class="normal"><a href="#__codelineno-47-24">24</a></span>
<span class="normal"><a href="#__codelineno-47-25">25</a></span>
<span class="normal"><a href="#__codelineno-47-26">26</a></span>
<span class="normal"><a href="#__codelineno-47-27">27</a></span>
<span class="normal"><a href="#__codelineno-47-28">28</a></span>
<span class="normal"><a href="#__codelineno-47-29">29</a></span>
<span class="normal"><a href="#__codelineno-47-30">30</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-47-1" name="__codelineno-47-1"></a>// 和左平衡同理
<a id="__codelineno-47-2" name="__codelineno-47-2"></a>void RightBalance(AVLTree *T) {
<a id="__codelineno-47-3" name="__codelineno-47-3"></a>AVLTree R = (*T)-&gt;rchild;
<a id="__codelineno-47-4" name="__codelineno-47-4"></a>AVLTree Rl;
<a id="__codelineno-47-5" name="__codelineno-47-5"></a>switch (R-&gt;bf) {
<a id="__codelineno-47-6" name="__codelineno-47-6"></a>case RH:
<a id="__codelineno-47-7" name="__codelineno-47-7"></a>(*T)-&gt;bf = R-&gt;bf = EH;
<a id="__codelineno-47-8" name="__codelineno-47-8"></a>LeftRotate(T);
<a id="__codelineno-47-9" name="__codelineno-47-9"></a>break;
<a id="__codelineno-47-10" name="__codelineno-47-10"></a>case LH: {
<a id="__codelineno-47-11" name="__codelineno-47-11"></a>Rl = R-&gt;lchild; //
<a id="__codelineno-47-12" name="__codelineno-47-12"></a>switch (Rl-&gt;bf) {
<a id="__codelineno-47-13" name="__codelineno-47-13"></a>case LH:
<a id="__codelineno-47-14" name="__codelineno-47-14"></a>(*T)-&gt;bf = EH;
<a id="__codelineno-47-15" name="__codelineno-47-15"></a>R-&gt;bf = RH;
<a id="__codelineno-47-16" name="__codelineno-47-16"></a>break;
<a id="__codelineno-47-17" name="__codelineno-47-17"></a>case EH:
<a id="__codelineno-47-18" name="__codelineno-47-18"></a>(*T)-&gt;bf = R-&gt;bf = EH;
<a id="__codelineno-47-19" name="__codelineno-47-19"></a>break;
<a id="__codelineno-47-20" name="__codelineno-47-20"></a>case RH:
<a id="__codelineno-47-21" name="__codelineno-47-21"></a>(*T)-&gt;bf = LH;
<a id="__codelineno-47-22" name="__codelineno-47-22"></a>R-&gt;bf = EH;
<a id="__codelineno-47-23" name="__codelineno-47-23"></a>break;
<a id="__codelineno-47-24" name="__codelineno-47-24"></a>}
<a id="__codelineno-47-25" name="__codelineno-47-25"></a>Rl-&gt;bf = EH;
<a id="__codelineno-47-26" name="__codelineno-47-26"></a>RightRotate(&amp;(*T)-&gt;rchild);
<a id="__codelineno-47-27" name="__codelineno-47-27"></a>LeftRotate(T);
<a id="__codelineno-47-28" name="__codelineno-47-28"></a>}
<a id="__codelineno-47-29" name="__codelineno-47-29"></a>}
<a id="__codelineno-47-30" name="__codelineno-47-30"></a>}
</code></pre></div></td></tr></table></div></p>
<h6 id="_238">插入节点和及时平衡<a class="headerlink" href="#_238" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-48-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-48-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-48-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-48-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-48-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-48-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-48-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-48-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-48-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-48-10">10</a></span>
<span class="normal"><a href="#__codelineno-48-11">11</a></span>
<span class="normal"><a href="#__codelineno-48-12">12</a></span>
<span class="normal"><a href="#__codelineno-48-13">13</a></span>
<span class="normal"><a href="#__codelineno-48-14">14</a></span>
<span class="normal"><a href="#__codelineno-48-15">15</a></span>
<span class="normal"><a href="#__codelineno-48-16">16</a></span>
<span class="normal"><a href="#__codelineno-48-17">17</a></span>
<span class="normal"><a href="#__codelineno-48-18">18</a></span>
<span class="normal"><a href="#__codelineno-48-19">19</a></span>
<span class="normal"><a href="#__codelineno-48-20">20</a></span>
<span class="normal"><a href="#__codelineno-48-21">21</a></span>
<span class="normal"><a href="#__codelineno-48-22">22</a></span>
<span class="normal"><a href="#__codelineno-48-23">23</a></span>
<span class="normal"><a href="#__codelineno-48-24">24</a></span>
<span class="normal"><a href="#__codelineno-48-25">25</a></span>
<span class="normal"><a href="#__codelineno-48-26">26</a></span>
<span class="normal"><a href="#__codelineno-48-27">27</a></span>
<span class="normal"><a href="#__codelineno-48-28">28</a></span>
<span class="normal"><a href="#__codelineno-48-29">29</a></span>
<span class="normal"><a href="#__codelineno-48-30">30</a></span>
<span class="normal"><a href="#__codelineno-48-31">31</a></span>
<span class="normal"><a href="#__codelineno-48-32">32</a></span>
<span class="normal"><a href="#__codelineno-48-33">33</a></span>
<span class="normal"><a href="#__codelineno-48-34">34</a></span>
<span class="normal"><a href="#__codelineno-48-35">35</a></span>
<span class="normal"><a href="#__codelineno-48-36">36</a></span>
<span class="normal"><a href="#__codelineno-48-37">37</a></span>
<span class="normal"><a href="#__codelineno-48-38">38</a></span>
<span class="normal"><a href="#__codelineno-48-39">39</a></span>
<span class="normal"><a href="#__codelineno-48-40">40</a></span>
<span class="normal"><a href="#__codelineno-48-41">41</a></span>
<span class="normal"><a href="#__codelineno-48-42">42</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-48-1" name="__codelineno-48-1"></a>//! 全局变量taller记录高度是否发生变化，如果未发生变化为false，发生则true
<a id="__codelineno-48-2" name="__codelineno-48-2"></a>bool __taller = false;
<a id="__codelineno-48-3" name="__codelineno-48-3"></a>void Insert_AVL(AVLTree *T, AVLElemtype key, bool *taller) {
<a id="__codelineno-48-4" name="__codelineno-48-4"></a>// T为要插入节点的双亲节点，key为要插入数据的值
<a id="__codelineno-48-5" name="__codelineno-48-5"></a>//若T为空，则创建一个节点，并初始化
<a id="__codelineno-48-6" name="__codelineno-48-6"></a>if (!(*T)) {
<a id="__codelineno-48-7" name="__codelineno-48-7"></a>*T = (AVLTree)malloc(sizeof(AVLNode));
<a id="__codelineno-48-8" name="__codelineno-48-8"></a>(*T)-&gt;lchild = (*T)-&gt;rchild = NULL;
<a id="__codelineno-48-9" name="__codelineno-48-9"></a>(*T)-&gt;bf = EH;
<a id="__codelineno-48-10" name="__codelineno-48-10"></a>(*T)-&gt;key = key;
<a id="__codelineno-48-11" name="__codelineno-48-11"></a>*taller = true;
<a id="__codelineno-48-12" name="__codelineno-48-12"></a>}
<a id="__codelineno-48-13" name="__codelineno-48-13"></a>if (key &lt; (*T)-&gt;key) {
<a id="__codelineno-48-14" name="__codelineno-48-14"></a>//如果插入值小于T的key值，则递归T的左子树，直到找到一个NULL节点
<a id="__codelineno-48-15" name="__codelineno-48-15"></a>Insert_AVL(&amp;(*T)-&gt;lchild, key, taller);
<a id="__codelineno-48-16" name="__codelineno-48-16"></a>//判断树是否变高了
<a id="__codelineno-48-17" name="__codelineno-48-17"></a>if (*taller) {
<a id="__codelineno-48-18" name="__codelineno-48-18"></a>//以T为根插入节点，则T的bf发生变化
<a id="__codelineno-48-19" name="__codelineno-48-19"></a>switch ((*T)-&gt;bf) {
<a id="__codelineno-48-20" name="__codelineno-48-20"></a>case LH:
<a id="__codelineno-48-21" name="__codelineno-48-21"></a>// T的bf == -1，向T的左孩子插入节点则T的bf = 2，需要左平衡
<a id="__codelineno-48-22" name="__codelineno-48-22"></a>LeftBalance(T);
<a id="__codelineno-48-23" name="__codelineno-48-23"></a>*taller = false;
<a id="__codelineno-48-24" name="__codelineno-48-24"></a>//经过平衡后taller = false，因为T经过左调整后，变得平衡了
<a id="__codelineno-48-25" name="__codelineno-48-25"></a>break;
<a id="__codelineno-48-26" name="__codelineno-48-26"></a>case EH:
<a id="__codelineno-48-27" name="__codelineno-48-27"></a>// 如果T的bf == 0，向T的左孩子插入节点，则T的bf = 1
<a id="__codelineno-48-28" name="__codelineno-48-28"></a>(*T)-&gt;bf = LH;
<a id="__codelineno-48-29" name="__codelineno-48-29"></a>//此时T的高度发生变化
<a id="__codelineno-48-30" name="__codelineno-48-30"></a>*taller = true;
<a id="__codelineno-48-31" name="__codelineno-48-31"></a>break;
<a id="__codelineno-48-32" name="__codelineno-48-32"></a>case RH:
<a id="__codelineno-48-33" name="__codelineno-48-33"></a>// 如果T的bf == -1，向T的左孩子插入节点，则T的bf = 0
<a id="__codelineno-48-34" name="__codelineno-48-34"></a>(*T)-&gt;bf = EH;
<a id="__codelineno-48-35" name="__codelineno-48-35"></a>//高度未发生变化
<a id="__codelineno-48-36" name="__codelineno-48-36"></a>*taller = false;
<a id="__codelineno-48-37" name="__codelineno-48-37"></a>break;
<a id="__codelineno-48-38" name="__codelineno-48-38"></a>}
<a id="__codelineno-48-39" name="__codelineno-48-39"></a>}
<a id="__codelineno-48-40" name="__codelineno-48-40"></a>} else {
<a id="__codelineno-48-41" name="__codelineno-48-41"></a>//和上面同理
<a id="__codelineno-48-42" name="__codelineno-48-42"></a>Insert_AVL(&amp;(*T)-&gt;rchild, key, taller);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-49-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-49-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-49-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-49-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-49-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-49-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-49-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-49-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-49-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-49-10">10</a></span>
<span class="normal"><a href="#__codelineno-49-11">11</a></span>
<span class="normal"><a href="#__codelineno-49-12">12</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-49-1" name="__codelineno-49-1"></a>if (*taller) {
<a id="__codelineno-49-2" name="__codelineno-49-2"></a>switch ((*T)-&gt;bf) {
<a id="__codelineno-49-3" name="__codelineno-49-3"></a>case LH:
<a id="__codelineno-49-4" name="__codelineno-49-4"></a>(*T)-&gt;bf = EH;
<a id="__codelineno-49-5" name="__codelineno-49-5"></a>*taller = false;
<a id="__codelineno-49-6" name="__codelineno-49-6"></a>break;
<a id="__codelineno-49-7" name="__codelineno-49-7"></a>case EH:
<a id="__codelineno-49-8" name="__codelineno-49-8"></a>(*T)-&gt;bf = RH;
<a id="__codelineno-49-9" name="__codelineno-49-9"></a>*taller = true;
<a id="__codelineno-49-10" name="__codelineno-49-10"></a>break;
<a id="__codelineno-49-11" name="__codelineno-49-11"></a>case RH:
<a id="__codelineno-49-12" name="__codelineno-49-12"></a>RightBalance(T);
</code></pre></div></td></tr></table></div></p>
<h4 id="_239">测试代码<a class="headerlink" href="#_239" title="Permanent link">&para;</a></h4>
<h6 id="output">output:<a class="headerlink" href="#output" title="Permanent link">&para;</a></h6>
<h3 id="hash-table_2">哈希表(Hash Table)<a class="headerlink" href="#hash-table_2" title="Permanent link">&para;</a></h3>
<h6 id="_240">记录存储位置与关键字之间存在对应关系<a class="headerlink" href="#_240" title="Permanent link">&para;</a></h6>
<h6 id="_241">用 表示<a class="headerlink" href="#_241" title="Permanent link">&para;</a></h6>
<h6 id="_242">优点：查找效率高<a class="headerlink" href="#_242" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-50-1">1</a></span>
<span class="normal"><a href="#__codelineno-50-2">2</a></span>
<span class="normal"><a href="#__codelineno-50-3">3</a></span>
<span class="normal"><a href="#__codelineno-50-4">4</a></span>
<span class="normal"><a href="#__codelineno-50-5">5</a></span>
<span class="normal"><a href="#__codelineno-50-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-50-1" name="__codelineno-50-1"></a>*taller = false;
<a id="__codelineno-50-2" name="__codelineno-50-2"></a>break;
<a id="__codelineno-50-3" name="__codelineno-50-3"></a>}
<a id="__codelineno-50-4" name="__codelineno-50-4"></a>}
<a id="__codelineno-50-5" name="__codelineno-50-5"></a>}
<a id="__codelineno-50-6" name="__codelineno-50-6"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-51-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-51-1" name="__codelineno-51-1"></a>#include &quot;AVLTree.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-52-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-52-1" name="__codelineno-52-1"></a>void Creat_AVL(AVLTree *T);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-53-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-53-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-53-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-53-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-53-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-53-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-53-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-53-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-53-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-53-10">10</a></span>
<span class="normal"><a href="#__codelineno-53-11">11</a></span>
<span class="normal"><a href="#__codelineno-53-12">12</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-53-1" name="__codelineno-53-1"></a>extern bool __taller;
<a id="__codelineno-53-2" name="__codelineno-53-2"></a>int main(void) {
<a id="__codelineno-53-3" name="__codelineno-53-3"></a>AVLTree T = NULL;
<a id="__codelineno-53-4" name="__codelineno-53-4"></a>Creat_AVL(&amp;T);
<a id="__codelineno-53-5" name="__codelineno-53-5"></a>printf(&quot;In-order:&quot;);
<a id="__codelineno-53-6" name="__codelineno-53-6"></a>Traverse_Inorder(T);
<a id="__codelineno-53-7" name="__codelineno-53-7"></a>printf(&quot;\nPre-order:&quot;);
<a id="__codelineno-53-8" name="__codelineno-53-8"></a>Traverse_Preorder(T);
<a id="__codelineno-53-9" name="__codelineno-53-9"></a>system(&quot;pause&quot;);
<a id="__codelineno-53-10" name="__codelineno-53-10"></a>return 0 ;
<a id="__codelineno-53-11" name="__codelineno-53-11"></a>}
<a id="__codelineno-53-12" name="__codelineno-53-12"></a>// 输入数据：16 3 7 11 9 26 18 14 15 0
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-54-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-54-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-54-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-54-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-54-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-54-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-54-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-54-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-54-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-54-10">10</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-54-1" name="__codelineno-54-1"></a>void Creat_AVL(AVLTree *T) {
<a id="__codelineno-54-2" name="__codelineno-54-2"></a>*T = NULL;
<a id="__codelineno-54-3" name="__codelineno-54-3"></a>AVLElemtype key;
<a id="__codelineno-54-4" name="__codelineno-54-4"></a>scanf(&quot; %d&quot;, &amp;key);
<a id="__codelineno-54-5" name="__codelineno-54-5"></a>// 0 代表输入结束
<a id="__codelineno-54-6" name="__codelineno-54-6"></a>while (key != 0 ) {
<a id="__codelineno-54-7" name="__codelineno-54-7"></a>Insert_AVL(T, key, &amp;__taller);
<a id="__codelineno-54-8" name="__codelineno-54-8"></a>scanf(&quot; %d&quot;, &amp;key);
<a id="__codelineno-54-9" name="__codelineno-54-9"></a>}
<a id="__codelineno-54-10" name="__codelineno-54-10"></a>}
</code></pre></div></td></tr></table></div></p>
<h6 id="_243">缺点：空间效率低<a class="headerlink" href="#_243" title="Permanent link">&para;</a></h6>
<h6 id="hash_1">冲突：通过Hash函数，不同的关键字映射到同一个地址上<a class="headerlink" href="#hash_1" title="Permanent link">&para;</a></h6>
<h3 id="hash_2">hash函数的构造方法<a class="headerlink" href="#hash_2" title="Permanent link">&para;</a></h3>
<h6 id="_244">需要考虑的因素：<a class="headerlink" href="#_244" title="Permanent link">&para;</a></h6>
<h6 id="_245">执行速度(计算时间)<a class="headerlink" href="#_245" title="Permanent link">&para;</a></h6>
<h6 id="_246">关键字长度<a class="headerlink" href="#_246" title="Permanent link">&para;</a></h6>
<h6 id="hash-table_3">Hash Table的大小<a class="headerlink" href="#hash-table_3" title="Permanent link">&para;</a></h6>
<h6 id="_247">关键字的分布情况<a class="headerlink" href="#_247" title="Permanent link">&para;</a></h6>
<h6 id="_248">朝朝频率<a class="headerlink" href="#_248" title="Permanent link">&para;</a></h6>
<h6 id="_249">主要构造方法 ：<a class="headerlink" href="#_249" title="Permanent link">&para;</a></h6>
<h6 id="_250">直接定址法<a class="headerlink" href="#_250" title="Permanent link">&para;</a></h6>
<h6 id="_251">数字分析法<a class="headerlink" href="#_251" title="Permanent link">&para;</a></h6>
<h6 id="_252">平方取中法<a class="headerlink" href="#_252" title="Permanent link">&para;</a></h6>
<h6 id="_253">折叠法<a class="headerlink" href="#_253" title="Permanent link">&para;</a></h6>
<h6 id="_254">除留余数法<a class="headerlink" href="#_254" title="Permanent link">&para;</a></h6>
<h6 id="_255">随机数法<a class="headerlink" href="#_255" title="Permanent link">&para;</a></h6>
<h6 id="_256">直接定址法 ：<a class="headerlink" href="#_256" title="Permanent link">&para;</a></h6>
<h6 id="key_2">优点：以关键字key的某个线性函数值为散列地址，不会产生冲突<a class="headerlink" href="#key_2" title="Permanent link">&para;</a></h6>
<h6 id="_257">缺点：要占用连续地址空间，空间效率低<a class="headerlink" href="#_257" title="Permanent link">&para;</a></h6>
<h6 id="_258">例<a class="headerlink" href="#_258" title="Permanent link">&para;</a></h6>
<h6 id="_259">散列函数<a class="headerlink" href="#_259" title="Permanent link">&para;</a></h6>
<h4 id="_260">处理冲突的方法<a class="headerlink" href="#_260" title="Permanent link">&para;</a></h4>
<h6 id="_261">除留余数法：<a class="headerlink" href="#_261" title="Permanent link">&para;</a></h6>
<h6 id="_262">为增量序列 表长，且 是个 质数<a class="headerlink" href="#_262" title="Permanent link">&para;</a></h6>
<h6 id="_263">开放定址法 ：<a class="headerlink" href="#_263" title="Permanent link">&para;</a></h6>
<h6 id="_264">基本思想：有冲突时就去寻找下一个空的散列地址，只要表足够大，总能找到空的地址<a class="headerlink" href="#_264" title="Permanent link">&para;</a></h6>
<h6 id="_265">常用方法：<a class="headerlink" href="#_265" title="Permanent link">&para;</a></h6>
<h6 id="_266">线性探测法 为 ， ， ，<a class="headerlink" href="#_266" title="Permanent link">&para;</a></h6>
<h6 id="_267">二次探测法 为<a class="headerlink" href="#_267" title="Permanent link">&para;</a></h6>
<h6 id="_268">伪随机数探测法 为伪随机数数列<a class="headerlink" href="#_268" title="Permanent link">&para;</a></h6>
<h6 id="_269">链地址法：<a class="headerlink" href="#_269" title="Permanent link">&para;</a></h6>
<h6 id="_270">基本思想，相同散列地址的记录链成一单链表<a class="headerlink" href="#_270" title="Permanent link">&para;</a></h6>
<h6 id="_271">例：<a class="headerlink" href="#_271" title="Permanent link">&para;</a></h6>
<h6 id="_272">已知一组关键字为 令<a class="headerlink" href="#_272" title="Permanent link">&para;</a></h6>
<h6 id="_273">链地址法的优点：<a class="headerlink" href="#_273" title="Permanent link">&para;</a></h6>
<h6 id="_274">非同义词不会冲突，无聚集现象<a class="headerlink" href="#_274" title="Permanent link">&para;</a></h6>
<h6 id="_275">链表上空间动态申请，更适用于表长不确定的情况<a class="headerlink" href="#_275" title="Permanent link">&para;</a></h6>
<h4 id="hash-table_4">除留余数法构造Hash Table<a class="headerlink" href="#hash-table_4" title="Permanent link">&para;</a></h4>
<h6 id="_276">类型定义：<a class="headerlink" href="#_276" title="Permanent link">&para;</a></h6>
<h6 id="_277">初始化并构造：<a class="headerlink" href="#_277" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-55-1">1</a></span>
<span class="normal"><a href="#__codelineno-55-2">2</a></span>
<span class="normal"><a href="#__codelineno-55-3">3</a></span>
<span class="normal"><a href="#__codelineno-55-4">4</a></span>
<span class="normal"><a href="#__codelineno-55-5">5</a></span>
<span class="normal"><a href="#__codelineno-55-6">6</a></span>
<span class="normal"><a href="#__codelineno-55-7">7</a></span>
<span class="normal"><a href="#__codelineno-55-8">8</a></span>
<span class="normal"><a href="#__codelineno-55-9">9</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-55-1" name="__codelineno-55-1"></a>#define __m 11 // __m是表长
<a id="__codelineno-55-2" name="__codelineno-55-2"></a>#define __n 9 // 元素个数
<a id="__codelineno-55-3" name="__codelineno-55-3"></a>#define NULLKEY 0 // 0意味着表空
<a id="__codelineno-55-4" name="__codelineno-55-4"></a>typedef int HashElemType;
<a id="__codelineno-55-5" name="__codelineno-55-5"></a>typedef char HashOther;
<a id="__codelineno-55-6" name="__codelineno-55-6"></a>typedef struct __HashTable {
<a id="__codelineno-55-7" name="__codelineno-55-7"></a>HashElemType key;
<a id="__codelineno-55-8" name="__codelineno-55-8"></a>HashOther other;
<a id="__codelineno-55-9" name="__codelineno-55-9"></a>} HashTable[__m];
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-56-1">1</a></span>
<span class="normal"><a href="#__codelineno-56-2">2</a></span>
<span class="normal"><a href="#__codelineno-56-3">3</a></span>
<span class="normal"><a href="#__codelineno-56-4">4</a></span>
<span class="normal"><a href="#__codelineno-56-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-56-1" name="__codelineno-56-1"></a>void InitHashTable(HashTable hash) {
<a id="__codelineno-56-2" name="__codelineno-56-2"></a>printf(&quot;Please input %d integer(s):&quot;, __n);
<a id="__codelineno-56-3" name="__codelineno-56-3"></a>int key;
<a id="__codelineno-56-4" name="__codelineno-56-4"></a>// 初始化
<a id="__codelineno-56-5" name="__codelineno-56-5"></a>memset(hash, 0 , sizeof(HashTable));
</code></pre></div></td></tr></table></div></p>
<h6 id="_278">搜索：<a class="headerlink" href="#_278" title="Permanent link">&para;</a></h6>
<h4 id="_279">查找效率分析<a class="headerlink" href="#_279" title="Permanent link">&para;</a></h4>
<h6 id="hash-tableasl">Hash Table的ASL取决于：<a class="headerlink" href="#hash-tableasl" title="Permanent link">&para;</a></h6>
<h6 id="_280">散列函数<a class="headerlink" href="#_280" title="Permanent link">&para;</a></h6>
<h6 id="_281">处理冲突的方法<a class="headerlink" href="#_281" title="Permanent link">&para;</a></h6>
<h6 id="_282">散列表的装填因子<a class="headerlink" href="#_282" title="Permanent link">&para;</a></h6>
<h6 id="_283">表中元素个数<a class="headerlink" href="#_283" title="Permanent link">&para;</a></h6>
<h5 id="_284">表长 越接近 说明发生冲突的可能性越大<a class="headerlink" href="#_284" title="Permanent link">&para;</a></h5>
<h6 id="hash-table_5">所以说Hash Table的查找效率 既不是 也不是<a class="headerlink" href="#hash-table_5" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-57-1">1</a></span>
<span class="normal"><a href="#__codelineno-57-2">2</a></span>
<span class="normal"><a href="#__codelineno-57-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-57-1" name="__codelineno-57-1"></a>for (int i = 1 ; i &lt; __n + 1 ; i++) {
<a id="__codelineno-57-2" name="__codelineno-57-2"></a>scanf(&quot; %d&quot;, &amp;key);
<a id="__codelineno-57-3" name="__codelineno-57-3"></a>int m_i = Hash(key);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-58-1">1</a></span>
<span class="normal"><a href="#__codelineno-58-2">2</a></span>
<span class="normal"><a href="#__codelineno-58-3">3</a></span>
<span class="normal"><a href="#__codelineno-58-4">4</a></span>
<span class="normal"><a href="#__codelineno-58-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-58-1" name="__codelineno-58-1"></a>if (hash[m_i].key == NULLKEY) {
<a id="__codelineno-58-2" name="__codelineno-58-2"></a>hash[m_i].key = key;
<a id="__codelineno-58-3" name="__codelineno-58-3"></a>} else {
<a id="__codelineno-58-4" name="__codelineno-58-4"></a>for (int j = 1 ; j &lt; __m; j++) {
<a id="__codelineno-58-5" name="__codelineno-58-5"></a>int m_j = Hash(key + j);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-59-1">1</a></span>
<span class="normal"><a href="#__codelineno-59-2">2</a></span>
<span class="normal"><a href="#__codelineno-59-3">3</a></span>
<span class="normal"><a href="#__codelineno-59-4">4</a></span>
<span class="normal"><a href="#__codelineno-59-5">5</a></span>
<span class="normal"><a href="#__codelineno-59-6">6</a></span>
<span class="normal"><a href="#__codelineno-59-7">7</a></span>
<span class="normal"><a href="#__codelineno-59-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-59-1" name="__codelineno-59-1"></a>if (hash[m_j].key == NULLKEY) {
<a id="__codelineno-59-2" name="__codelineno-59-2"></a>hash[m_j].key = key;
<a id="__codelineno-59-3" name="__codelineno-59-3"></a>break;
<a id="__codelineno-59-4" name="__codelineno-59-4"></a>}
<a id="__codelineno-59-5" name="__codelineno-59-5"></a>}
<a id="__codelineno-59-6" name="__codelineno-59-6"></a>}
<a id="__codelineno-59-7" name="__codelineno-59-7"></a>}
<a id="__codelineno-59-8" name="__codelineno-59-8"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-60-1">1</a></span>
<span class="normal"><a href="#__codelineno-60-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-60-1" name="__codelineno-60-1"></a>int Hash_Search(HashTable hash, HashElemType key) {
<a id="__codelineno-60-2" name="__codelineno-60-2"></a>int m_i = Hash(key);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-61-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-61-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-61-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-61-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-61-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-61-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-61-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-61-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-61-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-61-10">10</a></span>
<span class="normal"><a href="#__codelineno-61-11">11</a></span>
<span class="normal"><a href="#__codelineno-61-12">12</a></span>
<span class="normal"><a href="#__codelineno-61-13">13</a></span>
<span class="normal"><a href="#__codelineno-61-14">14</a></span>
<span class="normal"><a href="#__codelineno-61-15">15</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-61-1" name="__codelineno-61-1"></a>if (hash[m_i].key == NULLKEY)
<a id="__codelineno-61-2" name="__codelineno-61-2"></a>return - 1 ;
<a id="__codelineno-61-3" name="__codelineno-61-3"></a>else if (hash[m_i].key == key)
<a id="__codelineno-61-4" name="__codelineno-61-4"></a>return m_i;
<a id="__codelineno-61-5" name="__codelineno-61-5"></a>else {
<a id="__codelineno-61-6" name="__codelineno-61-6"></a>for (int i = 1 ; i &lt; __m; i++) {
<a id="__codelineno-61-7" name="__codelineno-61-7"></a>int m_j = Hash(key + i);
<a id="__codelineno-61-8" name="__codelineno-61-8"></a>if (hash[m_j].key == NULLKEY)
<a id="__codelineno-61-9" name="__codelineno-61-9"></a>return - 1 ;
<a id="__codelineno-61-10" name="__codelineno-61-10"></a>else if (hash[m_j].key == key)
<a id="__codelineno-61-11" name="__codelineno-61-11"></a>return m_j;
<a id="__codelineno-61-12" name="__codelineno-61-12"></a>}
<a id="__codelineno-61-13" name="__codelineno-61-13"></a>return - 1 ;
<a id="__codelineno-61-14" name="__codelineno-61-14"></a>}
<a id="__codelineno-61-15" name="__codelineno-61-15"></a>}
</code></pre></div></td></tr></table></div></p>
<h6 id="_285">顺序查找 折半查找 分块查找<a class="headerlink" href="#_285" title="Permanent link">&para;</a></h6>
<h6 id="_286">时间<a class="headerlink" href="#_286" title="Permanent link">&para;</a></h6>
<h6 id="_287">复杂<a class="headerlink" href="#_287" title="Permanent link">&para;</a></h6>
<h6 id="_288">度<a class="headerlink" href="#_288" title="Permanent link">&para;</a></h6>
<h6 id="_289">与确定所在块的查找方法有关<a class="headerlink" href="#_289" title="Permanent link">&para;</a></h6>
<h6 id="_290">特点<a class="headerlink" href="#_290" title="Permanent link">&para;</a></h6>
<h6 id="_291">算法简单，对结构无要<a class="headerlink" href="#_291" title="Permanent link">&para;</a></h6>
<h6 id="_292">求，效率底<a class="headerlink" href="#_292" title="Permanent link">&para;</a></h6>
<h6 id="_293">对表结构有要求，效<a class="headerlink" href="#_293" title="Permanent link">&para;</a></h6>
<h6 id="_294">率高<a class="headerlink" href="#_294" title="Permanent link">&para;</a></h6>
<h6 id="_295">对结构有一定要求，效率介于顺<a class="headerlink" href="#_295" title="Permanent link">&para;</a></h6>
<h6 id="_296">序查找和折半查找之间<a class="headerlink" href="#_296" title="Permanent link">&para;</a></h6>
<h6 id="_297">适用<a class="headerlink" href="#_297" title="Permanent link">&para;</a></h6>
<h6 id="_298">情况<a class="headerlink" href="#_298" title="Permanent link">&para;</a></h6>
<h6 id="_299">任何结构的线性表，不<a class="headerlink" href="#_299" title="Permanent link">&para;</a></h6>
<h6 id="_300">经常做插入和删除<a class="headerlink" href="#_300" title="Permanent link">&para;</a></h6>
<h6 id="_301">有序的顺序表，不经<a class="headerlink" href="#_301" title="Permanent link">&para;</a></h6>
<h6 id="_302">常做插入和删除<a class="headerlink" href="#_302" title="Permanent link">&para;</a></h6>
<h6 id="_303">块间有序，块内无序的循序表，<a class="headerlink" href="#_303" title="Permanent link">&para;</a></h6>
<h6 id="_304">经常做插入和删除<a class="headerlink" href="#_304" title="Permanent link">&para;</a></h6>
<h6 id="_305">折半查找 二叉排序树<a class="headerlink" href="#_305" title="Permanent link">&para;</a></h6>
<h6 id="_306">时间复<a class="headerlink" href="#_306" title="Permanent link">&para;</a></h6>
<h6 id="_307">杂度<a class="headerlink" href="#_307" title="Permanent link">&para;</a></h6>
<h6 id="_308">特点<a class="headerlink" href="#_308" title="Permanent link">&para;</a></h6>
<h6 id="_309">有序的顺序表，插入和删除需要移动<a class="headerlink" href="#_309" title="Permanent link">&para;</a></h6>
<h6 id="_310">大量元素<a class="headerlink" href="#_310" title="Permanent link">&para;</a></h6>
<h6 id="_311">用二叉链表，插入和删除无需移动元素，只<a class="headerlink" href="#_311" title="Permanent link">&para;</a></h6>
<h6 id="_312">需修改指针<a class="headerlink" href="#_312" title="Permanent link">&para;</a></h6>
<h6 id="_313">适用情<a class="headerlink" href="#_313" title="Permanent link">&para;</a></h6>
<h6 id="_314">况<a class="headerlink" href="#_314" title="Permanent link">&para;</a></h6>
<h6 id="_315">不经常插入删除 经常插入和删除<a class="headerlink" href="#_315" title="Permanent link">&para;</a></h6>
<h6 id="_316">拉链法<a class="headerlink" href="#_316" title="Permanent link">&para;</a></h6>
<h6 id="_317">线性探测法<a class="headerlink" href="#_317" title="Permanent link">&para;</a></h6>
<h6 id="_318">随机探测法<a class="headerlink" href="#_318" title="Permanent link">&para;</a></h6>
<h4 id="_319">几点结论<a class="headerlink" href="#_319" title="Permanent link">&para;</a></h4>
<h6 id="_320">散列表技术具有很好的平均性能，优于一些传统技术<a class="headerlink" href="#_320" title="Permanent link">&para;</a></h6>
<h6 id="_321">链地址法优于开地址法<a class="headerlink" href="#_321" title="Permanent link">&para;</a></h6>
<h6 id="_322">除留余数法作散列函数优于其他类型函数<a class="headerlink" href="#_322" title="Permanent link">&para;</a></h6>
<h2 id="_323">查找总结<a class="headerlink" href="#_323" title="Permanent link">&para;</a></h2>
<h6 id="_324">顺序查找，折半查找，分块查找比较<a class="headerlink" href="#_324" title="Permanent link">&para;</a></h6>
<h6 id="_325">折半查找和二叉排序树比较<a class="headerlink" href="#_325" title="Permanent link">&para;</a></h6>
<h6 id="_326">哈希表:开地址法和链地址法比较<a class="headerlink" href="#_326" title="Permanent link">&para;</a></h6>
<h6 id="_327">开地址法 链地址法<a class="headerlink" href="#_327" title="Permanent link">&para;</a></h6>
<h6 id="_328">空间 无指针域，存储效率高 附加指针域<a class="headerlink" href="#_328" title="Permanent link">&para;</a></h6>
<h6 id="_329">时间复杂度 有二次聚集现象，查找效率低 无二次聚集现象，查找效率高<a class="headerlink" href="#_329" title="Permanent link">&para;</a></h6>
<h6 id="_330">插入删除 不易实现 易于实现<a class="headerlink" href="#_330" title="Permanent link">&para;</a></h6>
<h6 id="_331">适用情况 表的大小固定，适用于表长无变化 节点动态生成，适用于表长经常变化<a class="headerlink" href="#_331" title="Permanent link">&para;</a></h6>
<h2 id="_332">排序<a class="headerlink" href="#_332" title="Permanent link">&para;</a></h2>
<h6 id="_333">排序方法的分类：<a class="headerlink" href="#_333" title="Permanent link">&para;</a></h6>
<h6 id="_334">按数据存储介质：内部排序和外部排序<a class="headerlink" href="#_334" title="Permanent link">&para;</a></h6>
<h6 id="_335">内部排序：数据量不大，数据在内存，无需内外存交换数据<a class="headerlink" href="#_335" title="Permanent link">&para;</a></h6>
<h6 id="_336">外部排序：数据量较大，数据在外存(文件排序)<a class="headerlink" href="#_336" title="Permanent link">&para;</a></h6>
<h6 id="_337">外部排序时，要将数据分批调入内存来排序，中间结果还要及时存入外存<a class="headerlink" href="#_337" title="Permanent link">&para;</a></h6>
<h6 id="_338">按比较器个数：串行排序和并行排序<a class="headerlink" href="#_338" title="Permanent link">&para;</a></h6>
<h6 id="_339">串行排序：单处理机(同一时刻比较一对元素)<a class="headerlink" href="#_339" title="Permanent link">&para;</a></h6>
<h6 id="_340">并行排序：多处理机(同一时刻比较多对元素)<a class="headerlink" href="#_340" title="Permanent link">&para;</a></h6>
<h6 id="_341">按主要操作：比较排序和基数排序<a class="headerlink" href="#_341" title="Permanent link">&para;</a></h6>
<h6 id="_342">比较排序：用比较的方法<a class="headerlink" href="#_342" title="Permanent link">&para;</a></h6>
<h6 id="_343">基数排序：仅仅根据数据本身的取值<a class="headerlink" href="#_343" title="Permanent link">&para;</a></h6>
<h6 id="_344">按辅助空间排序：原地排序和非原地排序<a class="headerlink" href="#_344" title="Permanent link">&para;</a></h6>
<h6 id="_345">原地排序：辅助空间为 的排序<a class="headerlink" href="#_345" title="Permanent link">&para;</a></h6>
<h6 id="_346">非原地排序：辅助空间大于 的排序<a class="headerlink" href="#_346" title="Permanent link">&para;</a></h6>
<h6 id="_347">按稳定性：稳定排序和非稳定排序<a class="headerlink" href="#_347" title="Permanent link">&para;</a></h6>
<h6 id="_348">稳定排序：任何数值相等的元素，排序以后相对次序不变<a class="headerlink" href="#_348" title="Permanent link">&para;</a></h6>
<h6 id="_349">排序方法是否稳定，并不能衡量一个排序算法的优劣<a class="headerlink" href="#_349" title="Permanent link">&para;</a></h6>
<h6 id="_350">按自然性：自然排序和非自然排序<a class="headerlink" href="#_350" title="Permanent link">&para;</a></h6>
<h6 id="_351">自然排序：输入数据越有序，排序的速度越快<a class="headerlink" href="#_351" title="Permanent link">&para;</a></h6>
<h6 id="_352">排序类型定义：<a class="headerlink" href="#_352" title="Permanent link">&para;</a></h6>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-62-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-62-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-62-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-62-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-62-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-62-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-62-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-62-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-62-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-62-10">10</a></span>
<span class="normal"><a href="#__codelineno-62-11">11</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-62-1" name="__codelineno-62-1"></a>#define SORTSIZE 20
<a id="__codelineno-62-2" name="__codelineno-62-2"></a>typedef int SortType;
<a id="__codelineno-62-3" name="__codelineno-62-3"></a>typedef char SortOther;
<a id="__codelineno-62-4" name="__codelineno-62-4"></a>typedef struct __RecordType {
<a id="__codelineno-62-5" name="__codelineno-62-5"></a>SortType key;
<a id="__codelineno-62-6" name="__codelineno-62-6"></a>SortOther other;
<a id="__codelineno-62-7" name="__codelineno-62-7"></a>} RecordType;
<a id="__codelineno-62-8" name="__codelineno-62-8"></a>typedef struct __RecordList {
<a id="__codelineno-62-9" name="__codelineno-62-9"></a>RecordType r[SORTSIZE + 1 ]; //数组中的 0 号位置作guard
<a id="__codelineno-62-10" name="__codelineno-62-10"></a>int length;
<a id="__codelineno-62-11" name="__codelineno-62-11"></a>} RecordList;
</code></pre></div></td></tr></table></div>
<h3 id="_353">直接插入排序<a class="headerlink" href="#_353" title="Permanent link">&para;</a></h3>
<h6 id="_354">若有 个元素需要进行排序，令 到 为有序表非递减， 元素与该有序表比较，插入到适当位置<a class="headerlink" href="#_354" title="Permanent link">&para;</a></h6>
<h6 id="_355">为有序表只有一个元素， 与该有序表比较，进行插入，此时有序表变成 到<a class="headerlink" href="#_355" title="Permanent link">&para;</a></h6>
<h6 id="_356">依此进行插入<a class="headerlink" href="#_356" title="Permanent link">&para;</a></h6>
<h6 id="_357">此时 到 为非递减序列<a class="headerlink" href="#_357" title="Permanent link">&para;</a></h6>
<h6 id="_358">代码实现：<a class="headerlink" href="#_358" title="Permanent link">&para;</a></h6>
<h6 id="_359">测试代码：<a class="headerlink" href="#_359" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-63-1">1</a></span>
<span class="normal"><a href="#__codelineno-63-2">2</a></span>
<span class="normal"><a href="#__codelineno-63-3">3</a></span>
<span class="normal"><a href="#__codelineno-63-4">4</a></span>
<span class="normal"><a href="#__codelineno-63-5">5</a></span>
<span class="normal"><a href="#__codelineno-63-6">6</a></span>
<span class="normal"><a href="#__codelineno-63-7">7</a></span>
<span class="normal"><a href="#__codelineno-63-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-63-1" name="__codelineno-63-1"></a>void InsertSort(RecordList *List) {
<a id="__codelineno-63-2" name="__codelineno-63-2"></a>for (int i = 2 ; i &lt;= List-&gt;length; i++) {
<a id="__codelineno-63-3" name="__codelineno-63-3"></a>// 因为有guard所以，i = 2，而不是 i = 1;
<a id="__codelineno-63-4" name="__codelineno-63-4"></a>if (List-&gt;r[i].key &lt; List-&gt;r[i - 1 ].key) {
<a id="__codelineno-63-5" name="__codelineno-63-5"></a>// 判断下标为i的元素是否大于i-1，如果大于则不需要进行排序
<a id="__codelineno-63-6" name="__codelineno-63-6"></a>// 如果小于则需要进行如下排序
<a id="__codelineno-63-7" name="__codelineno-63-7"></a>List-&gt;r[ 0 ].key = List-&gt;r[i].key; //设置guard
<a id="__codelineno-63-8" name="__codelineno-63-8"></a>List-&gt;r[i] = List-&gt;r[i - 1 ]; // 向后移动
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-64-1">1</a></span>
<span class="normal"><a href="#__codelineno-64-2">2</a></span>
<span class="normal"><a href="#__codelineno-64-3">3</a></span>
<span class="normal"><a href="#__codelineno-64-4">4</a></span>
<span class="normal"><a href="#__codelineno-64-5">5</a></span>
<span class="normal"><a href="#__codelineno-64-6">6</a></span>
<span class="normal"><a href="#__codelineno-64-7">7</a></span>
<span class="normal"><a href="#__codelineno-64-8">8</a></span>
<span class="normal"><a href="#__codelineno-64-9">9</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-64-1" name="__codelineno-64-1"></a>int j;
<a id="__codelineno-64-2" name="__codelineno-64-2"></a>for (j = i - 2 ; List-&gt;r[ 0 ].key &lt; List-&gt;r[j].key; j--) {
<a id="__codelineno-64-3" name="__codelineno-64-3"></a>List-&gt;r[j + 1 ] = List-&gt;r[j];
<a id="__codelineno-64-4" name="__codelineno-64-4"></a>}
<a id="__codelineno-64-5" name="__codelineno-64-5"></a>// 当上面循环结束后，下标为j的元素此时小于guard，则向j的直接后继(j+1)插入
<a id="__codelineno-64-6" name="__codelineno-64-6"></a>List-&gt;r[j + 1 ] = List-&gt;r[ 0 ];
<a id="__codelineno-64-7" name="__codelineno-64-7"></a>}
<a id="__codelineno-64-8" name="__codelineno-64-8"></a>}
<a id="__codelineno-64-9" name="__codelineno-64-9"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-65-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-65-1" name="__codelineno-65-1"></a>#include &quot;InsertSort.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-66-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-66-1" name="__codelineno-66-1"></a>void input(RecordList *RL);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-67-1">1</a></span>
<span class="normal"><a href="#__codelineno-67-2">2</a></span>
<span class="normal"><a href="#__codelineno-67-3">3</a></span>
<span class="normal"><a href="#__codelineno-67-4">4</a></span>
<span class="normal"><a href="#__codelineno-67-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-67-1" name="__codelineno-67-1"></a>int main(void) {
<a id="__codelineno-67-2" name="__codelineno-67-2"></a>RecordList RL;
<a id="__codelineno-67-3" name="__codelineno-67-3"></a>RL.length = 9 ;
<a id="__codelineno-67-4" name="__codelineno-67-4"></a>input(&amp;RL);
<a id="__codelineno-67-5" name="__codelineno-67-5"></a>InsertSort(&amp;RL);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-68-1">1</a></span>
<span class="normal"><a href="#__codelineno-68-2">2</a></span>
<span class="normal"><a href="#__codelineno-68-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-68-1" name="__codelineno-68-1"></a>for (int i = 1 ; i &lt;= RL.length; i++) {
<a id="__codelineno-68-2" name="__codelineno-68-2"></a>printf(&quot;%d &quot;, RL.r[i].key);
<a id="__codelineno-68-3" name="__codelineno-68-3"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-69-1">1</a></span>
<span class="normal"><a href="#__codelineno-69-2">2</a></span>
<span class="normal"><a href="#__codelineno-69-3">3</a></span>
<span class="normal"><a href="#__codelineno-69-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-69-1" name="__codelineno-69-1"></a>system(&quot;pause&quot;);
<a id="__codelineno-69-2" name="__codelineno-69-2"></a>return 0 ;
<a id="__codelineno-69-3" name="__codelineno-69-3"></a>}
<a id="__codelineno-69-4" name="__codelineno-69-4"></a>// 输入数据：47 7 29 11 16 92 22 8 3
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-70-1">1</a></span>
<span class="normal"><a href="#__codelineno-70-2">2</a></span>
<span class="normal"><a href="#__codelineno-70-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-70-1" name="__codelineno-70-1"></a>void input(RecordList *RL) {
<a id="__codelineno-70-2" name="__codelineno-70-2"></a>RecordType *p = RL-&gt;r + 1 ;
<a id="__codelineno-70-3" name="__codelineno-70-3"></a>for (int i = 1 ; i &lt;= RL-&gt;length; i++) {
</code></pre></div></td></tr></table></div></p>
<h6 id="_360">性能分析：<a class="headerlink" href="#_360" title="Permanent link">&para;</a></h6>
<h6 id="_361">最坏情况<a class="headerlink" href="#_361" title="Permanent link">&para;</a></h6>
<h6 id="_362">比较的次数<a class="headerlink" href="#_362" title="Permanent link">&para;</a></h6>
<h6 id="_363">移动的次数<a class="headerlink" href="#_363" title="Permanent link">&para;</a></h6>
<h6 id="_364">平均情况<a class="headerlink" href="#_364" title="Permanent link">&para;</a></h6>
<h6 id="_365">比较次数<a class="headerlink" href="#_365" title="Permanent link">&para;</a></h6>
<h6 id="_366">移动次数<a class="headerlink" href="#_366" title="Permanent link">&para;</a></h6>
<h6 id="_367">最坏情况下<a class="headerlink" href="#_367" title="Permanent link">&para;</a></h6>
<h6 id="_368">平均<a class="headerlink" href="#_368" title="Permanent link">&para;</a></h6>
<h3 id="binary-insert-sort_1">折半插入排序(Binary Insert Sort)<a class="headerlink" href="#binary-insert-sort_1" title="Permanent link">&para;</a></h3>
<h6 id="right1">在直接插入排序的基础上，对已经排序好的有序表进行折半操作，随着折半的进行，right+1就是插入<a class="headerlink" href="#right1" title="Permanent link">&para;</a></h6>
<h6 id="_369">的位置<a class="headerlink" href="#_369" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-71-1">1</a></span>
<span class="normal"><a href="#__codelineno-71-2">2</a></span>
<span class="normal"><a href="#__codelineno-71-3">3</a></span>
<span class="normal"><a href="#__codelineno-71-4">4</a></span>
<span class="normal"><a href="#__codelineno-71-5">5</a></span>
<span class="normal"><a href="#__codelineno-71-6">6</a></span>
<span class="normal"><a href="#__codelineno-71-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-71-1" name="__codelineno-71-1"></a>SortType key;
<a id="__codelineno-71-2" name="__codelineno-71-2"></a>scanf(&quot; %d&quot;, &amp;key);
<a id="__codelineno-71-3" name="__codelineno-71-3"></a>p-&gt;key = key;
<a id="__codelineno-71-4" name="__codelineno-71-4"></a>p++;
<a id="__codelineno-71-5" name="__codelineno-71-5"></a>}
<a id="__codelineno-71-6" name="__codelineno-71-6"></a>p = NULL;
<a id="__codelineno-71-7" name="__codelineno-71-7"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-72-1">1</a></span>
<span class="normal"><a href="#__codelineno-72-2">2</a></span>
<span class="normal"><a href="#__codelineno-72-3">3</a></span>
<span class="normal"><a href="#__codelineno-72-4">4</a></span>
<span class="normal"><a href="#__codelineno-72-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-72-1" name="__codelineno-72-1"></a>void InserSotr_Binary(RecordList *List) {
<a id="__codelineno-72-2" name="__codelineno-72-2"></a>for (int i = 2 ; i &lt;= List-&gt;length; i++) {
<a id="__codelineno-72-3" name="__codelineno-72-3"></a>List-&gt;r[ 0 ] = List-&gt;r[i];
<a id="__codelineno-72-4" name="__codelineno-72-4"></a>int left = 1 ;
<a id="__codelineno-72-5" name="__codelineno-72-5"></a>int right = i - 1 ;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-73-1">1</a></span>
<span class="normal"><a href="#__codelineno-73-2">2</a></span>
<span class="normal"><a href="#__codelineno-73-3">3</a></span>
<span class="normal"><a href="#__codelineno-73-4">4</a></span>
<span class="normal"><a href="#__codelineno-73-5">5</a></span>
<span class="normal"><a href="#__codelineno-73-6">6</a></span>
<span class="normal"><a href="#__codelineno-73-7">7</a></span>
<span class="normal"><a href="#__codelineno-73-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-73-1" name="__codelineno-73-1"></a>while (left &lt;= right) {
<a id="__codelineno-73-2" name="__codelineno-73-2"></a>int mid = (left + right) / 2 ;
<a id="__codelineno-73-3" name="__codelineno-73-3"></a>if (List-&gt;r[ 0 ].key &gt; List-&gt;r[mid].key) {
<a id="__codelineno-73-4" name="__codelineno-73-4"></a>left = mid + 1 ;
<a id="__codelineno-73-5" name="__codelineno-73-5"></a>} else {
<a id="__codelineno-73-6" name="__codelineno-73-6"></a>right = mid - 1 ;
<a id="__codelineno-73-7" name="__codelineno-73-7"></a>}
<a id="__codelineno-73-8" name="__codelineno-73-8"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-74-1">1</a></span>
<span class="normal"><a href="#__codelineno-74-2">2</a></span>
<span class="normal"><a href="#__codelineno-74-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-74-1" name="__codelineno-74-1"></a>for (int j = i - 1 ; j &gt;= right + 1 ; j--) {
<a id="__codelineno-74-2" name="__codelineno-74-2"></a>List-&gt;r[j + 1 ] = List-&gt;r[j];
<a id="__codelineno-74-3" name="__codelineno-74-3"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-75-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-75-1" name="__codelineno-75-1"></a>List-&gt;r[right + 1 ] = List-&gt;r[ 0 ];
</code></pre></div></td></tr></table></div></p>
<h6 id="_370">折半插入性能：<a class="headerlink" href="#_370" title="Permanent link">&para;</a></h6>
<h6 id="_371">时间复杂度<a class="headerlink" href="#_371" title="Permanent link">&para;</a></h6>
<h6 id="_372">空间复杂度<a class="headerlink" href="#_372" title="Permanent link">&para;</a></h6>
<h6 id="_373">是一种稳定排序<a class="headerlink" href="#_373" title="Permanent link">&para;</a></h6>
<h6 id="_374">直接插入和折半插入的比较<a class="headerlink" href="#_374" title="Permanent link">&para;</a></h6>
<h6 id="_375">折半插入的比较次数和待排序序列的初始排列无关，仅依赖序列元素个数<a class="headerlink" href="#_375" title="Permanent link">&para;</a></h6>
<h6 id="_376">折半插入减少了比较次数，但是没有减少移动次数<a class="headerlink" href="#_376" title="Permanent link">&para;</a></h6>
<h6 id="_377">折半插入平均性能优于直接插入排序<a class="headerlink" href="#_377" title="Permanent link">&para;</a></h6>
<h6 id="_378">直接插入在基本有序时，效率更高<a class="headerlink" href="#_378" title="Permanent link">&para;</a></h6>
<h3 id="shells-sort_1">希尔排序(Shell's Sort)<a class="headerlink" href="#shells-sort_1" title="Permanent link">&para;</a></h3>
<h6 id="_379">希尔排序思路<a class="headerlink" href="#_379" title="Permanent link">&para;</a></h6>
<h6 id="_380">增量序列 并且<a class="headerlink" href="#_380" title="Permanent link">&para;</a></h6>
<h6 id="_381">对每个 进行间隔插入排序<a class="headerlink" href="#_381" title="Permanent link">&para;</a></h6>
<h6 id="_382">例如<a class="headerlink" href="#_382" title="Permanent link">&para;</a></h6>
<h6 id="_383">则依此对将要排序的序列进行间隔为 ， ， 的直接插入排序<a class="headerlink" href="#_383" title="Permanent link">&para;</a></h6>
<h6 id="_384">希尔排序特点：<a class="headerlink" href="#_384" title="Permanent link">&para;</a></h6>
<h6 id="_385">移动位置较大，跳跃式地接近排序后的最终位置<a class="headerlink" href="#_385" title="Permanent link">&para;</a></h6>
<h6 id="_386">最后一次只需要少量移动<a class="headerlink" href="#_386" title="Permanent link">&para;</a></h6>
<h6 id="1_3">增量序列必须是递减的，最后一个必须是 1<a class="headerlink" href="#1_3" title="Permanent link">&para;</a></h6>
<h6 id="_387">增量序列必须是互质的<a class="headerlink" href="#_387" title="Permanent link">&para;</a></h6>
<h6 id="_388">代码实现：<a class="headerlink" href="#_388" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-76-1">1</a></span>
<span class="normal"><a href="#__codelineno-76-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-76-1" name="__codelineno-76-1"></a>}
<a id="__codelineno-76-2" name="__codelineno-76-2"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-77-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-77-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-77-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-77-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-77-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-77-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-77-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-77-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-77-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-77-10">10</a></span>
<span class="normal"><a href="#__codelineno-77-11">11</a></span>
<span class="normal"><a href="#__codelineno-77-12">12</a></span>
<span class="normal"><a href="#__codelineno-77-13">13</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-77-1" name="__codelineno-77-1"></a>void ShellInsert(RecordList *L, int dk) {
<a id="__codelineno-77-2" name="__codelineno-77-2"></a>for (int i = 1 + dk; i &lt;= L-&gt;length; i++) {
<a id="__codelineno-77-3" name="__codelineno-77-3"></a>if (L-&gt;r[i].key &lt; L-&gt;r[i - dk].key) {
<a id="__codelineno-77-4" name="__codelineno-77-4"></a>L-&gt;r[ 0 ] = L-&gt;r[i];
<a id="__codelineno-77-5" name="__codelineno-77-5"></a>L-&gt;r[i] = L-&gt;r[i - dk];
<a id="__codelineno-77-6" name="__codelineno-77-6"></a>int j;
<a id="__codelineno-77-7" name="__codelineno-77-7"></a>for (j = i - ( 2 * dk); j &gt; 0 &amp;&amp; L-&gt;r[ 0 ].key &lt; L-&gt;r[j].key; j -= dk) {
<a id="__codelineno-77-8" name="__codelineno-77-8"></a>L-&gt;r[j + dk] = L-&gt;r[j];
<a id="__codelineno-77-9" name="__codelineno-77-9"></a>}
<a id="__codelineno-77-10" name="__codelineno-77-10"></a>L-&gt;r[j + dk] = L-&gt;r[ 0 ];
<a id="__codelineno-77-11" name="__codelineno-77-11"></a>}
<a id="__codelineno-77-12" name="__codelineno-77-12"></a>}
<a id="__codelineno-77-13" name="__codelineno-77-13"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-78-1">1</a></span>
<span class="normal"><a href="#__codelineno-78-2">2</a></span>
<span class="normal"><a href="#__codelineno-78-3">3</a></span>
<span class="normal"><a href="#__codelineno-78-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-78-1" name="__codelineno-78-1"></a>void ShellSort(RecordList *L, int *dt, int t) {
<a id="__codelineno-78-2" name="__codelineno-78-2"></a>for (int i = 0 ; i &lt; t; i++) {
<a id="__codelineno-78-3" name="__codelineno-78-3"></a>ShellInsert(L, dt[i]);
<a id="__codelineno-78-4" name="__codelineno-78-4"></a>}
</code></pre></div></td></tr></table></div></p>
<h6 id="_389">测试代码：<a class="headerlink" href="#_389" title="Permanent link">&para;</a></h6>
<h6 id="_390">效率分析<a class="headerlink" href="#_390" title="Permanent link">&para;</a></h6>
<h6 id="_391">增量序列 ，相邻元素互质<a class="headerlink" href="#_391" title="Permanent link">&para;</a></h6>
<h6 id="_392">最坏情况<a class="headerlink" href="#_392" title="Permanent link">&para;</a></h6>
<h6 id="_393">猜想<a class="headerlink" href="#_393" title="Permanent link">&para;</a></h6>
<h6 id="_394">增量序列<a class="headerlink" href="#_394" title="Permanent link">&para;</a></h6>
<h6 id="_395">或<a class="headerlink" href="#_395" title="Permanent link">&para;</a></h6>
<h6 id="_396">猜想<a class="headerlink" href="#_396" title="Permanent link">&para;</a></h6>
<h6 id="_397">最坏情况<a class="headerlink" href="#_397" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-79-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-79-1" name="__codelineno-79-1"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-80-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-80-1" name="__codelineno-80-1"></a>#include &quot;InsertSort.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-81-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-81-1" name="__codelineno-81-1"></a>void input(RecordList *RL);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-82-1">1</a></span>
<span class="normal"><a href="#__codelineno-82-2">2</a></span>
<span class="normal"><a href="#__codelineno-82-3">3</a></span>
<span class="normal"><a href="#__codelineno-82-4">4</a></span>
<span class="normal"><a href="#__codelineno-82-5">5</a></span>
<span class="normal"><a href="#__codelineno-82-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-82-1" name="__codelineno-82-1"></a>int main(void) {
<a id="__codelineno-82-2" name="__codelineno-82-2"></a>RecordList RL;
<a id="__codelineno-82-3" name="__codelineno-82-3"></a>RL.length = 10 ;
<a id="__codelineno-82-4" name="__codelineno-82-4"></a>int dt[ 3 ] = { 5 , 3 , 1 };
<a id="__codelineno-82-5" name="__codelineno-82-5"></a>input(&amp;RL);
<a id="__codelineno-82-6" name="__codelineno-82-6"></a>ShellSort(&amp;RL, dt, 3 );
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-83-1">1</a></span>
<span class="normal"><a href="#__codelineno-83-2">2</a></span>
<span class="normal"><a href="#__codelineno-83-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-83-1" name="__codelineno-83-1"></a>for (int i = 1 ; i &lt;= RL.length; i++) {
<a id="__codelineno-83-2" name="__codelineno-83-2"></a>printf(&quot;%d &quot;, RL.r[i].key);
<a id="__codelineno-83-3" name="__codelineno-83-3"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-84-1">1</a></span>
<span class="normal"><a href="#__codelineno-84-2">2</a></span>
<span class="normal"><a href="#__codelineno-84-3">3</a></span>
<span class="normal"><a href="#__codelineno-84-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-84-1" name="__codelineno-84-1"></a>system(&quot;pause&quot;);
<a id="__codelineno-84-2" name="__codelineno-84-2"></a>return 0 ;
<a id="__codelineno-84-3" name="__codelineno-84-3"></a>}
<a id="__codelineno-84-4" name="__codelineno-84-4"></a>// 输入数据：49 38 65 97 76 13 27 49 55 4
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-85-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-85-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-85-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-85-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-85-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-85-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-85-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-85-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-85-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-85-10">10</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-85-1" name="__codelineno-85-1"></a>void input(RecordList *RL) {
<a id="__codelineno-85-2" name="__codelineno-85-2"></a>RecordType *p = RL-&gt;r + 1 ;
<a id="__codelineno-85-3" name="__codelineno-85-3"></a>for (int i = 1 ; i &lt;= RL-&gt;length; i++) {
<a id="__codelineno-85-4" name="__codelineno-85-4"></a>SortType key;
<a id="__codelineno-85-5" name="__codelineno-85-5"></a>scanf(&quot; %d&quot;, &amp;key);
<a id="__codelineno-85-6" name="__codelineno-85-6"></a>p-&gt;key = key;
<a id="__codelineno-85-7" name="__codelineno-85-7"></a>p++;
<a id="__codelineno-85-8" name="__codelineno-85-8"></a>}
<a id="__codelineno-85-9" name="__codelineno-85-9"></a>p = NULL;
<a id="__codelineno-85-10" name="__codelineno-85-10"></a>}
</code></pre></div></td></tr></table></div></p>
<h3 id="_398">交换排序<a class="headerlink" href="#_398" title="Permanent link">&para;</a></h3>
<h4 id="_399">冒泡排序<a class="headerlink" href="#_399" title="Permanent link">&para;</a></h4>
<h6 id="_400">冒泡排序算法效率分析：<a class="headerlink" href="#_400" title="Permanent link">&para;</a></h6>
<h6 id="_401">最好情况正序<a class="headerlink" href="#_401" title="Permanent link">&para;</a></h6>
<h6 id="_402">比较次数<a class="headerlink" href="#_402" title="Permanent link">&para;</a></h6>
<h6 id="_403">移动次数<a class="headerlink" href="#_403" title="Permanent link">&para;</a></h6>
<h6 id="_404">最坏情况逆序<a class="headerlink" href="#_404" title="Permanent link">&para;</a></h6>
<h6 id="_405">比较次数<a class="headerlink" href="#_405" title="Permanent link">&para;</a></h6>
<h6 id="_406">移动次数<a class="headerlink" href="#_406" title="Permanent link">&para;</a></h6>
<h6 id="_407">综上<a class="headerlink" href="#_407" title="Permanent link">&para;</a></h6>
<h6 id="_408">冒泡排序<a class="headerlink" href="#_408" title="Permanent link">&para;</a></h6>
<h6 id="_409">最好<a class="headerlink" href="#_409" title="Permanent link">&para;</a></h6>
<h6 id="_410">最坏<a class="headerlink" href="#_410" title="Permanent link">&para;</a></h6>
<h6 id="_411">平均<a class="headerlink" href="#_411" title="Permanent link">&para;</a></h6>
<h6 id="_412">需要辅助空间一个<a class="headerlink" href="#_412" title="Permanent link">&para;</a></h6>
<h6 id="_413">冒泡排序是稳定的<a class="headerlink" href="#_413" title="Permanent link">&para;</a></h6>
<h4 id="_414">快速排序<a class="headerlink" href="#_414" title="Permanent link">&para;</a></h4>
<h6 id="_415">基本思路：<a class="headerlink" href="#_415" title="Permanent link">&para;</a></h6>
<h6 id="_416">选取序列 中第一个元素 作为 ，依此扫描序列，如果 小于 则排在 后面，反之排在前面<a class="headerlink" href="#_416" title="Permanent link">&para;</a></h6>
<h6 id="_417">此时以 为中心，序列被分成两个子序列<a class="headerlink" href="#_417" title="Permanent link">&para;</a></h6>
<h6 id="_418">依此对 进行取 操作，以此类推直到 中只有一个元素，此时 为有序序列<a class="headerlink" href="#_418" title="Permanent link">&para;</a></h6>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-86-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-86-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-86-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-86-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-86-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-86-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-86-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-86-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-86-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-86-10">10</a></span>
<span class="normal"><a href="#__codelineno-86-11">11</a></span>
<span class="normal"><a href="#__codelineno-86-12">12</a></span>
<span class="normal"><a href="#__codelineno-86-13">13</a></span>
<span class="normal"><a href="#__codelineno-86-14">14</a></span>
<span class="normal"><a href="#__codelineno-86-15">15</a></span>
<span class="normal"><a href="#__codelineno-86-16">16</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-86-1" name="__codelineno-86-1"></a>void BubbleSort(RecordList *L) {
<a id="__codelineno-86-2" name="__codelineno-86-2"></a>bool flag = true;
<a id="__codelineno-86-3" name="__codelineno-86-3"></a>for (int i = 1 ; i &lt;= L-&gt;length - 1 &amp;&amp; flag; i++) {
<a id="__codelineno-86-4" name="__codelineno-86-4"></a>// 注意此行flag的位置,不要写在j循环里面
<a id="__codelineno-86-5" name="__codelineno-86-5"></a>flag = false;
<a id="__codelineno-86-6" name="__codelineno-86-6"></a>for (int j = 1 ; j &lt;= L-&gt;length - i; j++) {
<a id="__codelineno-86-7" name="__codelineno-86-7"></a>if (L-&gt;r[j].key &gt; L-&gt;r[j + 1 ].key) {
<a id="__codelineno-86-8" name="__codelineno-86-8"></a>//只要发生一次交换，flag就为true
<a id="__codelineno-86-9" name="__codelineno-86-9"></a>flag = true;
<a id="__codelineno-86-10" name="__codelineno-86-10"></a>RecordType temp = L-&gt;r[j];
<a id="__codelineno-86-11" name="__codelineno-86-11"></a>L-&gt;r[j] = L-&gt;r[j + 1 ];
<a id="__codelineno-86-12" name="__codelineno-86-12"></a>L-&gt;r[j + 1 ] = temp;
<a id="__codelineno-86-13" name="__codelineno-86-13"></a>}
<a id="__codelineno-86-14" name="__codelineno-86-14"></a>}
<a id="__codelineno-86-15" name="__codelineno-86-15"></a>}
<a id="__codelineno-86-16" name="__codelineno-86-16"></a>}
</code></pre></div></td></tr></table></div>
<h6 id="_419">代码实现:<a class="headerlink" href="#_419" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-87-1">1</a></span>
<span class="normal"><a href="#__codelineno-87-2">2</a></span>
<span class="normal"><a href="#__codelineno-87-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-87-1" name="__codelineno-87-1"></a>//找pivot
<a id="__codelineno-87-2" name="__codelineno-87-2"></a>int Partition(RecordList *L, int left, int right) {
<a id="__codelineno-87-3" name="__codelineno-87-3"></a>L-&gt;r[ 0 ] = L-&gt;r[left];
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-88-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-88-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-88-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-88-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-88-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-88-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-88-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-88-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-88-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-88-10">10</a></span>
<span class="normal"><a href="#__codelineno-88-11">11</a></span>
<span class="normal"><a href="#__codelineno-88-12">12</a></span>
<span class="normal"><a href="#__codelineno-88-13">13</a></span>
<span class="normal"><a href="#__codelineno-88-14">14</a></span>
<span class="normal"><a href="#__codelineno-88-15">15</a></span>
<span class="normal"><a href="#__codelineno-88-16">16</a></span>
<span class="normal"><a href="#__codelineno-88-17">17</a></span>
<span class="normal"><a href="#__codelineno-88-18">18</a></span>
<span class="normal"><a href="#__codelineno-88-19">19</a></span>
<span class="normal"><a href="#__codelineno-88-20">20</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-88-1" name="__codelineno-88-1"></a>while (left &lt; right) {
<a id="__codelineno-88-2" name="__codelineno-88-2"></a>while (left &lt; right &amp;&amp; L-&gt;r[ 0 ].key &lt;= L-&gt;r[right].key)
<a id="__codelineno-88-3" name="__codelineno-88-3"></a>// 必须&lt;=，如果不加等于号，则死循环
<a id="__codelineno-88-4" name="__codelineno-88-4"></a>right--;
<a id="__codelineno-88-5" name="__codelineno-88-5"></a>L-&gt;r[left] = L-&gt;r[right];
<a id="__codelineno-88-6" name="__codelineno-88-6"></a>while (left &lt; right &amp;&amp; L-&gt;r[ 0 ].key &gt;= L-&gt;r[left].key)
<a id="__codelineno-88-7" name="__codelineno-88-7"></a>left++;
<a id="__codelineno-88-8" name="__codelineno-88-8"></a>L-&gt;r[right] = L-&gt;r[left];
<a id="__codelineno-88-9" name="__codelineno-88-9"></a>}
<a id="__codelineno-88-10" name="__codelineno-88-10"></a>//此时 left和right重叠
<a id="__codelineno-88-11" name="__codelineno-88-11"></a>L-&gt;r[left] = L-&gt;r[ 0 ];
<a id="__codelineno-88-12" name="__codelineno-88-12"></a>return left;
<a id="__codelineno-88-13" name="__codelineno-88-13"></a>}
<a id="__codelineno-88-14" name="__codelineno-88-14"></a>//排序模型
<a id="__codelineno-88-15" name="__codelineno-88-15"></a>void QSort(RecordList *L, int left, int right) {
<a id="__codelineno-88-16" name="__codelineno-88-16"></a>if (left &lt; right) {
<a id="__codelineno-88-17" name="__codelineno-88-17"></a>//获取pivot位置
<a id="__codelineno-88-18" name="__codelineno-88-18"></a>int pivot = Partition(L, left, right);
<a id="__codelineno-88-19" name="__codelineno-88-19"></a>// pivot把序列分成两块，并分别递归
<a id="__codelineno-88-20" name="__codelineno-88-20"></a>QSort(L, left, pivot - 1 );
</code></pre></div></td></tr></table></div></p>
<h6 id="_420">快速排序算法效率：<a class="headerlink" href="#_420" title="Permanent link">&para;</a></h6>
<h6 id="_421">平均效率为<a class="headerlink" href="#_421" title="Permanent link">&para;</a></h6>
<h6 id="_422">快速排序不是原地排序<a class="headerlink" href="#_422" title="Permanent link">&para;</a></h6>
<h6 id="_423">需要借助递归来实现，调用栈<a class="headerlink" href="#_423" title="Permanent link">&para;</a></h6>
<h6 id="_424">平均情况下需要 的栈空间<a class="headerlink" href="#_424" title="Permanent link">&para;</a></h6>
<h6 id="_425">最快情况<a class="headerlink" href="#_425" title="Permanent link">&para;</a></h6>
<h6 id="_426">快速排序不是一种稳定排序<a class="headerlink" href="#_426" title="Permanent link">&para;</a></h6>
<h6 id="_427">若对 或 进行快速排序<a class="headerlink" href="#_427" title="Permanent link">&para;</a></h6>
<h6 id="_428">以 为中心，必然有一侧的子序列个数为 ，那么此时退化成冒泡排序<a class="headerlink" href="#_428" title="Permanent link">&para;</a></h6>
<h6 id="_429">所以快速排序不适用于原本有序或基本有序的序列<a class="headerlink" href="#_429" title="Permanent link">&para;</a></h6>
<h6 id="_430">总结<a class="headerlink" href="#_430" title="Permanent link">&para;</a></h6>
<h6 id="_431">的选取直接影响快排性能<a class="headerlink" href="#_431" title="Permanent link">&para;</a></h6>
<h6 id="_432">数据次序越乱，快排越快，效率越高<a class="headerlink" href="#_432" title="Permanent link">&para;</a></h6>
<h6 id="_433">快速排序不是自然排序方法<a class="headerlink" href="#_433" title="Permanent link">&para;</a></h6>
<h6 id="_434">改变 的选取方法，至多只能改变算法平均情况下的效率，无法改变最快情况下的效率<a class="headerlink" href="#_434" title="Permanent link">&para;</a></h6>
<h6 id="_435">即最坏情况<a class="headerlink" href="#_435" title="Permanent link">&para;</a></h6>
<h4 id="_436">选则排序<a class="headerlink" href="#_436" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-89-1">1</a></span>
<span class="normal"><a href="#__codelineno-89-2">2</a></span>
<span class="normal"><a href="#__codelineno-89-3">3</a></span>
<span class="normal"><a href="#__codelineno-89-4">4</a></span>
<span class="normal"><a href="#__codelineno-89-5">5</a></span>
<span class="normal"><a href="#__codelineno-89-6">6</a></span>
<span class="normal"><a href="#__codelineno-89-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-89-1" name="__codelineno-89-1"></a>QSort(L, pivot + 1 , right);
<a id="__codelineno-89-2" name="__codelineno-89-2"></a>}
<a id="__codelineno-89-3" name="__codelineno-89-3"></a>}
<a id="__codelineno-89-4" name="__codelineno-89-4"></a>// 为了使用方便，封装函数
<a id="__codelineno-89-5" name="__codelineno-89-5"></a>void QuickSort(RecordList *L) {
<a id="__codelineno-89-6" name="__codelineno-89-6"></a>QSort(L, 1 , L-&gt;length);
<a id="__codelineno-89-7" name="__codelineno-89-7"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-90-1">1</a></span>
<span class="normal"><a href="#__codelineno-90-2">2</a></span>
<span class="normal"><a href="#__codelineno-90-3">3</a></span>
<span class="normal"><a href="#__codelineno-90-4">4</a></span>
<span class="normal"><a href="#__codelineno-90-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-90-1" name="__codelineno-90-1"></a>void SelectionSort(RecordList *L) {
<a id="__codelineno-90-2" name="__codelineno-90-2"></a>int i, j;
<a id="__codelineno-90-3" name="__codelineno-90-3"></a>for (i = 1 ; i &lt; L-&gt;length; i++) {
<a id="__codelineno-90-4" name="__codelineno-90-4"></a>int k = i; // k记录最大值或最小值
<a id="__codelineno-90-5" name="__codelineno-90-5"></a>for (j = i + 1 ; j &lt;= L-&gt;length; j++) {
</code></pre></div></td></tr></table></div></p>
<h6 id="_437">测试代码<a class="headerlink" href="#_437" title="Permanent link">&para;</a></h6>
<h6 id="_438">算法效率分析:<a class="headerlink" href="#_438" title="Permanent link">&para;</a></h6>
<h6 id="_439">时间复杂度<a class="headerlink" href="#_439" title="Permanent link">&para;</a></h6>
<h6 id="_440">记录移动次数<a class="headerlink" href="#_440" title="Permanent link">&para;</a></h6>
<h6 id="_441">最好情况<a class="headerlink" href="#_441" title="Permanent link">&para;</a></h6>
<h6 id="_442">最坏情况<a class="headerlink" href="#_442" title="Permanent link">&para;</a></h6>
<h6 id="_443">比较次数<a class="headerlink" href="#_443" title="Permanent link">&para;</a></h6>
<h6 id="_444">无论待排序处于什么状态，选则排序所需进行的比较次数都相同<a class="headerlink" href="#_444" title="Permanent link">&para;</a></h6>
<h6 id="_445">算法特点<a class="headerlink" href="#_445" title="Permanent link">&para;</a></h6>
<h6 id="_446">就选则排序本身来讲，是一种稳定的排序方法，稳定取决于是否在在比较时加入等号<a class="headerlink" href="#_446" title="Permanent link">&para;</a></h6>
<h6 id="_447">可用于链式存储结构<a class="headerlink" href="#_447" title="Permanent link">&para;</a></h6>
<h6 id="_448">移动记录次数较少，当每一记录占用空间较多时，此方法比直接插入排序块<a class="headerlink" href="#_448" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-91-1">1</a></span>
<span class="normal"><a href="#__codelineno-91-2">2</a></span>
<span class="normal"><a href="#__codelineno-91-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-91-1" name="__codelineno-91-1"></a>if (L-&gt;r[k].key &lt; L-&gt;r[j].key) //从大到小排序
<a id="__codelineno-91-2" name="__codelineno-91-2"></a>k = j; // k记录最大值
<a id="__codelineno-91-3" name="__codelineno-91-3"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-92-1">1</a></span>
<span class="normal"><a href="#__codelineno-92-2">2</a></span>
<span class="normal"><a href="#__codelineno-92-3">3</a></span>
<span class="normal"><a href="#__codelineno-92-4">4</a></span>
<span class="normal"><a href="#__codelineno-92-5">5</a></span>
<span class="normal"><a href="#__codelineno-92-6">6</a></span>
<span class="normal"><a href="#__codelineno-92-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-92-1" name="__codelineno-92-1"></a>if (k != i) { //如果k!=i 说明有值比i大
<a id="__codelineno-92-2" name="__codelineno-92-2"></a>SortType temp = L-&gt;r[i].key;
<a id="__codelineno-92-3" name="__codelineno-92-3"></a>L-&gt;r[i].key = L-&gt;r[k].key;
<a id="__codelineno-92-4" name="__codelineno-92-4"></a>L-&gt;r[k].key = temp;
<a id="__codelineno-92-5" name="__codelineno-92-5"></a>}
<a id="__codelineno-92-6" name="__codelineno-92-6"></a>}
<a id="__codelineno-92-7" name="__codelineno-92-7"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-93-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-93-1" name="__codelineno-93-1"></a>#include &quot;ExchangeSort.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-94-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-94-1" name="__codelineno-94-1"></a>void input(RecordList *RL);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-95-1">1</a></span>
<span class="normal"><a href="#__codelineno-95-2">2</a></span>
<span class="normal"><a href="#__codelineno-95-3">3</a></span>
<span class="normal"><a href="#__codelineno-95-4">4</a></span>
<span class="normal"><a href="#__codelineno-95-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-95-1" name="__codelineno-95-1"></a>int main(void) {
<a id="__codelineno-95-2" name="__codelineno-95-2"></a>RecordList RL;
<a id="__codelineno-95-3" name="__codelineno-95-3"></a>RL.length = 10 ;
<a id="__codelineno-95-4" name="__codelineno-95-4"></a>input(&amp;RL);
<a id="__codelineno-95-5" name="__codelineno-95-5"></a>SelectionSort(&amp;RL);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-96-1">1</a></span>
<span class="normal"><a href="#__codelineno-96-2">2</a></span>
<span class="normal"><a href="#__codelineno-96-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-96-1" name="__codelineno-96-1"></a>for (int i = 1 ; i &lt;= RL.length; i++) {
<a id="__codelineno-96-2" name="__codelineno-96-2"></a>printf(&quot;%d &quot;, RL.r[i].key);
<a id="__codelineno-96-3" name="__codelineno-96-3"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-97-1">1</a></span>
<span class="normal"><a href="#__codelineno-97-2">2</a></span>
<span class="normal"><a href="#__codelineno-97-3">3</a></span>
<span class="normal"><a href="#__codelineno-97-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-97-1" name="__codelineno-97-1"></a>system(&quot;pause&quot;);
<a id="__codelineno-97-2" name="__codelineno-97-2"></a>return 0 ;
<a id="__codelineno-97-3" name="__codelineno-97-3"></a>}
<a id="__codelineno-97-4" name="__codelineno-97-4"></a>// 输入数据：49 38 65 97 76 13 27 49 55 4
</code></pre></div></td></tr></table></div></p>
<h4 id="_449">堆<a class="headerlink" href="#_449" title="Permanent link">&para;</a></h4>
<h6 id="_450">堆定义<a class="headerlink" href="#_450" title="Permanent link">&para;</a></h6>
<h6 id="_451">若 个元素的序列为<a class="headerlink" href="#_451" title="Permanent link">&para;</a></h6>
<h6 id="_452">满足如下条件<a class="headerlink" href="#_452" title="Permanent link">&para;</a></h6>
<h6 id="_453">小根堆或 大根堆<a class="headerlink" href="#_453" title="Permanent link">&para;</a></h6>
<h6 id="_454">从上述定义可知，堆实质上就是一个完全二叉树 二叉树中任意非叶子节点均小于大于它的孩子节点<a class="headerlink" href="#_454" title="Permanent link">&para;</a></h6>
<h6 id="_455">如下图<a class="headerlink" href="#_455" title="Permanent link">&para;</a></h6>
<h6 id="1_4">定理1:<a class="headerlink" href="#1_4" title="Permanent link">&para;</a></h6>
<h6 id="_456">若有数列 有 个元素，若按照按下标 存入一颗树中，则此颗树为完全二叉树<a class="headerlink" href="#_456" title="Permanent link">&para;</a></h6>
<h6 id="2_3">定理2:<a class="headerlink" href="#2_3" title="Permanent link">&para;</a></h6>
<h6 id="_457">若有数列 有 个元素，若按照按下标 存入一颗完全二叉树中，令<a class="headerlink" href="#_457" title="Permanent link">&para;</a></h6>
<h6 id="_458">为堆<a class="headerlink" href="#_458" title="Permanent link">&para;</a></h6>
<h6 id="_459">根据完全二叉树的性质可知 为序号最大的非叶子节点<a class="headerlink" href="#_459" title="Permanent link">&para;</a></h6>
<h6 id="_460">叶子节点本身为堆，所以 到 为堆<a class="headerlink" href="#_460" title="Permanent link">&para;</a></h6>
<h6 id="_461">初始化堆<a class="headerlink" href="#_461" title="Permanent link">&para;</a></h6>
<h6 id="_462">若在输出堆顶的最小值最大之后，使剩余 个元素的序列重新组成一个堆<a class="headerlink" href="#_462" title="Permanent link">&para;</a></h6>
<h6 id="_463">则得到 个元素中的次小值次大值<a class="headerlink" href="#_463" title="Permanent link">&para;</a></h6>
<h6 id="_464">对 执行如上操作，得到一个有序序列，此过程为堆排序<a class="headerlink" href="#_464" title="Permanent link">&para;</a></h6>
<h6 id="_465">堆调整<a class="headerlink" href="#_465" title="Permanent link">&para;</a></h6>
<h6 id="_466">根据定理 可知， 到 为堆，那么只需要判断到 是否为堆<a class="headerlink" href="#_466" title="Permanent link">&para;</a></h6>
<h6 id="_467">如果 到 不为堆，选取 和 交换，此时 为堆<a class="headerlink" href="#_467" title="Permanent link">&para;</a></h6>
<h6 id="_468">但是交换了 和 ，无法保证交换后的序列是否为堆，所以还要继续调整<a class="headerlink" href="#_468" title="Permanent link">&para;</a></h6>
<h6 id="_469">令 继续调整，直到<a class="headerlink" href="#_469" title="Permanent link">&para;</a></h6>
<h6 id="_470">堆排序<a class="headerlink" href="#_470" title="Permanent link">&para;</a></h6>
<h6 id="_471">堆初始化虽然完成并且有序，但是 到 并不是有序<a class="headerlink" href="#_471" title="Permanent link">&para;</a></h6>
<h6 id="_472">此时堆顶元素为 交换堆顶元素和 号元素<a class="headerlink" href="#_472" title="Permanent link">&para;</a></h6>
<h6 id="_473">并且对 到 进行堆调整，此时 号元素为<a class="headerlink" href="#_473" title="Permanent link">&para;</a></h6>
<h6 id="_474">依此类推，继续交换堆顶和 ，并对 到 进行堆调整<a class="headerlink" href="#_474" title="Permanent link">&para;</a></h6>
<h6 id="_475">直到<a class="headerlink" href="#_475" title="Permanent link">&para;</a></h6>
<h6 id="_476">堆排序算法效率分析<a class="headerlink" href="#_476" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-98-1">1</a></span>
<span class="normal"><a href="#__codelineno-98-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-98-1" name="__codelineno-98-1"></a>void HeapAdjust(RecordList *L, int s, int n) {
<a id="__codelineno-98-2" name="__codelineno-98-2"></a>RecordType temp = L-&gt;r[s]; // temp暂存，用来作哨兵
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-99-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-99-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-99-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-99-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-99-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-99-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-99-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-99-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-99-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-99-10">10</a></span>
<span class="normal"><a href="#__codelineno-99-11">11</a></span>
<span class="normal"><a href="#__codelineno-99-12">12</a></span>
<span class="normal"><a href="#__codelineno-99-13">13</a></span>
<span class="normal"><a href="#__codelineno-99-14">14</a></span>
<span class="normal"><a href="#__codelineno-99-15">15</a></span>
<span class="normal"><a href="#__codelineno-99-16">16</a></span>
<span class="normal"><a href="#__codelineno-99-17">17</a></span>
<span class="normal"><a href="#__codelineno-99-18">18</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-99-1" name="__codelineno-99-1"></a>for (int j = 2 * s; j &lt;= n; j *= 2 ) {
<a id="__codelineno-99-2" name="__codelineno-99-2"></a>//此处 j&lt;n 确保了如果j是序列最后的元素不进行比较
<a id="__codelineno-99-3" name="__codelineno-99-3"></a>if (j &lt; n &amp;&amp; L-&gt;r[j].key &lt; L-&gt;r[j + 1 ].key)
<a id="__codelineno-99-4" name="__codelineno-99-4"></a>j++; // j记录最大值
<a id="__codelineno-99-5" name="__codelineno-99-5"></a>//如果j的key&lt;=temp 说明temp为根的大根堆
<a id="__codelineno-99-6" name="__codelineno-99-6"></a>if (L-&gt;r[j].key &lt;= temp.key)
<a id="__codelineno-99-7" name="__codelineno-99-7"></a>break;
<a id="__codelineno-99-8" name="__codelineno-99-8"></a>//因为j.key &gt; s.key 所以把j赋给s
<a id="__codelineno-99-9" name="__codelineno-99-9"></a>L-&gt;r[s] = L-&gt;r[j];
<a id="__codelineno-99-10" name="__codelineno-99-10"></a>//! 注意并不需要更改j
<a id="__codelineno-99-11" name="__codelineno-99-11"></a>// 因为当发生堆调整时j会赋值给s，并且s=j,即再次循环发生堆调整时，s变动，也就是说上一个j发
<a id="__codelineno-99-12" name="__codelineno-99-12"></a>生变动
<a id="__codelineno-99-13" name="__codelineno-99-13"></a>//所以不用特地给j赋值。
<a id="__codelineno-99-14" name="__codelineno-99-14"></a>s = j;
<a id="__codelineno-99-15" name="__codelineno-99-15"></a>}
<a id="__codelineno-99-16" name="__codelineno-99-16"></a>//当循环结束再给s赋值，也就是给上一个j赋值
<a id="__codelineno-99-17" name="__codelineno-99-17"></a>L-&gt;r[s] = temp;
<a id="__codelineno-99-18" name="__codelineno-99-18"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-100-1">1</a></span>
<span class="normal"><a href="#__codelineno-100-2">2</a></span>
<span class="normal"><a href="#__codelineno-100-3">3</a></span>
<span class="normal"><a href="#__codelineno-100-4">4</a></span>
<span class="normal"><a href="#__codelineno-100-5">5</a></span>
<span class="normal"><a href="#__codelineno-100-6">6</a></span>
<span class="normal"><a href="#__codelineno-100-7">7</a></span>
<span class="normal"><a href="#__codelineno-100-8">8</a></span>
<span class="normal"><a href="#__codelineno-100-9">9</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-100-1" name="__codelineno-100-1"></a>void HeapSort(RecordList *L) {
<a id="__codelineno-100-2" name="__codelineno-100-2"></a>InitHeap(L);
<a id="__codelineno-100-3" name="__codelineno-100-3"></a>for (int i = L-&gt;length; i &gt; 1 ; i--) {
<a id="__codelineno-100-4" name="__codelineno-100-4"></a>RecordType temp = L-&gt;r[ 1 ];
<a id="__codelineno-100-5" name="__codelineno-100-5"></a>L-&gt;r[ 1 ] = L-&gt;r[i];
<a id="__codelineno-100-6" name="__codelineno-100-6"></a>L-&gt;r[i] = temp;
<a id="__codelineno-100-7" name="__codelineno-100-7"></a>HeapAdjust(L, 1 , i - 1 );
<a id="__codelineno-100-8" name="__codelineno-100-8"></a>}
<a id="__codelineno-100-9" name="__codelineno-100-9"></a>}
</code></pre></div></td></tr></table></div></p>
<h6 id="_477">初始化堆<a class="headerlink" href="#_477" title="Permanent link">&para;</a></h6>
<h6 id="_478">交换堆顶元素和 元素，并重新堆调整<a class="headerlink" href="#_478" title="Permanent link">&para;</a></h6>
<h6 id="_479">所以堆排序<a class="headerlink" href="#_479" title="Permanent link">&para;</a></h6>
<h6 id="_480">具体推导过程在书中第二版 页<a class="headerlink" href="#_480" title="Permanent link">&para;</a></h6>
<h6 id="_481">堆排序的特点<a class="headerlink" href="#_481" title="Permanent link">&para;</a></h6>
<h6 id="_482">不是稳定排序<a class="headerlink" href="#_482" title="Permanent link">&para;</a></h6>
<h6 id="_483">只能用于顺序结构，不能用于链式结构<a class="headerlink" href="#_483" title="Permanent link">&para;</a></h6>
<h6 id="_484">堆排序在最坏情况下时间复杂度也为 ，无论待排序序列是正序还是逆序都一样<a class="headerlink" href="#_484" title="Permanent link">&para;</a></h6>
<h6 id="_485">初始化堆时，需要比较的次数较多，因此记录较少时不宜采用。堆排序在最坏情况下 ，<a class="headerlink" href="#_485" title="Permanent link">&para;</a></h6>
<h6 id="_486">相对于快速排序最坏情况 而言是一个优点，当记录较多时效率高<a class="headerlink" href="#_486" title="Permanent link">&para;</a></h6>
<h3 id="_487">其他类型排序<a class="headerlink" href="#_487" title="Permanent link">&para;</a></h3>
<h4 id="merge-sort_1">并归排序 Merge Sort<a class="headerlink" href="#merge-sort_1" title="Permanent link">&para;</a></h4>
<h6 id="_488">基本思想<a class="headerlink" href="#_488" title="Permanent link">&para;</a></h6>
<h6 id="_489">若有序列<a class="headerlink" href="#_489" title="Permanent link">&para;</a></h6>
<h6 id="_490">其中 为非递减序列 也为非递减序列<a class="headerlink" href="#_490" title="Permanent link">&para;</a></h6>
<h6 id="_491">依此比较 取较小值放入新建序列<a class="headerlink" href="#_491" title="Permanent link">&para;</a></h6>
<h6 id="_492">依此类推得到的序列 为有序序列<a class="headerlink" href="#_492" title="Permanent link">&para;</a></h6>
<h6 id="_493">但是如果一个杂乱无章的序列应该如何应用<a class="headerlink" href="#_493" title="Permanent link">&para;</a></h6>
<h6 id="_494">若有序列<a class="headerlink" href="#_494" title="Permanent link">&para;</a></h6>
<h6 id="_495">依此对该序列进行二分，直到获得只有一个元素的子序列<a class="headerlink" href="#_495" title="Permanent link">&para;</a></h6>
<h6 id="_496">如下图<a class="headerlink" href="#_496" title="Permanent link">&para;</a></h6>
<h6 id="_497">比较 和 较小值放入 充当 ，较大值则充当 ，此时 为有序序列<a class="headerlink" href="#_497" title="Permanent link">&para;</a></h6>
<h6 id="_498">按照此方法递归，可以得到有序序列<a class="headerlink" href="#_498" title="Permanent link">&para;</a></h6>
<h6 id="_499">例子<a class="headerlink" href="#_499" title="Permanent link">&para;</a></h6>
<h6 id="_500">实现代码<a class="headerlink" href="#_500" title="Permanent link">&para;</a></h6>
<h6 id="_501">合并两个有序序列<a class="headerlink" href="#_501" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-101-1">1</a></span>
<span class="normal"><a href="#__codelineno-101-2">2</a></span>
<span class="normal"><a href="#__codelineno-101-3">3</a></span>
<span class="normal"><a href="#__codelineno-101-4">4</a></span>
<span class="normal"><a href="#__codelineno-101-5">5</a></span>
<span class="normal"><a href="#__codelineno-101-6">6</a></span>
<span class="normal"><a href="#__codelineno-101-7">7</a></span>
<span class="normal"><a href="#__codelineno-101-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-101-1" name="__codelineno-101-1"></a>//令R的 1 到mid为有序序列，mid+1到n为有序序列
<a id="__codelineno-101-2" name="__codelineno-101-2"></a>void Merge(RecordType *R, RecordType *Temp, int left, int mid, int right) {
<a id="__codelineno-101-3" name="__codelineno-101-3"></a>int i = left, j = mid + 1 , k = left;
<a id="__codelineno-101-4" name="__codelineno-101-4"></a>while (i &lt;= mid &amp;&amp; j &lt;= right) {
<a id="__codelineno-101-5" name="__codelineno-101-5"></a>//利用三目运算符简化语句
<a id="__codelineno-101-6" name="__codelineno-101-6"></a>// &lt;= 保证了稳定性
<a id="__codelineno-101-7" name="__codelineno-101-7"></a>Temp[k++] = (R[i].key &lt;= R[j].key? R[i++] : R[j++]);
<a id="__codelineno-101-8" name="__codelineno-101-8"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-102-1">1</a></span>
<span class="normal"><a href="#__codelineno-102-2">2</a></span>
<span class="normal"><a href="#__codelineno-102-3">3</a></span>
<span class="normal"><a href="#__codelineno-102-4">4</a></span>
<span class="normal"><a href="#__codelineno-102-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-102-1" name="__codelineno-102-1"></a>while (i &lt;= mid)
<a id="__codelineno-102-2" name="__codelineno-102-2"></a>Temp[k++] = R[i++];
<a id="__codelineno-102-3" name="__codelineno-102-3"></a>while (j &lt;= right)
<a id="__codelineno-102-4" name="__codelineno-102-4"></a>Temp[k++] = R[j++];
<a id="__codelineno-102-5" name="__codelineno-102-5"></a>}
</code></pre></div></td></tr></table></div></p>
<h6 id="_502">分割序列并进行合并<a class="headerlink" href="#_502" title="Permanent link">&para;</a></h6>
<h6 id="_503">函数封装<a class="headerlink" href="#_503" title="Permanent link">&para;</a></h6>
<h6 id="_504">算法效率<a class="headerlink" href="#_504" title="Permanent link">&para;</a></h6>
<h6 id="_505">时间复杂度<a class="headerlink" href="#_505" title="Permanent link">&para;</a></h6>
<h6 id="_506">空间复杂度<a class="headerlink" href="#_506" title="Permanent link">&para;</a></h6>
<h6 id="_507">是稳定排序<a class="headerlink" href="#_507" title="Permanent link">&para;</a></h6>
<h6 id="_508">可以用于链式存储结构，且不需要附加存储空间，但递归的实现仍要需要开辟相应的工作栈<a class="headerlink" href="#_508" title="Permanent link">&para;</a></h6>
<h4 id="_509">基数排序<a class="headerlink" href="#_509" title="Permanent link">&para;</a></h4>
<h6 id="_510">前面的算法都是基于比较，而基数排序则不需要比较，通过关键字中的信息进行分类，进行 分配 和 采<a class="headerlink" href="#_510" title="Permanent link">&para;</a></h6>
<h6 id="_511">集 来实现排序<a class="headerlink" href="#_511" title="Permanent link">&para;</a></h6>
<h6 id="_512">如下图<a class="headerlink" href="#_512" title="Permanent link">&para;</a></h6>
<h6 id="_513">先按照个位排序<a class="headerlink" href="#_513" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-103-1">1</a></span>
<span class="normal"><a href="#__codelineno-103-2">2</a></span>
<span class="normal"><a href="#__codelineno-103-3">3</a></span>
<span class="normal"><a href="#__codelineno-103-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-103-1" name="__codelineno-103-1"></a>void MSort(RecordType *R, RecordType *Temp, int left, int right) {
<a id="__codelineno-103-2" name="__codelineno-103-2"></a>//递归函数的出口为left = right = 1 和 left = right = mid+1
<a id="__codelineno-103-3" name="__codelineno-103-3"></a>if (left &gt;= right)
<a id="__codelineno-103-4" name="__codelineno-103-4"></a>return;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-104-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-104-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-104-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-104-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-104-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-104-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-104-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-104-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-104-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-104-10">10</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-104-1" name="__codelineno-104-1"></a>int mid = (left + right) &gt;&gt; 1 ;
<a id="__codelineno-104-2" name="__codelineno-104-2"></a>MSort(R, Temp, left, mid);
<a id="__codelineno-104-3" name="__codelineno-104-3"></a>MSort(R, Temp, mid + 1 , right);
<a id="__codelineno-104-4" name="__codelineno-104-4"></a>Merge(R, Temp, left, mid, right);
<a id="__codelineno-104-5" name="__codelineno-104-5"></a>//! 注意：此函数的核心语句为下行的循环
<a id="__codelineno-104-6" name="__codelineno-104-6"></a>//! 每一次递归都需要更新R数组，因为进行栈底递归时，R必须为以mid为中心，两侧都是有序序列
<a id="__codelineno-104-7" name="__codelineno-104-7"></a>for (int i = left; i &lt; right + 1 ; ++i) {
<a id="__codelineno-104-8" name="__codelineno-104-8"></a>R[i] = Temp[i];
<a id="__codelineno-104-9" name="__codelineno-104-9"></a>}
<a id="__codelineno-104-10" name="__codelineno-104-10"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-105-1">1</a></span>
<span class="normal"><a href="#__codelineno-105-2">2</a></span>
<span class="normal"><a href="#__codelineno-105-3">3</a></span>
<span class="normal"><a href="#__codelineno-105-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-105-1" name="__codelineno-105-1"></a>void MergeSort(RecordList *L) {
<a id="__codelineno-105-2" name="__codelineno-105-2"></a>RecordType Temp[L-&gt;length + 1 ];
<a id="__codelineno-105-3" name="__codelineno-105-3"></a>MSort(L-&gt;r, Temp, 1 , L-&gt;length);
<a id="__codelineno-105-4" name="__codelineno-105-4"></a>}
</code></pre></div></td></tr></table></div></p>
<h6 id="_514">再按照十位排序<a class="headerlink" href="#_514" title="Permanent link">&para;</a></h6>
<h6 id="_515">再按百位排序<a class="headerlink" href="#_515" title="Permanent link">&para;</a></h6>
<h6 id="_516">数据类型定义<a class="headerlink" href="#_516" title="Permanent link">&para;</a></h6>
<h6 id="3_1">采用静态链表来对 3 位数字排序<a class="headerlink" href="#3_1" title="Permanent link">&para;</a></h6>
<h6 id="_517">分配函数<a class="headerlink" href="#_517" title="Permanent link">&para;</a></h6>
<h6 id="_518">收集函数<a class="headerlink" href="#_518" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-106-1">1</a></span>
<span class="normal"><a href="#__codelineno-106-2">2</a></span>
<span class="normal"><a href="#__codelineno-106-3">3</a></span>
<span class="normal"><a href="#__codelineno-106-4">4</a></span>
<span class="normal"><a href="#__codelineno-106-5">5</a></span>
<span class="normal"><a href="#__codelineno-106-6">6</a></span>
<span class="normal"><a href="#__codelineno-106-7">7</a></span>
<span class="normal"><a href="#__codelineno-106-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-106-1" name="__codelineno-106-1"></a>#define MAXBIT 3 //排序的关键字为 3 位
<a id="__codelineno-106-2" name="__codelineno-106-2"></a>#define RADIX 10 //对 10 进制进行排序
<a id="__codelineno-106-3" name="__codelineno-106-3"></a>#define MAX_SPACE 100 //最多可以有 99 个待排序元素，因为有一个头节点
<a id="__codelineno-106-4" name="__codelineno-106-4"></a>struct SLCell { //元素类型
<a id="__codelineno-106-5" name="__codelineno-106-5"></a>SortType keys[MAXBIT]; //存储个位，十位，百位
<a id="__codelineno-106-6" name="__codelineno-106-6"></a>SortOther other; //其他信息
<a id="__codelineno-106-7" name="__codelineno-106-7"></a>int next; //存放下一个元素在数组中的位置
<a id="__codelineno-106-8" name="__codelineno-106-8"></a>};
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-107-1">1</a></span>
<span class="normal"><a href="#__codelineno-107-2">2</a></span>
<span class="normal"><a href="#__codelineno-107-3">3</a></span>
<span class="normal"><a href="#__codelineno-107-4">4</a></span>
<span class="normal"><a href="#__codelineno-107-5">5</a></span>
<span class="normal"><a href="#__codelineno-107-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-107-1" name="__codelineno-107-1"></a>struct SLList {
<a id="__codelineno-107-2" name="__codelineno-107-2"></a>SLCell r[MAX_SPACE]; // r[0]不存放数据，类似于链表的头指针
<a id="__codelineno-107-3" name="__codelineno-107-3"></a>int bitnumber; //表示此静态链表对n位数排序
<a id="__codelineno-107-4" name="__codelineno-107-4"></a>int length; //表中有效元素个数
<a id="__codelineno-107-5" name="__codelineno-107-5"></a>};
<a id="__codelineno-107-6" name="__codelineno-107-6"></a>typedef int RadixArr[RADIX]; //用于创建first, end 数组
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-108-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-108-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-108-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-108-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-108-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-108-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-108-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-108-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-108-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-108-10">10</a></span>
<span class="normal"><a href="#__codelineno-108-11">11</a></span>
<span class="normal"><a href="#__codelineno-108-12">12</a></span>
<span class="normal"><a href="#__codelineno-108-13">13</a></span>
<span class="normal"><a href="#__codelineno-108-14">14</a></span>
<span class="normal"><a href="#__codelineno-108-15">15</a></span>
<span class="normal"><a href="#__codelineno-108-16">16</a></span>
<span class="normal"><a href="#__codelineno-108-17">17</a></span>
<span class="normal"><a href="#__codelineno-108-18">18</a></span>
<span class="normal"><a href="#__codelineno-108-19">19</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-108-1" name="__codelineno-108-1"></a>void Distrubute(SLCell *r, int i, RadixArr first, RadixArr end) {
<a id="__codelineno-108-2" name="__codelineno-108-2"></a>// r表示 SLCell数组的首地址，i=0,i=1,i=2 分别表示对百位，十位，个位进行分配
<a id="__codelineno-108-3" name="__codelineno-108-3"></a>// first数组存放首个被分配的下标，end存放first指向的最后元素
<a id="__codelineno-108-4" name="__codelineno-108-4"></a>memset(first, 0 , sizeof(int) * RADIX); //初始化为 0
<a id="__codelineno-108-5" name="__codelineno-108-5"></a>memset(end, 0 , sizeof(int) * RADIX);
<a id="__codelineno-108-6" name="__codelineno-108-6"></a>for (int p = r[ 0 ].next; p; p = r[p].next) {
<a id="__codelineno-108-7" name="__codelineno-108-7"></a>//因为r[0]为头指针，所以p指向表中第一个元素
<a id="__codelineno-108-8" name="__codelineno-108-8"></a>int j = r[p].keys[i]; // j为下标，等式右边则表示映射关系
<a id="__codelineno-108-9" name="__codelineno-108-9"></a>//如果first[j]==0说明first指向任何元素，直接把p赋给first[j]，
<a id="__codelineno-108-10" name="__codelineno-108-10"></a>if (!first[j])
<a id="__codelineno-108-11" name="__codelineno-108-11"></a>first[j] = p;
<a id="__codelineno-108-12" name="__codelineno-108-12"></a>else {
<a id="__codelineno-108-13" name="__codelineno-108-13"></a>// first[j]已经有指向，那么需要找到end[j]，并把它们连起来
<a id="__codelineno-108-14" name="__codelineno-108-14"></a>r[end[j]].next = p;
<a id="__codelineno-108-15" name="__codelineno-108-15"></a>}
<a id="__codelineno-108-16" name="__codelineno-108-16"></a>//因为p指向新加入的元素，所以最后一个元素变成p
<a id="__codelineno-108-17" name="__codelineno-108-17"></a>end[j] = p;
<a id="__codelineno-108-18" name="__codelineno-108-18"></a>}
<a id="__codelineno-108-19" name="__codelineno-108-19"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-109-1">1</a></span>
<span class="normal"><a href="#__codelineno-109-2">2</a></span>
<span class="normal"><a href="#__codelineno-109-3">3</a></span>
<span class="normal"><a href="#__codelineno-109-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-109-1" name="__codelineno-109-1"></a>void Collect(SLCell *r, int i, RadixArr first, RadixArr end) {
<a id="__codelineno-109-2" name="__codelineno-109-2"></a>//此时分配已经完成，需要做的是按顺序把分配的元素连起来，即收集
<a id="__codelineno-109-3" name="__codelineno-109-3"></a>int j = 0 ;
<a id="__codelineno-109-4" name="__codelineno-109-4"></a>//寻找第一个非空的first子表
</code></pre></div></td></tr></table></div></p>
<h6 id="_519">排序函数<a class="headerlink" href="#_519" title="Permanent link">&para;</a></h6>
<h6 id="_520">初始化和输出函数<a class="headerlink" href="#_520" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-110-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-110-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-110-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-110-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-110-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-110-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-110-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-110-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-110-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-110-10">10</a></span>
<span class="normal"><a href="#__codelineno-110-11">11</a></span>
<span class="normal"><a href="#__codelineno-110-12">12</a></span>
<span class="normal"><a href="#__codelineno-110-13">13</a></span>
<span class="normal"><a href="#__codelineno-110-14">14</a></span>
<span class="normal"><a href="#__codelineno-110-15">15</a></span>
<span class="normal"><a href="#__codelineno-110-16">16</a></span>
<span class="normal"><a href="#__codelineno-110-17">17</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-110-1" name="__codelineno-110-1"></a>while (!first[j])
<a id="__codelineno-110-2" name="__codelineno-110-2"></a>j++;
<a id="__codelineno-110-3" name="__codelineno-110-3"></a>//此时j指向第一个非空子表
<a id="__codelineno-110-4" name="__codelineno-110-4"></a>r[ 0 ].next = first[j]; //让头指针指向此子表
<a id="__codelineno-110-5" name="__codelineno-110-5"></a>int tail = end[j]; // tail代表此子表最后元素的下标
<a id="__codelineno-110-6" name="__codelineno-110-6"></a>//寻找第 2 个非空子表，依此类推，直到j&gt;=Radix
<a id="__codelineno-110-7" name="__codelineno-110-7"></a>for (j = j + 1 ; j &lt; RADIX; j++) {
<a id="__codelineno-110-8" name="__codelineno-110-8"></a>if (!first[j])
<a id="__codelineno-110-9" name="__codelineno-110-9"></a>continue; //如果子表为空则跳过
<a id="__codelineno-110-10" name="__codelineno-110-10"></a>else { //当不为空时
<a id="__codelineno-110-11" name="__codelineno-110-11"></a>r[tail].next = first[j]; //让上一个子表的最后一个元素指向first[j]
<a id="__codelineno-110-12" name="__codelineno-110-12"></a>tail = end[j]; //此时更新尾部下标
<a id="__codelineno-110-13" name="__codelineno-110-13"></a>}
<a id="__codelineno-110-14" name="__codelineno-110-14"></a>}
<a id="__codelineno-110-15" name="__codelineno-110-15"></a>//当下面循环结束后，说明收集完毕
<a id="__codelineno-110-16" name="__codelineno-110-16"></a>r[tail].next = 0 ;
<a id="__codelineno-110-17" name="__codelineno-110-17"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-111-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-111-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-111-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-111-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-111-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-111-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-111-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-111-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-111-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-111-10">10</a></span>
<span class="normal"><a href="#__codelineno-111-11">11</a></span>
<span class="normal"><a href="#__codelineno-111-12">12</a></span>
<span class="normal"><a href="#__codelineno-111-13">13</a></span>
<span class="normal"><a href="#__codelineno-111-14">14</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-111-1" name="__codelineno-111-1"></a>void RadixSort(SLList *L) {
<a id="__codelineno-111-2" name="__codelineno-111-2"></a>//创建first,end数组，不需要初始化，因为Distrubute(函数会进行初始化)
<a id="__codelineno-111-3" name="__codelineno-111-3"></a>RadixArr first, end;
<a id="__codelineno-111-4" name="__codelineno-111-4"></a>//因为是静态链表，需要更新next
<a id="__codelineno-111-5" name="__codelineno-111-5"></a>for (int i = 0 ; i &lt; L-&gt;length; ++i) {
<a id="__codelineno-111-6" name="__codelineno-111-6"></a>L-&gt;r[i].next = i + 1 ;
<a id="__codelineno-111-7" name="__codelineno-111-7"></a>}
<a id="__codelineno-111-8" name="__codelineno-111-8"></a>L-&gt;r[L-&gt;length].next = 0 ; //设置结束表示 0
<a id="__codelineno-111-9" name="__codelineno-111-9"></a>//因为是对三位数进行分配，依此对个位，十位，百位进行分配并收集
<a id="__codelineno-111-10" name="__codelineno-111-10"></a>for (int i = L-&gt;bitnumber - 1 ; i &gt;= 0 ; --i) {
<a id="__codelineno-111-11" name="__codelineno-111-11"></a>Distrubute(L-&gt;r, i, first, end);
<a id="__codelineno-111-12" name="__codelineno-111-12"></a>Collect(L-&gt;r, i, first, end);
<a id="__codelineno-111-13" name="__codelineno-111-13"></a>}
<a id="__codelineno-111-14" name="__codelineno-111-14"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-112-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-112-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-112-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-112-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-112-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-112-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-112-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-112-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-112-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-112-10">10</a></span>
<span class="normal"><a href="#__codelineno-112-11">11</a></span>
<span class="normal"><a href="#__codelineno-112-12">12</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-112-1" name="__codelineno-112-1"></a>void Init_Radix_3(SLList *L, int n) {
<a id="__codelineno-112-2" name="__codelineno-112-2"></a>int hundreds, tens, ones;
<a id="__codelineno-112-3" name="__codelineno-112-3"></a>printf(&quot;Please input %d intergers(tree digits):&quot;, n);
<a id="__codelineno-112-4" name="__codelineno-112-4"></a>for (int i = 1 ; i &lt; n + 1 ; ++i) {
<a id="__codelineno-112-5" name="__codelineno-112-5"></a>int value;
<a id="__codelineno-112-6" name="__codelineno-112-6"></a>scanf(&quot; %d&quot;, &amp;value);
<a id="__codelineno-112-7" name="__codelineno-112-7"></a>ones = value % 10 ;
<a id="__codelineno-112-8" name="__codelineno-112-8"></a>tens = (value / 10 ) % 10 ;
<a id="__codelineno-112-9" name="__codelineno-112-9"></a>hundreds = value / 100 ;
<a id="__codelineno-112-10" name="__codelineno-112-10"></a>L-&gt;r[i].keys[ 0 ] = hundreds;
<a id="__codelineno-112-11" name="__codelineno-112-11"></a>L-&gt;r[i].keys[ 1 ] = tens;
<a id="__codelineno-112-12" name="__codelineno-112-12"></a>L-&gt;r[i].keys[ 2 ] = ones;
</code></pre></div></td></tr></table></div></p>
<h6 id="_521">排序方法 最好情况 最坏情况 平均情况 空间复杂度 稳定性<a class="headerlink" href="#_521" title="Permanent link">&para;</a></h6>
<h6 id="_522">直接插入排序 稳定<a class="headerlink" href="#_522" title="Permanent link">&para;</a></h6>
<h6 id="_523">折半插入排序 稳定<a class="headerlink" href="#_523" title="Permanent link">&para;</a></h6>
<h6 id="_524">希尔排序 不稳定<a class="headerlink" href="#_524" title="Permanent link">&para;</a></h6>
<h6 id="_525">冒泡排序 稳定<a class="headerlink" href="#_525" title="Permanent link">&para;</a></h6>
<h6 id="_526">简单选择排序 稳定<a class="headerlink" href="#_526" title="Permanent link">&para;</a></h6>
<h6 id="_527">快速排序 不稳定<a class="headerlink" href="#_527" title="Permanent link">&para;</a></h6>
<h6 id="_528">堆排序 不稳定<a class="headerlink" href="#_528" title="Permanent link">&para;</a></h6>
<h6 id="_529">归并排序 稳定<a class="headerlink" href="#_529" title="Permanent link">&para;</a></h6>
<h6 id="_530">基数排序 稳定<a class="headerlink" href="#_530" title="Permanent link">&para;</a></h6>
<h6 id="_531">算法效率<a class="headerlink" href="#_531" title="Permanent link">&para;</a></h6>
<h6 id="_532">令基数为 有 个记录，每个记录含有 个关键字，则分配需要 ，收集则需要<a class="headerlink" href="#_532" title="Permanent link">&para;</a></h6>
<h6 id="_533">所以<a class="headerlink" href="#_533" title="Permanent link">&para;</a></h6>
<h6 id="_534">需要两个长度为 的 数组，且还增加了个 个 元素<a class="headerlink" href="#_534" title="Permanent link">&para;</a></h6>
<h6 id="_535">所以空间复杂度<a class="headerlink" href="#_535" title="Permanent link">&para;</a></h6>
<h6 id="_536">算法特点：<a class="headerlink" href="#_536" title="Permanent link">&para;</a></h6>
<h6 id="_537">稳定排序<a class="headerlink" href="#_537" title="Permanent link">&para;</a></h6>
<h6 id="_538">可用于链式存储结构<a class="headerlink" href="#_538" title="Permanent link">&para;</a></h6>
<h6 id="_539">只要基数选取合适，时间复杂度是线性的可以达到<a class="headerlink" href="#_539" title="Permanent link">&para;</a></h6>
<h6 id="_540">有严格的使用要求：需要直到各级关键字的主次关系和取值范围<a class="headerlink" href="#_540" title="Permanent link">&para;</a></h6>
<h2 id="_541">排序总结<a class="headerlink" href="#_541" title="Permanent link">&para;</a></h2>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-113-1">1</a></span>
<span class="normal"><a href="#__codelineno-113-2">2</a></span>
<span class="normal"><a href="#__codelineno-113-3">3</a></span>
<span class="normal"><a href="#__codelineno-113-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-113-1" name="__codelineno-113-1"></a>}
<a id="__codelineno-113-2" name="__codelineno-113-2"></a>L-&gt;length = n;
<a id="__codelineno-113-3" name="__codelineno-113-3"></a>L-&gt;bitnumber = 3 ;
<a id="__codelineno-113-4" name="__codelineno-113-4"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-114-1">1</a></span>
<span class="normal"><a href="#__codelineno-114-2">2</a></span>
<span class="normal"><a href="#__codelineno-114-3">3</a></span>
<span class="normal"><a href="#__codelineno-114-4">4</a></span>
<span class="normal"><a href="#__codelineno-114-5">5</a></span>
<span class="normal"><a href="#__codelineno-114-6">6</a></span>
<span class="normal"><a href="#__codelineno-114-7">7</a></span>
<span class="normal"><a href="#__codelineno-114-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-114-1" name="__codelineno-114-1"></a>void Display_Radix(SLList *L) {
<a id="__codelineno-114-2" name="__codelineno-114-2"></a>for (int p = L-&gt;r[ 0 ].next; p != NULL; p = L-&gt;r[p].next) {
<a id="__codelineno-114-3" name="__codelineno-114-3"></a>for (int i = 0 ; i &lt; L-&gt;bitnumber; i++) {
<a id="__codelineno-114-4" name="__codelineno-114-4"></a>printf(&quot;%d&quot;, L-&gt;r[p].keys[i]);
<a id="__codelineno-114-5" name="__codelineno-114-5"></a>}
<a id="__codelineno-114-6" name="__codelineno-114-6"></a>printf(&quot; &quot;);
<a id="__codelineno-114-7" name="__codelineno-114-7"></a>}
<a id="__codelineno-114-8" name="__codelineno-114-8"></a>}
</code></pre></div></td></tr></table></div></p>
<h6 id="_542">按照时间性能来区分：<a class="headerlink" href="#_542" title="Permanent link">&para;</a></h6>
<h6 id="_543">有 快速排序，归并排序，堆排序，其中快速排序最好<a class="headerlink" href="#_543" title="Permanent link">&para;</a></h6>
<h6 id="_544">有 直接插入排序，冒泡排序，简单选择排序，其中直接插入最好<a class="headerlink" href="#_544" title="Permanent link">&para;</a></h6>
<h6 id="_545">特别是对于关键字近似有序的记录<a class="headerlink" href="#_545" title="Permanent link">&para;</a></h6>
<h6 id="_546">只有 基数排序<a class="headerlink" href="#_546" title="Permanent link">&para;</a></h6>
<h6 id="_547">当待排记录有序时，直接插入排序和冒泡排序能达到 ，而对于快速排序而言，这是最不好的情况<a class="headerlink" href="#_547" title="Permanent link">&para;</a></h6>
<h6 id="_548">此时快速排序<a class="headerlink" href="#_548" title="Permanent link">&para;</a></h6>
<h6 id="_549">简单选则排序，堆排序，归并排序的效率并不能根据关键字的分布而改变<a class="headerlink" href="#_549" title="Permanent link">&para;</a></h6>
<h6 id="_550">按空间性能来区分<a class="headerlink" href="#_550" title="Permanent link">&para;</a></h6>
<h6 id="_551">所有简单排序方法直接插入，冒泡，简单选择排序和堆排序为<a class="headerlink" href="#_551" title="Permanent link">&para;</a></h6>
<h6 id="_552">快速排序为 需要借助栈<a class="headerlink" href="#_552" title="Permanent link">&para;</a></h6>
<h6 id="_553">归并排序需要辅助空间最多，<a class="headerlink" href="#_553" title="Permanent link">&para;</a></h6>
<h6 id="_554">链式基数排序需要 ， 数组和 变量<a class="headerlink" href="#_554" title="Permanent link">&para;</a></h6>
<h6 id="_555">按稳定性来区分<a class="headerlink" href="#_555" title="Permanent link">&para;</a></h6>
<h6 id="_556">快速排序和堆排序不是稳定的方法<a class="headerlink" href="#_556" title="Permanent link">&para;</a></h6>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2023 by CMQ233
    </div>
  
  
</div>
      
        <div class="md-social">
  
    
    
    
    
      
      
    
    <a href="https://github.com/PCDL233" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://space.bilibili.com/107669273?spm_id_from=333.1007.0.0" target="_blank" rel="noopener" title="space.bilibili.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M488.6 104.1c16.7 18.1 24.4 39.7 23.3 65.7v202.4c-.4 26.4-9.2 48.1-26.5 65.1-17.2 17-39.1 25.9-65.5 26.7H92.02c-26.45-.8-48.21-9.8-65.28-27.2C9.682 419.4.767 396.5 0 368.2V169.8c.767-26 9.682-47.6 26.74-65.7C43.81 87.75 65.57 78.77 92.02 78h29.38L96.05 52.19c-5.75-5.73-8.63-13-8.63-21.79 0-8.8 2.88-16.06 8.63-21.797C101.8 2.868 109.1 0 117.9 0s16.1 2.868 21.9 8.603L213.1 78h88l74.5-69.397C381.7 2.868 389.2 0 398 0c8.8 0 16.1 2.868 21.9 8.603 5.7 5.737 8.6 12.997 8.6 21.797 0 8.79-2.9 16.06-8.6 21.79L394.6 78h29.3c26.4.77 48 9.75 64.7 26.1zm-38.8 69.7c-.4-9.6-3.7-17.4-10.7-23.5-5.2-6.1-14-9.4-22.7-9.8H96.05c-9.59.4-17.45 3.7-23.58 9.8-6.14 6.1-9.4 13.9-9.78 23.5v194.4c0 9.2 3.26 17 9.78 23.5s14.38 9.8 23.58 9.8H416.4c9.2 0 17-3.3 23.3-9.8 6.3-6.5 9.7-14.3 10.1-23.5V173.8zm-264.3 42.7c6.3 6.3 9.7 14.1 10.1 23.2V273c-.4 9.2-3.7 16.9-9.8 23.2-6.2 6.3-14 9.5-23.6 9.5-9.6 0-17.5-3.2-23.6-9.5-6.1-6.3-9.4-14-9.8-23.2v-33.3c.4-9.1 3.8-16.9 10.1-23.2 6.3-6.3 13.2-9.6 23.3-10 9.2.4 17 3.7 23.3 10zm191.5 0c6.3 6.3 9.7 14.1 10.1 23.2V273c-.4 9.2-3.7 16.9-9.8 23.2-6.1 6.3-14 9.5-23.6 9.5-9.6 0-17.4-3.2-23.6-9.5-7-6.3-9.4-14-9.7-23.2v-33.3c.3-9.1 3.7-16.9 10-23.2 6.3-6.3 14.1-9.6 23.3-10 9.2.4 17 3.7 23.3 10z"/></svg>
    </a>
  
    
    
    
    
    <a href="mailto:<2815834616@qq.com>" target="_blank" rel="noopener" title="" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M498.1 5.6c10.1 7 15.4 19.1 13.5 31.2l-64 416c-1.5 9.7-7.4 18.2-16 23s-18.9 5.4-28 1.6L284 427.7l-68.5 74.1c-8.9 9.7-22.9 12.9-35.2 8.1S160 493.2 160 480v-83.6c0-4 1.5-7.8 4.2-10.7l167.6-182.9c5.8-6.3 5.6-16-.4-22s-15.7-6.4-22-.7L106 360.8l-88.3-44.2C7.1 311.3.3 300.7 0 288.9s5.9-22.8 16.1-28.7l448-256c10.7-6.1 23.9-5.5 34 1.4z"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.instant", "announce.dismiss", "navigation.tracking", "navigation.tabs", "search.suggest", "search.highlight", "navigation.expand", "navigation.indexes", "search.share"], "search": "../../assets/javascripts/workers/search.208ed371.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.fc8c2696.min.js"></script>
      
        <script src="../../js/extra.js"></script>
      
        <script src="../../js/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>