
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="CMQ233">
      
      
        <link rel="canonical" href="https://PCDL233.github.io/Mkdocs_Note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/DataStructure/">
      
      
        <link rel="prev" href="../Algorithm/">
      
      
        <link rel="next" href="../../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C/%E6%95%B0%E6%8D%AE%E5%AE%9E%E9%AA%8C_%E5%AD%A6%E7%94%9F%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%BA%E5%BA%8F%E8%A1%A8/">
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-9.1.2">
    
    
      
        <title>-2 - CMQNote</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.7bf56d0a.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.a0c5b2b5.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../css/extra.css">
    
      <link rel="stylesheet" href="../../css/video.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="light-blue" data-md-color-accent="light-blue">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="CMQNote" class="md-header__button md-logo" aria-label="CMQNote" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            CMQNote
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              -2
            
          </span>
        </div>
      </div>
    </div>
    
      <form class="md-header__option" data-md-component="palette">
        
          
          <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="light-blue" data-md-color-accent="light-blue"  aria-label="切换至夜间模式"  type="radio" name="__palette" id="__palette_1">
          
            <label class="md-header__button md-icon" title="切换至夜间模式" for="__palette_2" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
            </label>
          
        
          
          <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="cyan"  aria-label="切换至日间模式"  type="radio" name="__palette" id="__palette_2">
          
            <label class="md-header__button md-icon" title="切换至日间模式" for="__palette_1" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
            </label>
          
        
      </form>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="分享" aria-label="分享" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/PCDL233/Mkdocs_Note" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    Mkdocs_Note.github.io
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="md-tabs__link">
        学习
      </a>
    </li>
  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../c%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%EF%BC%9A/" class="md-tabs__link">
        C语言
      </a>
    </li>
  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../c%2B%2B/C%2B%2B%20%E4%B8%ADstring%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95%EF%BC%9A/" class="md-tabs__link">
        c++
      </a>
    </li>
  

      
        
  
  
    
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="../../%E7%BA%BF%E6%80%A7%E8%A1%A8/dataStructure_day01/" class="md-tabs__link md-tabs__link--active">
        数据结构学习
      </a>
    </li>
  

  

      
        
  
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="../../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C/%E6%95%B0%E6%8D%AE%E5%AE%9E%E9%AA%8C_%E5%AD%A6%E7%94%9F%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%BA%E5%BA%8F%E8%A1%A8/" class="md-tabs__link">
        数据结构实验
      </a>
    </li>
  

  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../sortAlgorithm/bubbleSort/" class="md-tabs__link">
        排序算法
      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="CMQNote" class="md-nav__button md-logo" aria-label="CMQNote" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    CMQNote
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/PCDL233/Mkdocs_Note" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    Mkdocs_Note.github.io
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
        
      
      <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_1" >
      
      
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1" id="__nav_1_label" tabindex="0">
          学习
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          学习
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="md-nav__link">
        JavaScript
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BD%91%E7%AB%99/" class="md-nav__link">
        算法可视化学习网站
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
        
      
      <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2" >
      
      
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
          C语言
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          C语言
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../c%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%EF%BC%9A/" class="md-nav__link">
        排序方法
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../c%E8%AF%AD%E8%A8%80/c%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E9%80%92%E5%BD%92/" class="md-nav__link">
        递归
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../c%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%EF%BC%9A/" class="md-nav__link">
        字符串函数
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../c%E8%AF%AD%E8%A8%80/%E6%9E%9A%E4%B8%BE%E6%B3%95%EF%BC%88%E7%A9%B7%E4%B8%BE%E6%B3%95%EF%BC%89/" class="md-nav__link">
        穷举法
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
        
      
      <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_3" >
      
      
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
          c++
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          c++
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../c%2B%2B/C%2B%2B%20%E4%B8%ADstring%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95%EF%BC%9A/" class="md-nav__link">
        string
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../c%2B%2B/C%2B%2B%20%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88STL%EF%BC%89/" class="md-nav__link">
        c++标准模板(STL)
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" checked>
      
      
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
          数据结构学习
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="true">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          数据结构学习
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
        
      
      <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_4_1" >
      
      
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_4_1" id="__nav_4_1_label" tabindex="0">
          线性表
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_1">
          <span class="md-nav__icon md-icon"></span>
          线性表
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%BA%BF%E6%80%A7%E8%A1%A8/dataStructure_day01/" class="md-nav__link">
        1
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%BA%BF%E6%80%A7%E8%A1%A8/dataStructure_day02/" class="md-nav__link">
        2
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%BA%BF%E6%80%A7%E8%A1%A8/dataStructure_day03/" class="md-nav__link">
        3
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/" class="md-nav__link">
        单链表
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%BA%BF%E6%80%A7%E8%A1%A8/%E9%A1%BA%E5%BA%8F%E8%A1%A8/" class="md-nav__link">
        顺序表
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_2" checked>
      
      
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_4_2" id="__nav_4_2_label" tabindex="0">
          数据结构代码实现
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_2_label" aria-expanded="true">
        <label class="md-nav__title" for="__nav_4_2">
          <span class="md-nav__icon md-icon"></span>
          数据结构代码实现
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../Algorithm/" class="md-nav__link">
        -1
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          -2
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        -2
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    数据结构
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    宏定义
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1. 线性表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sequence-list" class="md-nav__link">
    顺序表(Sequence List)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    初始化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    获取元素
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    查找元素
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    插入
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    删除
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    销毁，清空，检查为空
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    顺序表的头文件
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#single-linked-list" class="md-nav__link">
    单链表(Single Linked List)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    初始化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    创建链表(头插法)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    创建链表(尾插法)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    获取元素
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    查找元素
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    插入元素
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    删除元素
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    总结插入和删除操作算法的不同
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    销毁链表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    单链表头文件
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#circular-linked-list" class="md-nav__link">
    循环链表(Circular Linked List)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#double-linked-list" class="md-nav__link">
    双向链表(Double Linked List)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    初始化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    创建双向链表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    插入和删除
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    线性表玩具
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    线性表合并
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    有序表合并(并归排序的基础)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    有序链表合并
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#and" class="md-nav__link">
    多项式创建 and 多项式相加
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-stack-and-queue" class="md-nav__link">
    2. 栈和队列(Stack and Queue)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sequence-stack" class="md-nav__link">
    顺序栈(Sequence Stack)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    栈的类型定义
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    栈的初始化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#push" class="md-nav__link">
    入栈(Push)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pop" class="md-nav__link">
    出栈(Pop)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    栈的其他操作
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    测试代码
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#linked-stack" class="md-nav__link">
    链栈(Linked Stack)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    链栈的类型定义
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    链栈初始化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#push_1" class="md-nav__link">
    链栈Push
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pop_1" class="md-nav__link">
    链栈Pop
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    链栈的其他操作
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    测试代码
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#stackh" class="md-nav__link">
    Stack.h
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    栈与递归
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    函数的调用过程
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    循环队列
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    顺换队列初始化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    顺换队列入队
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    循环队列出队
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    循环队列其他操作
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    测试代码
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    链队
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    链队初始化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_45" class="md-nav__link">
    链队入队
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_46" class="md-nav__link">
    链队出队
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_47" class="md-nav__link">
    栈和队列玩具
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_48" class="md-nav__link">
    进制转化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_49" class="md-nav__link">
    括号的匹配
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#10" class="md-nav__link">
    10 以内的计算器
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    3. 字符串，数组，广义表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_50" class="md-nav__link">
    字符串匹配
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bfbrute-force" class="md-nav__link">
    BF算法(Brute Force)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#kmp" class="md-nav__link">
    KMP算法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#next" class="md-nav__link">
    求next数组
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_51" class="md-nav__link">
    字符串匹配玩具
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_52" class="md-nav__link">
    数组
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#generalized-list" class="md-nav__link">
    广义表(Generalized List)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    4. 树、二叉树、森林
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_53" class="md-nav__link">
    定义
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_54" class="md-nav__link">
    树的基本术语
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_55" class="md-nav__link">
    二叉树的定义
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_56" class="md-nav__link">
    二叉树的性质
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_57" class="md-nav__link">
    二叉树定理
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_58" class="md-nav__link">
    完全二叉树性质及定理
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_59" class="md-nav__link">
    链式二叉树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_60" class="md-nav__link">
    存储结构
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_61" class="md-nav__link">
    遍历方式(递归)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_62" class="md-nav__link">
    遍历方式(非递归)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_63" class="md-nav__link">
    先序遍历创建二叉树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_64" class="md-nav__link">
    测试(创建，遍历)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_65" class="md-nav__link">
    层次遍历算法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_66" class="md-nav__link">
    复制二叉树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_67" class="md-nav__link">
    求深度和节点数
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_68" class="md-nav__link">
    销毁二叉树(递归和非递归)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_69" class="md-nav__link">
    头文件
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#threaded-binary-tree" class="md-nav__link">
    线索二叉树 Threaded Binary Tree(了解即可)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_70" class="md-nav__link">
    数据类型定义
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_71" class="md-nav__link">
    树和森林
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_72" class="md-nav__link">
    树的存储结构
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    1. 双亲表示法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    2. 孩子链表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3_1" class="md-nav__link">
    3. 孩子兄弟表示法(树转化二叉树的基础)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_73" class="md-nav__link">
    树与二叉树之间相互转换
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_74" class="md-nav__link">
    树转二叉树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_75" class="md-nav__link">
    二叉树转树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_76" class="md-nav__link">
    森林与二叉树之间的转化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_77" class="md-nav__link">
    森林转二叉树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_78" class="md-nav__link">
    二叉树转森林
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_79" class="md-nav__link">
    树和森林的遍历
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_80" class="md-nav__link">
    树的遍历
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_81" class="md-nav__link">
    森林的遍历
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_82" class="md-nav__link">
    哈夫曼树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_83" class="md-nav__link">
    术语
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_84" class="md-nav__link">
    最优二叉树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_85" class="md-nav__link">
    构造哈夫曼树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#step" class="md-nav__link">
    step和定理
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_86" class="md-nav__link">
    代码实现
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_87" class="md-nav__link">
    哈夫曼编码
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_88" class="md-nav__link">
    代码实现
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_89" class="md-nav__link">
    整体头文件
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-graph" class="md-nav__link">
    5. 图(Graph)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_90" class="md-nav__link">
    图的定义和术语
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_91" class="md-nav__link">
    完全图
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sparse-graphdense-gaph" class="md-nav__link">
    稀疏图(Sparse Graph)和稠密图(Dense Gaph)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#degree" class="md-nav__link">
    顶点的度(degree)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#path" class="md-nav__link">
    路径(path)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connected-graph" class="md-nav__link">
    连通图(Connected Graph)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connected-component" class="md-nav__link">
    连通子图和连通分量(Connected Component)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#spanning-tree" class="md-nav__link">
    极小连通子图和生成树(Spanning Tree)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_92" class="md-nav__link">
    图的存储结构
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adjacency-matrix" class="md-nav__link">
    邻接矩阵(Adjacency Matrix)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_93" class="md-nav__link">
    无向图
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_94" class="md-nav__link">
    有向图
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#weighted-graph" class="md-nav__link">
    带权图(网) weighted Graph
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_95" class="md-nav__link">
    代码实现
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_96" class="md-nav__link">
    无向无权图
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_97" class="md-nav__link">
    无向带权图
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_98" class="md-nav__link">
    有向带权图
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_99" class="md-nav__link">
    有向无权图
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adjacency-list" class="md-nav__link">
    邻接表(Adjacency List)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_100" class="md-nav__link">
    代码实现
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_101" class="md-nav__link">
    无向无权图
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_102" class="md-nav__link">
    邻接表和邻接矩阵的比较
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_103" class="md-nav__link">
    十字链表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_104" class="md-nav__link">
    邻接多重链表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_105" class="md-nav__link">
    图的遍历
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#depth-first-search" class="md-nav__link">
    深度优先 (Depth First Search)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_106" class="md-nav__link">
    遍历矩阵
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_107" class="md-nav__link">
    遍历邻接表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#breadth-first-search" class="md-nav__link">
    广度优先 (Breadth First Search)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_108" class="md-nav__link">
    遍历矩阵
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_109" class="md-nav__link">
    遍历邻接表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_110" class="md-nav__link">
    算法效率
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#spanning-tree_1" class="md-nav__link">
    最小生成树 Spanning Tree
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#prim" class="md-nav__link">
    Prim 算法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_111" class="md-nav__link">
    代码实现
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_112" class="md-nav__link">
    邻接矩阵
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_113" class="md-nav__link">
    邻接表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#kruskal" class="md-nav__link">
    Kruskal 算法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_114" class="md-nav__link">
    代码实现
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_115" class="md-nav__link">
    邻接矩阵
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_116" class="md-nav__link">
    邻接表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_117" class="md-nav__link">
    最短路径
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dijkstra" class="md-nav__link">
    Dijkstra 算法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_118" class="md-nav__link">
    代码实现
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_119" class="md-nav__link">
    邻接矩阵
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#floyd" class="md-nav__link">
    Floyd算法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_120" class="md-nav__link">
    代码实现
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_121" class="md-nav__link">
    邻接矩阵
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#directed-acycline-graph" class="md-nav__link">
    有向无环图(Directed Acycline Graph)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#aocaoe" class="md-nav__link">
    AOC和AOE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_122" class="md-nav__link">
    拓扑排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_123" class="md-nav__link">
    代码实现
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_124" class="md-nav__link">
    邻接表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_125" class="md-nav__link">
    关键路径
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_126" class="md-nav__link">
    代码实现
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_127" class="md-nav__link">
    邻接表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_128" class="md-nav__link">
    图的头文件
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#define_graphh" class="md-nav__link">
    define_Graph.h
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#amgraphh" class="md-nav__link">
    AMGraph.h
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#algraphh" class="md-nav__link">
    ALGraph.h
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_129" class="md-nav__link">
    数据结构
  </a>
  
    <nav class="md-nav" aria-label="数据结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_130" class="md-nav__link">
    宏定义
  </a>
  
    <nav class="md-nav" aria-label="宏定义">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#defineh" class="md-nav__link">
    在本笔记中用到的宏定义，头文件为define.h
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_2" class="md-nav__link">
    1. 线性表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sequence-list_1" class="md-nav__link">
    顺序表(Sequence List)
  </a>
  
    <nav class="md-nav" aria-label="顺序表(Sequence List)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_131" class="md-nav__link">
    特点：逻辑上相邻的数据元素，其物理次序也是相邻的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_132" class="md-nav__link">
    线性表中第 个数据元素的存储位置 和第个元素满足下列关系
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_133" class="md-nav__link">
    代表每个元素所占的存储单元
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_134" class="md-nav__link">
    循序表的存储结构：
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_135" class="md-nav__link">
    初始化
  </a>
  
    <nav class="md-nav" aria-label="初始化">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_136" class="md-nav__link">
    获取元素
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_137" class="md-nav__link">
    查找元素
  </a>
  
    <nav class="md-nav" aria-label="查找元素">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#aslaverage-search-length" class="md-nav__link">
    平均查找长度ASL(Average Search Length)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_138" class="md-nav__link">
    为查找第个元素成功的概率
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_139" class="md-nav__link">
    为查找第个元素需要比较的次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_140" class="md-nav__link">
    可知
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_141" class="md-nav__link">
    为第个元素在表中位置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_142" class="md-nav__link">
    因此可知 的时间复杂度为
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_143" class="md-nav__link">
    插入
  </a>
  
    <nav class="md-nav" aria-label="插入">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_144" class="md-nav__link">
    表示插入元素所需要移动元素次数的期望值平均次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_145" class="md-nav__link">
    假设在各个位置上插入元素的概率相等
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_146" class="md-nav__link">
    因此
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_147" class="md-nav__link">
    删除
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_148" class="md-nav__link">
    销毁，清空，检查为空
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_149" class="md-nav__link">
    顺序表的头文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#single-linked-list_1" class="md-nav__link">
    单链表(Single Linked List)
  </a>
  
    <nav class="md-nav" aria-label="单链表(Single Linked List)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#n" class="md-nav__link">
    单链表由头节点(不存放数据只存放下个节点的地址)和n个节点组成，
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_150" class="md-nav__link">
    每个节点分为两个域：数据域和指针域(存放下个节点的地址)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nnull" class="md-nav__link">
    第n个节点的指针域为NULL
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_151" class="md-nav__link">
    如下图所示
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_152" class="md-nav__link">
    初始化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_153" class="md-nav__link">
    创建链表(头插法)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_154" class="md-nav__link">
    创建链表(尾插法)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_155" class="md-nav__link">
    获取元素
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_156" class="md-nav__link">
    查找元素
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_157" class="md-nav__link">
    插入元素
  </a>
  
    <nav class="md-nav" aria-label="插入元素">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_158" class="md-nav__link">
    想在 ， 之间插入 ,需要先知道 节点的地址
  </a>
  
    <nav class="md-nav" aria-label="想在 ， 之间插入 ,需要先知道 节点的地址">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_159" class="md-nav__link">
    如图所示，如果想要在位置 插入节点，则需要知道位置 节点的位置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#getelem" class="md-nav__link">
    注意因为插入操作和GetElem操作不同
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0-pl" class="md-nav__link">
    要从 0 开始，p要从L开始
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-l-1" class="md-nav__link">
    如果从 1 和L开始的话，无法再位置 1 插入元素
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_160" class="md-nav__link">
    删除元素
  </a>
  
    <nav class="md-nav" aria-label="删除元素">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_161" class="md-nav__link">
    想要删除 ，则必须先知道 的地址
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#getelem_1" class="md-nav__link">
    注意因为插入操作和GetElem操作不同
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0-pl_1" class="md-nav__link">
    要从 0 开始，p要从L开始
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-l-1_1" class="md-nav__link">
    如果从 1 和L开始的话，无法再位置 1 插入元素
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_162" class="md-nav__link">
    总结插入和删除操作算法的不同
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_163" class="md-nav__link">
    销毁链表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_164" class="md-nav__link">
    单链表头文件
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#circular-linked-list_1" class="md-nav__link">
    循环链表(Circular Linked List)
  </a>
  
    <nav class="md-nav" aria-label="循环链表(Circular Linked List)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_165" class="md-nav__link">
    循环链表的特点：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_166" class="md-nav__link">
    最后一个节点的指针域指向头节点，整个表链形成一个环
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_167" class="md-nav__link">
    由此，从表中任意节点出发，可以找到其他节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#next_1" class="md-nav__link">
    和单链表很像，区别就是最后一个节点的next域指向头节点
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#double-linked-list_1" class="md-nav__link">
    双向链表(Double Linked List)
  </a>
  
    <nav class="md-nav" aria-label="双向链表(Double Linked List)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_168" class="md-nav__link">
    有两个指针域，一个指向直接前驱，另一个指向直接后继
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_169" class="md-nav__link">
    数据类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_170" class="md-nav__link">
    初始化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_171" class="md-nav__link">
    创建双向链表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_172" class="md-nav__link">
    插入和删除
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_173" class="md-nav__link">
    线性表玩具
  </a>
  
    <nav class="md-nav" aria-label="线性表玩具">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_174" class="md-nav__link">
    线性表合并
  </a>
  
    <nav class="md-nav" aria-label="线性表合并">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_175" class="md-nav__link">
    已知两个集合
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_176" class="md-nav__link">
    求出合并后集合
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_177" class="md-nav__link">
    有序表合并(并归排序的基础)
  </a>
  
    <nav class="md-nav" aria-label="有序表合并(并归排序的基础)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_178" class="md-nav__link">
    合并成新集合
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_179" class="md-nav__link">
    有序链表合并
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#and_1" class="md-nav__link">
    多项式创建 and 多项式相加
  </a>
  
    <nav class="md-nav" aria-label="多项式创建 and 多项式相加">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_180" class="md-nav__link">
    创建一个多项式，并按照指数的高低排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_181" class="md-nav__link">
    多项式结构体
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_182" class="md-nav__link">
    多项式创建
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polynomial-q-polynimial-pre" class="md-nav__link">
    核心变量为 Polynomial q; Polynimial pre;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#whileq-q-exponent-pnew-exponent" class="md-nav__link">
    核心语句为 while(q &amp;&amp; q-&gt;exponent &lt; pnew-&gt;exponent)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_183" class="md-nav__link">
    主程序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-stack-and-queue_1" class="md-nav__link">
    2. 栈和队列(Stack and Queue)
  </a>
  
    <nav class="md-nav" aria-label="2. 栈和队列(Stack and Queue)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sequence-stack_1" class="md-nav__link">
    顺序栈(Sequence Stack)
  </a>
  
    <nav class="md-nav" aria-label="顺序栈(Sequence Stack)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#topbottom" class="md-nav__link">
    栈是限定仅在表尾进行插入或删除操作的线性表，表末端为栈顶(Top)，表头称为栈顶(Bottom),不含元
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_184" class="md-nav__link">
    素称为空战
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_185" class="md-nav__link">
    (用顺序表存储的栈更常见)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#last-in-first-out-lifo" class="md-nav__link">
    因此栈又称为后进先出(Last in First out, LIFO)的线性表，如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_186" class="md-nav__link">
    栈的类型定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_187" class="md-nav__link">
    栈的初始化
  </a>
  
    <nav class="md-nav" aria-label="栈的初始化">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#top" class="md-nav__link">
    观察上图，发现top指向内存空间不存放元素
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#push_2" class="md-nav__link">
    入栈(Push)
  </a>
  
    <nav class="md-nav" aria-label="入栈(Push)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#topbasetop" class="md-nav__link">
    因为top指向的内存不存放空间，当为base分配的空间存满元素时，top = 分配空间的最后一个元素的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1top-base-stacksize" class="md-nav__link">
    地址+1，此时表示栈满，即top-base = stacksize
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pop_2" class="md-nav__link">
    出栈(Pop)
  </a>
  
    <nav class="md-nav" aria-label="出栈(Pop)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#base-top" class="md-nav__link">
    当 base == top 时，表示栈空
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_188" class="md-nav__link">
    栈的其他操作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_189" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linked-stack_1" class="md-nav__link">
    链栈(Linked Stack)
  </a>
  
    <nav class="md-nav" aria-label="链栈(Linked Stack)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pushpoptop" class="md-nav__link">
    由于栈的主要操作是对栈顶进行Push和Pop，所以选用top作为链表的头节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_190" class="md-nav__link">
    链栈的类型定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_191" class="md-nav__link">
    链栈初始化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#push_3" class="md-nav__link">
    链栈Push
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pop_3" class="md-nav__link">
    链栈Pop
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_192" class="md-nav__link">
    链栈的其他操作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_193" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stackh_1" class="md-nav__link">
    Stack.h
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_194" class="md-nav__link">
    栈与递归
  </a>
  
    <nav class="md-nav" aria-label="栈与递归">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_195" class="md-nav__link">
    函数的调用过程
  </a>
  
    <nav class="md-nav" aria-label="函数的调用过程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_196" class="md-nav__link">
    调用前系统完成：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_3" class="md-nav__link">
    1. 将实参，返回地址(下行代码地址)等传递给被调用函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_1" class="md-nav__link">
    2. 为被调用函数的局部变量分配空间
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_2" class="md-nav__link">
    3. 将控制转移到被调用函数的入口
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_197" class="md-nav__link">
    调用后，系统完成：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_4" class="md-nav__link">
    1. 保存被调用函数的计算结果(返回值)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_2" class="md-nav__link">
    2. 释放被调用函数的数据区
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_3" class="md-nav__link">
    3. 依照被调用函数保存的返回地址，将控制转移到调用函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_198" class="md-nav__link">
    递归调用函数时，如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_199" class="md-nav__link">
    按照调用顺序依此把各个函数入栈
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#returnfislo" class="md-nav__link">
    当栈顶函数满足return条件时，依此出栈(按照FISLO原则)，并且返回值从上向下传递
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fact4" class="md-nav__link">
    直到主程序调用的fact(4)出栈后，递归完成
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_200" class="md-nav__link">
    循环队列
  </a>
  
    <nav class="md-nav" aria-label="循环队列">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_201" class="md-nav__link">
    定义：只能在表的一端进行插入运算，在表的另一端进行删除运算的 线性表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#first-in-firs-out" class="md-nav__link">
    先进先出(First in Firs out)原则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_202" class="md-nav__link">
    数据类型定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drear" class="md-nav__link">
    如上图，(d)虽然数组中的空间没有满，但是rear却不能继续增加，假溢出
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#base" class="md-nav__link">
    解决方法：把base数组想象成一个环形的循环队列如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#front-rere-front-rere1-qmaxsize" class="md-nav__link">
    此时如果 front == rere表示 队空 ，而 front == (rere+1) % QMAXSIZE时表示 队满
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_203" class="md-nav__link">
    顺换队列初始化
  </a>
  
    <nav class="md-nav" aria-label="顺换队列初始化">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#front-rere-0" class="md-nav__link">
    把 front 和 rere 初始化为 0
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_204" class="md-nav__link">
    顺换队列入队
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_205" class="md-nav__link">
    循环队列出队
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_206" class="md-nav__link">
    循环队列其他操作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_207" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_208" class="md-nav__link">
    链队
  </a>
  
    <nav class="md-nav" aria-label="链队">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#front-rere" class="md-nav__link">
    链队结构类似于链表，不同于链表的头指针，用两个指针域 front rere 来表示队列，如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_209" class="md-nav__link">
    数据类型定义：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_210" class="md-nav__link">
    链队初始化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_211" class="md-nav__link">
    链队入队
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_212" class="md-nav__link">
    链队出队
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_213" class="md-nav__link">
    栈和队列玩具
  </a>
  
    <nav class="md-nav" aria-label="栈和队列玩具">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_214" class="md-nav__link">
    进制转化
  </a>
  
    <nav class="md-nav" aria-label="进制转化">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#nn-8" class="md-nav__link">
    一个进转换函数，有一个参数n(十进制)，要求输出n的 8 进制
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_215" class="md-nav__link">
    括号的匹配
  </a>
  
    <nav class="md-nav" aria-label="括号的匹配">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_216" class="md-nav__link">
    输入括号()[]，判断括号是否匹配成功，#字符表示输入结束
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_217" class="md-nav__link">
    例: ([()])成功 [(())]] 失败
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_5" class="md-nav__link">
    写法 1 ：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_3" class="md-nav__link">
    写法 2 ：
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#10_1" class="md-nav__link">
    10 以内的计算器
  </a>
  
    <nav class="md-nav" aria-label="10 以内的计算器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#10_2" class="md-nav__link">
    写出一个只有加减乘除的计算器，要求每一步计算结果小于 10
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_218" class="md-nav__link">
    运算符顺序要求如下(#代表结束标志，且#运算级最小)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_219" class="md-nav__link">
    测试代码:
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_4" class="md-nav__link">
    3. 字符串，数组，广义表
  </a>
  
    <nav class="md-nav" aria-label="3. 字符串，数组，广义表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_220" class="md-nav__link">
    字符串匹配
  </a>
  
    <nav class="md-nav" aria-label="字符串匹配">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_221" class="md-nav__link">
    字符串的存储结构可以分为两类：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_222" class="md-nav__link">
    顺序存储结构：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_223" class="md-nav__link">
    链式存储结构：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_224" class="md-nav__link">
    本笔记只记录顺序存储结构的字符串
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_225" class="md-nav__link">
    输入字符串函数和初始化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bfbrute-force_1" class="md-nav__link">
    BF算法(Brute Force)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bf" class="md-nav__link">
    BF算法效率分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_226" class="md-nav__link">
    令主串长度为 子串长度为 ，若从主串的第个位置开始与模式串匹配成功
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_227" class="md-nav__link">
    则在前 趟匹配中字符总共比较了 次
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_228" class="md-nav__link">
    若第趟匹配成功，则比较次数为 ，总比较次数为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_229" class="md-nav__link">
    即
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_230" class="md-nav__link">
    最坏情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_231" class="md-nav__link">
    假设从主串对的第个位置开始与模式串匹配成功，则在前 趟中总共比较了 次
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_232" class="md-nav__link">
    若第趟匹配成功，则第趟需要 次匹配，总比较次数为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kmp_1" class="md-nav__link">
    KMP算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_233" class="md-nav__link">
    令字符串 ，和模式串
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_234" class="md-nav__link">
    匹配到 和 时失匹 则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_235" class="md-nav__link">
    下标由来： 为失匹之前成功匹配的子串长度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_236" class="md-nav__link">
    指向 中失配字符，则有
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_237" class="md-nav__link">
    下标由来：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_238" class="md-nav__link">
    由 可知，
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_239" class="md-nav__link">
    由 可知，如果 和 失匹，无需从 开始和 比较，只需要把 滑动到 的位置比较即可
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_240" class="md-nav__link">
    令 表示在匹配中 失匹时，让 与 比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_241" class="md-nav__link">
    可得
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_242" class="md-nav__link">
    ，因为当 失匹时字符串来到 位置空串，有 空串
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_243" class="md-nav__link">
    且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_244" class="md-nav__link">
    需要从 开始重新比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#next_2" class="md-nav__link">
    求next数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_245" class="md-nav__link">
    求 数组的过程实际上是 的过程，即如果存在，那么 必然存在
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_246" class="md-nav__link">
    也是模式串的字串匹配模式串的过程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_247" class="md-nav__link">
    设 即有
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_248" class="md-nav__link">
    第一种情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_249" class="md-nav__link">
    此时则有
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_250" class="md-nav__link">
    那么则有
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_251" class="md-nav__link">
    第二种情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_252" class="md-nav__link">
    说明在 处失匹，则回溯到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_253" class="md-nav__link">
    如果 如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_254" class="md-nav__link">
    那么
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_255" class="md-nav__link">
    如果
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_256" class="md-nav__link">
    那么一直回溯 若出现 则同上，若未出现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#next_3" class="md-nav__link">
    未优化前，求next数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_257" class="md-nav__link">
    考虑如下问题，如果回溯的 也等于 会出现什么问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_258" class="md-nav__link">
    会出现无意义比较，解决办法让 也进行回溯
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_259" class="md-nav__link">
    优化后
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kmp_2" class="md-nav__link">
    KMP算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_260" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_261" class="md-nav__link">
    字符串匹配玩具
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_262" class="md-nav__link">
    输入一个病毒序列长度为 ，从文件中读取病人样本，确认病人是否被感染
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_263" class="md-nav__link">
    注意 病毒序列是环状的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_264" class="md-nav__link">
    比如病毒序列为 那么 都属于病毒
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_265" class="md-nav__link">
    思路 利用一个数组存储病毒序列，并把该序列扩大到 长度，依此比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_266" class="md-nav__link">
    实现代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_267" class="md-nav__link">
    数组
  </a>
  
    <nav class="md-nav" aria-label="数组">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_268" class="md-nav__link">
    声明格式 数据类型变量名称行数 列数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_269" class="md-nav__link">
    如
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_270" class="md-nav__link">
    一个二维数组也可以被定义成一维数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_271" class="md-nav__link">
    例如:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_272" class="md-nav__link">
    三维数组 每个元素都是二维数组，且二维数组中的每个元素又都是一维数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_273" class="md-nav__link">
    维数组 每个元素都是 维数组，且 维数组的每个元素都是 维数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_274" class="md-nav__link">
    维数组中的每个元素都是一维数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_275" class="md-nav__link">
    若有三维数组 各元素维
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_276" class="md-nav__link">
    则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_277" class="md-nav__link">
    可以抽象成下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_278" class="md-nav__link">
    若有 维数组，各个维度的元素个数为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_279" class="md-nav__link">
    则
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generalized-list_1" class="md-nav__link">
    广义表(Generalized List)
  </a>
  
    <nav class="md-nav" aria-label="广义表(Generalized List)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_280" class="md-nav__link">
    广义表通常记作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_281" class="md-nav__link">
    为表名通常用大写字母表示
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_282" class="md-nav__link">
    为长度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_283" class="md-nav__link">
    为表的元素
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_284" class="md-nav__link">
    表头 若 非空 ，则第一元素 就是表头
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_285" class="md-nav__link">
    表尾 除表头之外的其他元素组成的表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_286" class="md-nav__link">
    注意 表尾不是一个元素，而是一个子表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_287" class="md-nav__link">
    例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_288" class="md-nav__link">
    空表，
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_289" class="md-nav__link">
    ， 和 都是 但并不是同一
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_290" class="md-nav__link">
    广义表的性质:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_291" class="md-nav__link">
    广义表中的元素有相对次序 一个直接前驱和一个直接后继
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_292" class="md-nav__link">
    广义表的长度定义为最外层所包含的元素个数 广义表的深度定义为该广义表展开后所含括号的层数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_293" class="md-nav__link">
    如 深度 ， 深度 ， 深度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_294" class="md-nav__link">
    注意 原子的深度为 ，空表的深度为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_295" class="md-nav__link">
    在广义表中可以为其他广义表共享，如上述广义表 就共享
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_296" class="md-nav__link">
    广义表可以是一个递归的表，如上述 广义表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_297" class="md-nav__link">
    注意 递归表的长度是有限的，但是深度是
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_298" class="md-nav__link">
    广义表的基本运算
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4_1" class="md-nav__link">
    4. 树、二叉树、森林
  </a>
  
    <nav class="md-nav" aria-label="4. 树、二叉树、森林">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_299" class="md-nav__link">
    定义
  </a>
  
    <nav class="md-nav" aria-label="定义">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_300" class="md-nav__link">
    树是 个节点的有限集合
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_301" class="md-nav__link">
    当 时为空树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_302" class="md-nav__link">
    有且仅有一个称之为根的节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_303" class="md-nav__link">
    令一颗树为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_304" class="md-nav__link">
    除根节点外，可分为 个互不相交的有限集 ，其中一个集合又是一棵树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_305" class="md-nav__link">
    称其为 的子树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_306" class="md-nav__link">
    如下图
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_307" class="md-nav__link">
    树的基本术语
  </a>
  
    <nav class="md-nav" aria-label="树的基本术语">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_308" class="md-nav__link">
    节点的度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_309" class="md-nav__link">
    节点拥有的子树个数成为节点的度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_310" class="md-nav__link">
    如上图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_311" class="md-nav__link">
    树的度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_312" class="md-nav__link">
    树的度是树内各节点度的最大值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_313" class="md-nav__link">
    上图的度为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_314" class="md-nav__link">
    层次
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_315" class="md-nav__link">
    节点的层次从根开始定义，根为第一层，根的孩子为第二层
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_316" class="md-nav__link">
    树中任意节点的层次 它的双亲层次
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_317" class="md-nav__link">
    高度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_318" class="md-nav__link">
    树中节点的最大层次成为树的高度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_319" class="md-nav__link">
    如上图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_320" class="md-nav__link">
    森林
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_321" class="md-nav__link">
    是 颗互不相交的树的集合
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_322" class="md-nav__link">
    对任意一棵树而言，其子树组成森林
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_323" class="md-nav__link">
    二叉树的定义
  </a>
  
    <nav class="md-nav" aria-label="二叉树的定义">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_324" class="md-nav__link">
    是 个节点组成的集合， 时为空树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_325" class="md-nav__link">
    对于非空树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_326" class="md-nav__link">
    有且仅有一个根节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_327" class="md-nav__link">
    除根结点外，有互不相交的 两棵子树可以为空树，分别称其为 的左右子树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_328" class="md-nav__link">
    二叉树的性质
  </a>
  
    <nav class="md-nav" aria-label="二叉树的性质">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_329" class="md-nav__link">
    每个节点最多有两棵子树即
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_330" class="md-nav__link">
    子树有左右之分，不可颠倒
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_331" class="md-nav__link">
    二叉树定理
  </a>
  
    <nav class="md-nav" aria-label="二叉树定理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_332" class="md-nav__link">
    定理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_333" class="md-nav__link">
    在二叉树的第层上，最多有 个节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_334" class="md-nav__link">
    定理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_335" class="md-nav__link">
    深度为 的二叉树，最多有 个节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_336" class="md-nav__link">
    定理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_337" class="md-nav__link">
    令一颗二叉树 有 个节点，其中 分别为 的节点个数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_338" class="md-nav__link">
    即有
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_339" class="md-nav__link">
    可知 的根无双亲节点，而其他的节点都有双亲 令这些节点的个数为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_340" class="md-nav__link">
    即
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_341" class="md-nav__link">
    由 可知
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_342" class="md-nav__link">
    所以
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_343" class="md-nav__link">
    完全二叉树性质及定理
  </a>
  
    <nav class="md-nav" aria-label="完全二叉树性质及定理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_344" class="md-nav__link">
    定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_345" class="md-nav__link">
    深度为 的，由 个节点的二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_346" class="md-nav__link">
    当且仅当其每一个节点都与深度为 的满二叉树中编号从 到 的节点一一对应时
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_347" class="md-nav__link">
    称其为完全二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_348" class="md-nav__link">
    如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_349" class="md-nav__link">
    特点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_350" class="md-nav__link">
    对完全二叉树的任意节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_351" class="md-nav__link">
    若其右分支的子孙最大层次为 ，则其左分支的子孙最大层次为 或
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_352" class="md-nav__link">
    定理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_353" class="md-nav__link">
    若一个完全二叉树有 个节点，深度为 ，则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_354" class="md-nav__link">
    根据完全二叉树性质可知
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_355" class="md-nav__link">
    对其 化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_356" class="md-nav__link">
    因为 所以
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_357" class="md-nav__link">
    定理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_358" class="md-nav__link">
    一颗完全二叉树 ，有 个节点，若按照节点层次从左到右给其编号，则对于任意节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_359" class="md-nav__link">
    无双亲
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_360" class="md-nav__link">
    的双亲为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_361" class="md-nav__link">
    则无左孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_362" class="md-nav__link">
    为的左孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_363" class="md-nav__link">
    则无右孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_364" class="md-nav__link">
    则 为的右孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_365" class="md-nav__link">
    如下图
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_366" class="md-nav__link">
    链式二叉树
  </a>
  
    <nav class="md-nav" aria-label="链式二叉树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_367" class="md-nav__link">
    存储结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_368" class="md-nav__link">
    遍历方式(递归)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_369" class="md-nav__link">
    遍历方式(非递归)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_370" class="md-nav__link">
    先序遍历创建二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_371" class="md-nav__link">
    测试(创建，遍历)
  </a>
  
    <nav class="md-nav" aria-label="测试(创建，遍历)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_372" class="md-nav__link">
    输入如下一棵树，按照中序遍历方式输出
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_373" class="md-nav__link">
    层次遍历算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_374" class="md-nav__link">
    复制二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_375" class="md-nav__link">
    求深度和节点数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_376" class="md-nav__link">
    销毁二叉树(递归和非递归)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_377" class="md-nav__link">
    头文件
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#threaded-binary-tree_1" class="md-nav__link">
    线索二叉树 Threaded Binary Tree(了解即可)
  </a>
  
    <nav class="md-nav" aria-label="线索二叉树 Threaded Binary Tree(了解即可)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_378" class="md-nav__link">
    问题，如何寻找特点遍历顺序中二叉树节点的前驱和后继
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_379" class="md-nav__link">
    办法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_380" class="md-nav__link">
    通过遍历，浪费时间
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_381" class="md-nav__link">
    给结构体内增加前驱和后继指针，增加存储负担
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_382" class="md-nav__link">
    利用二叉链表中的空指针域
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_383" class="md-nav__link">
    定理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_384" class="md-nav__link">
    如果一个二叉树有 个节点，那么空指针域为 个
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_385" class="md-nav__link">
    总指针域为 个，除去根节点，一个有 个节点，即需要 个指针域
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_386" class="md-nav__link">
    线索二叉树的定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_387" class="md-nav__link">
    如果某个节点的左孩子为空，那么利用左孩子指针域，把它指向它的前驱
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_388" class="md-nav__link">
    如果右孩子为空，则指向它后继
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_389" class="md-nav__link">
    这种改变指向的指针称为线索
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_390" class="md-nav__link">
    数据类型定义
  </a>
  
    <nav class="md-nav" aria-label="数据类型定义">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_391" class="md-nav__link">
    左孩子为空
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_392" class="md-nav__link">
    左孩子指向前驱
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_393" class="md-nav__link">
    右孩子为空
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_394" class="md-nav__link">
    右孩子指向前驱
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_395" class="md-nav__link">
    如果按照遍历的顺序，那么序列中第一个元素必然没有前驱
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_396" class="md-nav__link">
    把该节点的左孩子指向一个头指针
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_397" class="md-nav__link">
    该头指针的左孩子指向根节点，右孩子指向序列最后一个节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_398" class="md-nav__link">
    一个中序遍历为 的线索二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_399" class="md-nav__link">
    如下图
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_400" class="md-nav__link">
    树和森林
  </a>
  
    <nav class="md-nav" aria-label="树和森林">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_401" class="md-nav__link">
    树的存储结构
  </a>
  
    <nav class="md-nav" aria-label="树的存储结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_6" class="md-nav__link">
    1. 双亲表示法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_4" class="md-nav__link">
    2. 孩子链表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_5" class="md-nav__link">
    3. 孩子兄弟表示法(树转化二叉树的基础)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_402" class="md-nav__link">
    树与二叉树之间相互转换
  </a>
  
    <nav class="md-nav" aria-label="树与二叉树之间相互转换">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_403" class="md-nav__link">
    树转二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_404" class="md-nav__link">
    在兄弟之间连线
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_405" class="md-nav__link">
    对于任意一个节点 ，除了其左孩子外，去除掉所有孩子与其的关系
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_406" class="md-nav__link">
    以根节点的左孩子为中心，顺时针旋转 ，再与根节点相连
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_407" class="md-nav__link">
    二叉树转树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_408" class="md-nav__link">
    若 节点是双亲节点的左孩子，则将 的右孩子，右孩子的右孩子 连接到 的双亲结点上
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_409" class="md-nav__link">
    抹掉所有双亲结点和右孩子之间关系
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_410" class="md-nav__link">
    整理成树状
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_411" class="md-nav__link">
    森林与二叉树之间的转化
  </a>
  
    <nav class="md-nav" aria-label="森林与二叉树之间的转化">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_412" class="md-nav__link">
    森林转二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_413" class="md-nav__link">
    将森林中的各棵树转化为二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_414" class="md-nav__link">
    链接这些二叉树的根节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_415" class="md-nav__link">
    第一棵树的根为二叉树的根，进行调整
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_416" class="md-nav__link">
    二叉树转森林
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_417" class="md-nav__link">
    若是二叉树的根，则取消所有 的右孩子，右孩子的右孩子 之间的关系
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_418" class="md-nav__link">
    此时有 颗孤立的二叉树，把这些二叉树转成树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_419" class="md-nav__link">
    树和森林的遍历
  </a>
  
    <nav class="md-nav" aria-label="树和森林的遍历">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_420" class="md-nav__link">
    树的遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_421" class="md-nav__link">
    先根遍历 若树不为空，则先访问根节点，然后再依次先根遍历遍历各个子树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_422" class="md-nav__link">
    后根遍历 若树不为空，先依次后根遍历各个子树，再访问根节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_423" class="md-nav__link">
    层次遍历 自上到下，从左到右
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#s" class="md-nav__link">
    s
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_424" class="md-nav__link">
    先根遍历为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_425" class="md-nav__link">
    后根遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_426" class="md-nav__link">
    森林的遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_427" class="md-nav__link">
    假设有森林 ，有 棵互不相交的树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_428" class="md-nav__link">
    将森林看成三部分
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_429" class="md-nav__link">
    森林中第一棵树的根节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_430" class="md-nav__link">
    森林中第一棵树的所有子树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_431" class="md-nav__link">
    森林中 到 颗树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_432" class="md-nav__link">
    先序遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_433" class="md-nav__link">
    访问 的根节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_434" class="md-nav__link">
    先序遍历 的所有子树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_435" class="md-nav__link">
    先序遍历 到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_436" class="md-nav__link">
    即从左到右依次对 进行先根遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_437" class="md-nav__link">
    中序遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_438" class="md-nav__link">
    中序遍历 的所有子树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_439" class="md-nav__link">
    访问 的根节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_440" class="md-nav__link">
    中序遍历 到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_441" class="md-nav__link">
    即从左到右依次对 进行后根遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_442" class="md-nav__link">
    对上图进行先序遍历和中序遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_443" class="md-nav__link">
    先序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_444" class="md-nav__link">
    中序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_445" class="md-nav__link">
    哈夫曼树
  </a>
  
    <nav class="md-nav" aria-label="哈夫曼树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_446" class="md-nav__link">
    术语
  </a>
  
    <nav class="md-nav" aria-label="术语">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_447" class="md-nav__link">
    路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_448" class="md-nav__link">
    从树中一个节点到另一个节点之间的分支，组成两个节点间的路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_449" class="md-nav__link">
    节点的路径长度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_450" class="md-nav__link">
    两节点间路径上的分支数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_451" class="md-nav__link">
    树的路径长度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_452" class="md-nav__link">
    从树根到每一个节点的路径长度之和，记作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_453" class="md-nav__link">
    节点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_454" class="md-nav__link">
    权
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_455" class="md-nav__link">
    将树中节点赋给一个含有某种意义的值，这个值叫
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_456" class="md-nav__link">
    结点的带权路径长度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_457" class="md-nav__link">
    从根节点到该节点之间的路径长度与该节点的乘积，即
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_458" class="md-nav__link">
    树的带权路径长度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_459" class="md-nav__link">
    树中所有叶子节点的带权路径长度之和
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_460" class="md-nav__link">
    如下图
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_461" class="md-nav__link">
    最优二叉树
  </a>
  
    <nav class="md-nav" aria-label="最优二叉树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_462" class="md-nav__link">
    哈夫曼树，又称最优二叉树，即带权路径 最短的树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_463" class="md-nav__link">
    注意
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_464" class="md-nav__link">
    是 相同的树比较之下
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_465" class="md-nav__link">
    完全二叉树包括满二叉树不一定是哈夫曼树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_466" class="md-nav__link">
    哈夫曼树中权值越大的叶子节点离根节点越近
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_467" class="md-nav__link">
    具有相同带权路径的哈夫曼树，节点位置不唯一
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_468" class="md-nav__link">
    构造哈夫曼树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#step_1" class="md-nav__link">
    step和定理
  </a>
  
    <nav class="md-nav" aria-label="step和定理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_469" class="md-nav__link">
    根据 个给定的权值 构成 个只有根节点的森林 森林里全是根
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_470" class="md-nav__link">
    在 中选取两个权值最小的树 ，构造一颗新的二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_471" class="md-nav__link">
    在 中删除 ，把 加入 中
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_472" class="md-nav__link">
    重复如上步骤，直到 中只有一颗树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_473" class="md-nav__link">
    定理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_474" class="md-nav__link">
    包含 个节点的树，需要经过 次合并才能形成哈夫曼树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_475" class="md-nav__link">
    定理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_476" class="md-nav__link">
    把一颗含有 个节点的树，转化成哈夫曼树，那么这个哈夫曼树一共有 个
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_477" class="md-nav__link">
    定理
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_478" class="md-nav__link">
    代码实现
  </a>
  
    <nav class="md-nav" aria-label="代码实现">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_479" class="md-nav__link">
    数据类型定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_480" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_481" class="md-nav__link">
    哈夫曼编码
  </a>
  
    <nav class="md-nav" aria-label="哈夫曼编码">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_482" class="md-nav__link">
    讨论的背景
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_483" class="md-nav__link">
    在远程通信中传递字符串时，需要转换成二进制的字符串
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_484" class="md-nav__link">
    即，让待传递字符串中出现次数多的字符采用尽可能短的编码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_485" class="md-nav__link">
    这样的话二进制字符串的编码就会缩短
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_486" class="md-nav__link">
    但，由于二进制只有 和 ，所以有可能二进制代码转成字符时，出现二义性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_487" class="md-nav__link">
    所以要设计长度不等的编码，则必须使任一字符的编码都不是另一个字符编码的前缀
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_488" class="md-nav__link">
    如上形式的编码称为 前缀码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_489" class="md-nav__link">
    哈夫曼编码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_490" class="md-nav__link">
    哈夫曼编码是总长最短的前缀码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_491" class="md-nav__link">
    统计字符集中每个字符在电文中出现的平均概率概率越大，编码要求最短
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_492" class="md-nav__link">
    利用哈夫曼树的特点 权值越大的叶子离根越近 将每个字符的概率值最为权值，构造哈夫曼树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_493" class="md-nav__link">
    在哈夫曼树的每个分支上标 和 ，左分支为 ，右分支为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_494" class="md-nav__link">
    为什么哈夫曼编码是最短的前缀码？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_495" class="md-nav__link">
    根据哈夫曼树的特性，原树中的 个节点，在哈夫曼树中变成了叶子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_496" class="md-nav__link">
    叶子节点不会是另一个叶子的双亲或是祖先，所以是前缀码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_497" class="md-nav__link">
    哈夫曼树的性质
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_498" class="md-nav__link">
    性质 哈夫曼编码是前缀码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_499" class="md-nav__link">
    性质 哈夫曼编码是最优前缀码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_500" class="md-nav__link">
    代码实现
  </a>
  
    <nav class="md-nav" aria-label="代码实现">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_501" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_502" class="md-nav__link">
    构建如下哈夫曼编码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#define-nodes-7" class="md-nav__link">
    define NODES 7
  </a>
  
    <nav class="md-nav" aria-label="define NODES 7">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_503" class="md-nav__link">
    整体头文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5-graph_1" class="md-nav__link">
    5. 图(Graph)
  </a>
  
    <nav class="md-nav" aria-label="5. 图(Graph)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_504" class="md-nav__link">
    图的定义和术语
  </a>
  
    <nav class="md-nav" aria-label="图的定义和术语">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_505" class="md-nav__link">
    图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_506" class="md-nav__link">
    顶点的有限非空集合
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_507" class="md-nav__link">
    边的有限集合
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_508" class="md-nav__link">
    图分为有向图 和无向图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_509" class="md-nav__link">
    如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_510" class="md-nav__link">
    完全图
  </a>
  
    <nav class="md-nav" aria-label="完全图">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_511" class="md-nav__link">
    完全图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_512" class="md-nav__link">
    任意两个点都有一条边相连
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_513" class="md-nav__link">
    若有 个顶点的无向完全图，则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_514" class="md-nav__link">
    若有 个顶点的有向完全图，则
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sparse-graphdense-gaph_1" class="md-nav__link">
    稀疏图(Sparse Graph)和稠密图(Dense Gaph)
  </a>
  
    <nav class="md-nav" aria-label="稀疏图(Sparse Graph)和稠密图(Dense Gaph)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_515" class="md-nav__link">
    稠密图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_516" class="md-nav__link">
    稠密图 有较多边的图
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#degree_1" class="md-nav__link">
    顶点的度(degree)
  </a>
  
    <nav class="md-nav" aria-label="顶点的度(degree)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_517" class="md-nav__link">
    与该顶点相关联的边的数量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_518" class="md-nav__link">
    中，顶点的度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_519" class="md-nav__link">
    问题 当 中，仅有一个顶点的 为 ，其余顶点的 ，此时图为什么形状
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_520" class="md-nav__link">
    答 树，有向树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#path_1" class="md-nav__link">
    路径(path)
  </a>
  
    <nav class="md-nav" aria-label="路径(path)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_521" class="md-nav__link">
    路径 接续的边构成的顶点序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_522" class="md-nav__link">
    路径长度 路径上边的数量或权值之和
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_523" class="md-nav__link">
    回路 第一个顶点和最后一个顶点相同的路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_524" class="md-nav__link">
    路径 路径上的顶点均不相同
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_525" class="md-nav__link">
    回路 除路径起点和终点可以相同外，其余顶点均不相同的路径
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#connected-graph_1" class="md-nav__link">
    连通图(Connected Graph)
  </a>
  
    <nav class="md-nav" aria-label="连通图(Connected Graph)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_526" class="md-nav__link">
    若连通图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_527" class="md-nav__link">
    在无向图 中
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_528" class="md-nav__link">
    若对任何两个顶点 ，都存在 路径，则 是连通图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_529" class="md-nav__link">
    弱连通图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_530" class="md-nav__link">
    若把有向图 中所有的边替换成无向边，此时得到的图为 的基图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_531" class="md-nav__link">
    若它的基图为连通图，则 为若连通
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_532" class="md-nav__link">
    强连通
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_533" class="md-nav__link">
    任取有向图 中两个顶点 ，若 和 中间存在路径，则 为强连通
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#connected-component_1" class="md-nav__link">
    连通子图和连通分量(Connected Component)
  </a>
  
    <nav class="md-nav" aria-label="连通子图和连通分量(Connected Component)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_534" class="md-nav__link">
    无向图 的极大连通子图称为 的连通分量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_535" class="md-nav__link">
    极大连通子图 若无向图 的子图 为连通图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_536" class="md-nav__link">
    任取 即
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_537" class="md-nav__link">
    若把 加入到 中，如果 不再连通，则称 为 的极大连通子图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_538" class="md-nav__link">
    如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_539" class="md-nav__link">
    强连通分量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_540" class="md-nav__link">
    有向图 的极大强连通子图称为 的连通分量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_541" class="md-nav__link">
    若有向图 的子图 为连通图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_542" class="md-nav__link">
    任取 即
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_543" class="md-nav__link">
    若把 加入到 中，如果 不再连通，则称 为 的极大强连通子图
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#spanning-tree_2" class="md-nav__link">
    极小连通子图和生成树(Spanning Tree)
  </a>
  
    <nav class="md-nav" aria-label="极小连通子图和生成树(Spanning Tree)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_544" class="md-nav__link">
    若子图 是 的连通子图，在改子图中删除任意一条边， 不再连通，则称 是 的极小连通子图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_545" class="md-nav__link">
    注意 极小连通子图中不存在 ，极大连通子图可以存在
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_546" class="md-nav__link">
    生成树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_547" class="md-nav__link">
    若无向图 ， 中所有的点构成的极小连通子图就是 的生成树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_548" class="md-nav__link">
    图的存储结构
  </a>
  
    <nav class="md-nav" aria-label="图的存储结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#adjacency-matrix_1" class="md-nav__link">
    邻接矩阵(Adjacency Matrix)
  </a>
  
    <nav class="md-nav" aria-label="邻接矩阵(Adjacency Matrix)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_549" class="md-nav__link">
    若有图 ，有 个顶点，则对应 矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_550" class="md-nav__link">
    注意 无向图的邻接矩阵为对称矩阵，而有向图的邻接矩阵未必
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_551" class="md-nav__link">
    无向图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_552" class="md-nav__link">
    的邻接矩阵为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_553" class="md-nav__link">
    行中 的个数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_554" class="md-nav__link">
    有向图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_555" class="md-nav__link">
    第列 的个数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_556" class="md-nav__link">
    第行 的个数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#weighted-graph_1" class="md-nav__link">
    带权图(网) weighted Graph
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_557" class="md-nav__link">
    若有带权图 ，有 个顶点，则对应 矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_558" class="md-nav__link">
    代码实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_559" class="md-nav__link">
    数据类型定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_560" class="md-nav__link">
    无向无权图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_561" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_562" class="md-nav__link">
    无向带权图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_563" class="md-nav__link">
    有向带权图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_564" class="md-nav__link">
    有向无权图
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adjacency-list_1" class="md-nav__link">
    邻接表(Adjacency List)
  </a>
  
    <nav class="md-nav" aria-label="邻接表(Adjacency List)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_565" class="md-nav__link">
    数据类型定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_566" class="md-nav__link">
    代码实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_567" class="md-nav__link">
    无向无权图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#weight" class="md-nav__link">
    无向有权，有向无权，有向有权图的创建方法和此方法类似，只需改动weight,和新建节点个数即可
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_568" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_569" class="md-nav__link">
    邻接表和邻接矩阵的比较
  </a>
  
    <nav class="md-nav" aria-label="邻接表和邻接矩阵的比较">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_570" class="md-nav__link">
    邻接矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_571" class="md-nav__link">
    优点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_572" class="md-nav__link">
    便于判断顶点间是否有边
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_573" class="md-nav__link">
    便于计算各个顶点的度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_574" class="md-nav__link">
    缺点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_575" class="md-nav__link">
    不便于插入和删除顶点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_576" class="md-nav__link">
    不便于统计边数，需要扫描矩阵才能计算.
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_577" class="md-nav__link">
    空间复杂度较高，但如果 较大时，可以采用上三角或下三角矩阵(因为矩阵是对称的)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_578" class="md-nav__link">
    邻接表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_579" class="md-nav__link">
    优点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_580" class="md-nav__link">
    便于增加和删除顶点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_581" class="md-nav__link">
    便于统计边的数量，按顶点顺序扫描所有边即可。
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_582" class="md-nav__link">
    空间效率高，无向图 ，有向图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_583" class="md-nav__link">
    缺点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_584" class="md-nav__link">
    不便于判断两顶点间是否有边(相对于矩阵的随机取值而言)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_585" class="md-nav__link">
    不便于计算各个顶点的度。
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_586" class="md-nav__link">
    对于无向图， 第个表的节点个数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_587" class="md-nav__link">
    对无向图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_588" class="md-nav__link">
    )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_589" class="md-nav__link">
    ，入度为第个表的节点个数，但是出度却要历遍所有的表
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_590" class="md-nav__link">
    十字链表
  </a>
  
    <nav class="md-nav" aria-label="十字链表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#degree_2" class="md-nav__link">
    十字链表可以解决用邻接链表储存的有向图求顶点degree的问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_591" class="md-nav__link">
    根据上图可知，一条边即是一个顶点的入度，也是另外一个顶点的出度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_592" class="md-nav__link">
    设是 的一条边
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_593" class="md-nav__link">
    当建立边节点 时，使 的 域指向，使 的 指向
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_594" class="md-nav__link">
    当 再次有出度边 时，使 的 域指向 的 所指节点 指向
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_595" class="md-nav__link">
    当 再次有入度边 时，使 的 域指向 的 所指节点 指向
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_596" class="md-nav__link">
    邻接多重链表
  </a>
  
    <nav class="md-nav" aria-label="邻接多重链表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_597" class="md-nav__link">
    用于 解决 用 邻接表 存储的 无向图 每条边都要存储 两遍 的问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_598" class="md-nav__link">
    如上图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_599" class="md-nav__link">
    记录该边是否被搜索过
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_600" class="md-nav__link">
    分别表示边 顶点的下标
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_601" class="md-nav__link">
    分别表示 的下条边节点， 的下条边节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_602" class="md-nav__link">
    令
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_603" class="md-nav__link">
    使 的 指向 的 域， 的 指向 的 域
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_604" class="md-nav__link">
    的 的下标， 的 的下标
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_605" class="md-nav__link">
    使 和 的 指向
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_606" class="md-nav__link">
    遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_607" class="md-nav__link">
    令 的 为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_608" class="md-nav__link">
    打印
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_609" class="md-nav__link">
    图的遍历
  </a>
  
    <nav class="md-nav" aria-label="图的遍历">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_610" class="md-nav__link">
    图中可能存在 ，且图的任何一点都有可能和其他顶点相连
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_611" class="md-nav__link">
    在访问完某个顶点之后，可能会沿着某些边又回到了曾经访问过的顶点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_612" class="md-nav__link">
    解决思路
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_613" class="md-nav__link">
    设置辅助数组 ，用来标记顶点是否被访问过
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_614" class="md-nav__link">
    顶点未被访问过
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_615" class="md-nav__link">
    顶点被访问过
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#depth-first-search_1" class="md-nav__link">
    深度优先 (Depth First Search)
  </a>
  
    <nav class="md-nav" aria-label="深度优先 (Depth First Search)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_616" class="md-nav__link">
    算法描述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_617" class="md-nav__link">
    先访问 ，再访问 的邻接点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_618" class="md-nav__link">
    再访问 的邻接点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_619" class="md-nav__link">
    开始出栈，控制节点再次来到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_620" class="md-nav__link">
    因为 已经被访问过，所以开始访问
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_621" class="md-nav__link">
    全部出栈完，控制再次回到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_622" class="md-nav__link">
    出栈，结束
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_623" class="md-nav__link">
    代码实现下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_624" class="md-nav__link">
    注意上图中的当访问完 之后，并不是直接回到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_625" class="md-nav__link">
    而是退回到 ，需要依次出栈
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_626" class="md-nav__link">
    遍历矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_627" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_628" class="md-nav__link">
    遍历邻接表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_629" class="md-nav__link">
    注意:使用邻接表时，遍历的顺序和邻接矩阵不一样，因为创建邻接表使用头插法(如果使用尾插法顺序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_630" class="md-nav__link">
    则一样)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_631" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#breadth-first-search_1" class="md-nav__link">
    广度优先 (Breadth First Search)
  </a>
  
    <nav class="md-nav" aria-label="广度优先 (Breadth First Search)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_632" class="md-nav__link">
    从图的 出发，首先访问 ，然后访问 的所有邻接点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_633" class="md-nav__link">
    然后按照 的顺序，依次访问他们的邻接点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_634" class="md-nav__link">
    实现遍历下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_635" class="md-nav__link">
    代码实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_636" class="md-nav__link">
    遍历矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_637" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_638" class="md-nav__link">
    遍历邻接表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_639" class="md-nav__link">
    注意:使用邻接表时，遍历的顺序和邻接矩阵不一样，因为创建邻接表使用头插法(如果使用尾插法顺序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_640" class="md-nav__link">
    则一样)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_641" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_642" class="md-nav__link">
    算法效率
  </a>
  
    <nav class="md-nav" aria-label="算法效率">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_643" class="md-nav__link">
    可知，邻接矩阵的时间效率为 邻接表的时间效率为
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#spanning-tree_3" class="md-nav__link">
    最小生成树 Spanning Tree
  </a>
  
    <nav class="md-nav" aria-label="最小生成树 Spanning Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#prim_1" class="md-nav__link">
    Prim 算法
  </a>
  
    <nav class="md-nav" aria-label="Prim 算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_644" class="md-nav__link">
    令 为连通图带权，且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_645" class="md-nav__link">
    设起点为 把 加入到 中
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_646" class="md-nav__link">
    选取 为最小
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_647" class="md-nav__link">
    输出 边
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_648" class="md-nav__link">
    把 加入 中
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_649" class="md-nav__link">
    选取 为最小
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_650" class="md-nav__link">
    输出 边
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_651" class="md-nav__link">
    直到存在 条边
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_652" class="md-nav__link">
    此时输出的边即为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_653" class="md-nav__link">
    代码实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#spanning-tree_4" class="md-nav__link">
    实现下图的Spanning Tree
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#u" class="md-nav__link">
    需要辅助集合U
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_654" class="md-nav__link">
    邻接矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_655" class="md-nav__link">
    前置算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_656" class="md-nav__link">
    邻接表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_657" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kruskal_1" class="md-nav__link">
    Kruskal 算法
  </a>
  
    <nav class="md-nav" aria-label="Kruskal 算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_658" class="md-nav__link">
    定理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_659" class="md-nav__link">
    若无向有权无环图 为 图的最大连通子图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_660" class="md-nav__link">
    ，作为连通依赖点，则 集合所有点必然存在一条通往 的路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_661" class="md-nav__link">
    单个顶点的连通依赖点为自身注意 表示为 不可以这么表示
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_662" class="md-nav__link">
    令 为连通依赖点，且 使 之间并不存在路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_663" class="md-nav__link">
    为连通图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_664" class="md-nav__link">
    引理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_665" class="md-nav__link">
    若 分别为 的最大连通子图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_666" class="md-nav__link">
    若 ，则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_667" class="md-nav__link">
    利用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_668" class="md-nav__link">
    若 ，则说明 中所有的点都有一条通往 的路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_669" class="md-nav__link">
    为最大连通子图子图 同理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_670" class="md-nav__link">
    算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_671" class="md-nav__link">
    若存在无向带权图 且 连通
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_672" class="md-nav__link">
    令集合
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_673" class="md-nav__link">
    对 进行排序，取 ，把 加入 中
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_674" class="md-nav__link">
    循环对 进行如下操作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_675" class="md-nav__link">
    如果 的连通依赖点 的联通点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_676" class="md-nav__link">
    则把 加入到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_677" class="md-nav__link">
    直到遍历所有边
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_678" class="md-nav__link">
    集合中为 的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_679" class="md-nav__link">
    代码实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_680" class="md-nav__link">
    数据类型定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_681" class="md-nav__link">
    采用冒泡排序，可以灵活变换
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_682" class="md-nav__link">
    邻接矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_683" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_684" class="md-nav__link">
    邻接表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_685" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_686" class="md-nav__link">
    最短路径
  </a>
  
    <nav class="md-nav" aria-label="最短路径">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dijkstra_1" class="md-nav__link">
    Dijkstra 算法
  </a>
  
    <nav class="md-nav" aria-label="Dijkstra 算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_687" class="md-nav__link">
    若有无向带权网
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_688" class="md-nav__link">
    以 为顶点，求出所有 和 间的最路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_689" class="md-nav__link">
    令 为 到 间的路径长度，集合
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_690" class="md-nav__link">
    若 存在，则初始化 ，若不存在则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_691" class="md-nav__link">
    遍历所有点之后，把 加入到 中
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_692" class="md-nav__link">
    把 加入到 中，若 为 的邻接点，且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_693" class="md-nav__link">
    则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_694" class="md-nav__link">
    重复上步骤，直到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_695" class="md-nav__link">
    用代码实现此图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_696" class="md-nav__link">
    代码实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_697" class="md-nav__link">
    邻接矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_698" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#floyd_1" class="md-nav__link">
    Floyd算法
  </a>
  
    <nav class="md-nav" aria-label="Floyd算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_699" class="md-nav__link">
    本质上为暴力算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_700" class="md-nav__link">
    令矩阵 存储图 的权值，其中 有 个顶点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_701" class="md-nav__link">
    表示到的 表示 到 的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_702" class="md-nav__link">
    遍历矩阵所有元素，向 之间插入点 ，如果
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_703" class="md-nav__link">
    则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_704" class="md-nav__link">
    遍历结束后，矩阵 记录 的最短路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_705" class="md-nav__link">
    代码实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_706" class="md-nav__link">
    邻接矩阵
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#directed-acycline-graph_1" class="md-nav__link">
    有向无环图(Directed Acycline Graph)
  </a>
  
    <nav class="md-nav" aria-label="有向无环图(Directed Acycline Graph)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#aocaoe_1" class="md-nav__link">
    AOC和AOE
  </a>
  
    <nav class="md-nav" aria-label="AOC和AOE">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_707" class="md-nav__link">
    网
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_708" class="md-nav__link">
    用一个有向图表示一个工程的各个子工程及其相互制约关系
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_709" class="md-nav__link">
    其中顶点表示活动，弧表示优先制约关系
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_710" class="md-nav__link">
    网
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_711" class="md-nav__link">
    弧表示活动，以顶点表示活动开始或结束事件
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_712" class="md-nav__link">
    拓扑排序
  </a>
  
    <nav class="md-nav" aria-label="拓扑排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_713" class="md-nav__link">
    在 网没有回路的前提下，将全部活动排列成一个线性序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_714" class="md-nav__link">
    网中边 存在，则在这个序列中一定排在的前面
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_715" class="md-nav__link">
    对 网进行如上排序，即为拓扑排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_716" class="md-nav__link">
    算法思路
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_717" class="md-nav__link">
    若 图中 ，则去除掉所有和 相关的边
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_718" class="md-nav__link">
    令 ，把 加入到 中
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_719" class="md-nav__link">
    更新所有 的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_720" class="md-nav__link">
    直到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_721" class="md-nav__link">
    此时 的序列则为拓扑序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_722" class="md-nav__link">
    代码实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_723" class="md-nav__link">
    实现下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_724" class="md-nav__link">
    邻接表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_725" class="md-nav__link">
    前置函数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_726" class="md-nav__link">
    关键路径
  </a>
  
    <nav class="md-nav" aria-label="关键路径">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_727" class="md-nav__link">
    如上图 网，源点 表示事件整体的开始，汇点 表示事件整体结束
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_728" class="md-nav__link">
    其他的点则表示一个活动的结束，同时也表示另外一个活动的开始
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_729" class="md-nav__link">
    关 表示时间，而 表示活动， 表示活动所需要的时间
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_730" class="md-nav__link">
    令 表示 的最早开始时间，即 时间之前的活动必须完成， 才能开始
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_731" class="md-nav__link">
    即 为的直接前驱
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_732" class="md-nav__link">
    令 表示 的最迟开始时间 即 的后继点 需要为 留出时间 为 的直接前驱
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_733" class="md-nav__link">
    若已知 ，则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_734" class="md-nav__link">
    活动时间 表示边 的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_735" class="md-nav__link">
    表示， 发生的最早时间，只有 发生了， 才能发生
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_736" class="md-nav__link">
    所以
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_737" class="md-nav__link">
    注意
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_738" class="md-nav__link">
    ，即源点 的最早发生时间为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_739" class="md-nav__link">
    即汇点 的发生最早时间 的最迟时间
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_740" class="md-nav__link">
    由此可知 从源点开始向前递归 从后向前递归
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_741" class="md-nav__link">
    表示 的最迟发生时间
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_742" class="md-nav__link">
    若 则说明活动 没有缓冲时间，为关键路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_743" class="md-nav__link">
    如果 这说明活动 有 时间可以调整
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_744" class="md-nav__link">
    代码实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_745" class="md-nav__link">
    实现下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_746" class="md-nav__link">
    邻接表
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_747" class="md-nav__link">
    图的头文件
  </a>
  
    <nav class="md-nav" aria-label="图的头文件">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#define_graphh_1" class="md-nav__link">
    define_Graph.h
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#amgraphh_1" class="md-nav__link">
    AMGraph.h
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#algraphh_1" class="md-nav__link">
    ALGraph.h
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#endif" class="md-nav__link">
    endif
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
        
      
      <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_5" >
      
      
        
          
        
      
      
        <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
          数据结构实验
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          数据结构实验
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
        
      
      <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_5_1" >
      
      
        
          
        
      
      
        <label class="md-nav__link" for="__nav_5_1" id="__nav_5_1_label" tabindex="0">
          顺序表
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5_1">
          <span class="md-nav__icon md-icon"></span>
          顺序表
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C/%E6%95%B0%E6%8D%AE%E5%AE%9E%E9%AA%8C_%E5%AD%A6%E7%94%9F%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%BA%E5%BA%8F%E8%A1%A8/" class="md-nav__link">
        学生通讯录
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
        
      
      <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_6" >
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
          排序算法
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          排序算法
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sortAlgorithm/bubbleSort/" class="md-nav__link">
        冒泡排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sortAlgorithm/countingSort/" class="md-nav__link">
        计数排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sortAlgorithm/heapSort/" class="md-nav__link">
        堆排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sortAlgorithm/insertionSort/" class="md-nav__link">
        插入排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sortAlgorithm/mergeSort/" class="md-nav__link">
        归并排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sortAlgorithm/quickSort/" class="md-nav__link">
        快速排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sortAlgorithm/selectionSort/" class="md-nav__link">
        选择排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sortAlgorithm/shellSort/" class="md-nav__link">
        希尔排序
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    数据结构
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    宏定义
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1. 线性表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sequence-list" class="md-nav__link">
    顺序表(Sequence List)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    初始化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    获取元素
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    查找元素
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    插入
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    删除
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    销毁，清空，检查为空
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    顺序表的头文件
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#single-linked-list" class="md-nav__link">
    单链表(Single Linked List)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    初始化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    创建链表(头插法)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    创建链表(尾插法)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    获取元素
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    查找元素
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    插入元素
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    删除元素
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    总结插入和删除操作算法的不同
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    销毁链表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    单链表头文件
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#circular-linked-list" class="md-nav__link">
    循环链表(Circular Linked List)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#double-linked-list" class="md-nav__link">
    双向链表(Double Linked List)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    初始化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    创建双向链表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    插入和删除
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    线性表玩具
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    线性表合并
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    有序表合并(并归排序的基础)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    有序链表合并
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#and" class="md-nav__link">
    多项式创建 and 多项式相加
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-stack-and-queue" class="md-nav__link">
    2. 栈和队列(Stack and Queue)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sequence-stack" class="md-nav__link">
    顺序栈(Sequence Stack)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    栈的类型定义
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    栈的初始化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#push" class="md-nav__link">
    入栈(Push)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pop" class="md-nav__link">
    出栈(Pop)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    栈的其他操作
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    测试代码
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#linked-stack" class="md-nav__link">
    链栈(Linked Stack)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    链栈的类型定义
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    链栈初始化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#push_1" class="md-nav__link">
    链栈Push
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pop_1" class="md-nav__link">
    链栈Pop
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    链栈的其他操作
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    测试代码
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#stackh" class="md-nav__link">
    Stack.h
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    栈与递归
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    函数的调用过程
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    循环队列
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    顺换队列初始化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    顺换队列入队
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    循环队列出队
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    循环队列其他操作
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    测试代码
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    链队
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    链队初始化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_45" class="md-nav__link">
    链队入队
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_46" class="md-nav__link">
    链队出队
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_47" class="md-nav__link">
    栈和队列玩具
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_48" class="md-nav__link">
    进制转化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_49" class="md-nav__link">
    括号的匹配
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#10" class="md-nav__link">
    10 以内的计算器
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    3. 字符串，数组，广义表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_50" class="md-nav__link">
    字符串匹配
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bfbrute-force" class="md-nav__link">
    BF算法(Brute Force)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#kmp" class="md-nav__link">
    KMP算法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#next" class="md-nav__link">
    求next数组
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_51" class="md-nav__link">
    字符串匹配玩具
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_52" class="md-nav__link">
    数组
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#generalized-list" class="md-nav__link">
    广义表(Generalized List)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    4. 树、二叉树、森林
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_53" class="md-nav__link">
    定义
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_54" class="md-nav__link">
    树的基本术语
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_55" class="md-nav__link">
    二叉树的定义
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_56" class="md-nav__link">
    二叉树的性质
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_57" class="md-nav__link">
    二叉树定理
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_58" class="md-nav__link">
    完全二叉树性质及定理
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_59" class="md-nav__link">
    链式二叉树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_60" class="md-nav__link">
    存储结构
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_61" class="md-nav__link">
    遍历方式(递归)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_62" class="md-nav__link">
    遍历方式(非递归)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_63" class="md-nav__link">
    先序遍历创建二叉树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_64" class="md-nav__link">
    测试(创建，遍历)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_65" class="md-nav__link">
    层次遍历算法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_66" class="md-nav__link">
    复制二叉树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_67" class="md-nav__link">
    求深度和节点数
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_68" class="md-nav__link">
    销毁二叉树(递归和非递归)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_69" class="md-nav__link">
    头文件
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#threaded-binary-tree" class="md-nav__link">
    线索二叉树 Threaded Binary Tree(了解即可)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_70" class="md-nav__link">
    数据类型定义
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_71" class="md-nav__link">
    树和森林
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_72" class="md-nav__link">
    树的存储结构
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    1. 双亲表示法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    2. 孩子链表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3_1" class="md-nav__link">
    3. 孩子兄弟表示法(树转化二叉树的基础)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_73" class="md-nav__link">
    树与二叉树之间相互转换
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_74" class="md-nav__link">
    树转二叉树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_75" class="md-nav__link">
    二叉树转树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_76" class="md-nav__link">
    森林与二叉树之间的转化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_77" class="md-nav__link">
    森林转二叉树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_78" class="md-nav__link">
    二叉树转森林
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_79" class="md-nav__link">
    树和森林的遍历
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_80" class="md-nav__link">
    树的遍历
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_81" class="md-nav__link">
    森林的遍历
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_82" class="md-nav__link">
    哈夫曼树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_83" class="md-nav__link">
    术语
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_84" class="md-nav__link">
    最优二叉树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_85" class="md-nav__link">
    构造哈夫曼树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#step" class="md-nav__link">
    step和定理
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_86" class="md-nav__link">
    代码实现
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_87" class="md-nav__link">
    哈夫曼编码
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_88" class="md-nav__link">
    代码实现
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_89" class="md-nav__link">
    整体头文件
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-graph" class="md-nav__link">
    5. 图(Graph)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_90" class="md-nav__link">
    图的定义和术语
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_91" class="md-nav__link">
    完全图
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sparse-graphdense-gaph" class="md-nav__link">
    稀疏图(Sparse Graph)和稠密图(Dense Gaph)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#degree" class="md-nav__link">
    顶点的度(degree)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#path" class="md-nav__link">
    路径(path)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connected-graph" class="md-nav__link">
    连通图(Connected Graph)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connected-component" class="md-nav__link">
    连通子图和连通分量(Connected Component)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#spanning-tree" class="md-nav__link">
    极小连通子图和生成树(Spanning Tree)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_92" class="md-nav__link">
    图的存储结构
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adjacency-matrix" class="md-nav__link">
    邻接矩阵(Adjacency Matrix)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_93" class="md-nav__link">
    无向图
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_94" class="md-nav__link">
    有向图
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#weighted-graph" class="md-nav__link">
    带权图(网) weighted Graph
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_95" class="md-nav__link">
    代码实现
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_96" class="md-nav__link">
    无向无权图
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_97" class="md-nav__link">
    无向带权图
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_98" class="md-nav__link">
    有向带权图
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_99" class="md-nav__link">
    有向无权图
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adjacency-list" class="md-nav__link">
    邻接表(Adjacency List)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_100" class="md-nav__link">
    代码实现
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_101" class="md-nav__link">
    无向无权图
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_102" class="md-nav__link">
    邻接表和邻接矩阵的比较
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_103" class="md-nav__link">
    十字链表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_104" class="md-nav__link">
    邻接多重链表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_105" class="md-nav__link">
    图的遍历
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#depth-first-search" class="md-nav__link">
    深度优先 (Depth First Search)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_106" class="md-nav__link">
    遍历矩阵
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_107" class="md-nav__link">
    遍历邻接表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#breadth-first-search" class="md-nav__link">
    广度优先 (Breadth First Search)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_108" class="md-nav__link">
    遍历矩阵
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_109" class="md-nav__link">
    遍历邻接表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_110" class="md-nav__link">
    算法效率
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#spanning-tree_1" class="md-nav__link">
    最小生成树 Spanning Tree
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#prim" class="md-nav__link">
    Prim 算法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_111" class="md-nav__link">
    代码实现
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_112" class="md-nav__link">
    邻接矩阵
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_113" class="md-nav__link">
    邻接表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#kruskal" class="md-nav__link">
    Kruskal 算法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_114" class="md-nav__link">
    代码实现
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_115" class="md-nav__link">
    邻接矩阵
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_116" class="md-nav__link">
    邻接表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_117" class="md-nav__link">
    最短路径
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dijkstra" class="md-nav__link">
    Dijkstra 算法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_118" class="md-nav__link">
    代码实现
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_119" class="md-nav__link">
    邻接矩阵
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#floyd" class="md-nav__link">
    Floyd算法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_120" class="md-nav__link">
    代码实现
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_121" class="md-nav__link">
    邻接矩阵
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#directed-acycline-graph" class="md-nav__link">
    有向无环图(Directed Acycline Graph)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#aocaoe" class="md-nav__link">
    AOC和AOE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_122" class="md-nav__link">
    拓扑排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_123" class="md-nav__link">
    代码实现
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_124" class="md-nav__link">
    邻接表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_125" class="md-nav__link">
    关键路径
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_126" class="md-nav__link">
    代码实现
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_127" class="md-nav__link">
    邻接表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_128" class="md-nav__link">
    图的头文件
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#define_graphh" class="md-nav__link">
    define_Graph.h
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#amgraphh" class="md-nav__link">
    AMGraph.h
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#algraphh" class="md-nav__link">
    ALGraph.h
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_129" class="md-nav__link">
    数据结构
  </a>
  
    <nav class="md-nav" aria-label="数据结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_130" class="md-nav__link">
    宏定义
  </a>
  
    <nav class="md-nav" aria-label="宏定义">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#defineh" class="md-nav__link">
    在本笔记中用到的宏定义，头文件为define.h
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_2" class="md-nav__link">
    1. 线性表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sequence-list_1" class="md-nav__link">
    顺序表(Sequence List)
  </a>
  
    <nav class="md-nav" aria-label="顺序表(Sequence List)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_131" class="md-nav__link">
    特点：逻辑上相邻的数据元素，其物理次序也是相邻的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_132" class="md-nav__link">
    线性表中第 个数据元素的存储位置 和第个元素满足下列关系
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_133" class="md-nav__link">
    代表每个元素所占的存储单元
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_134" class="md-nav__link">
    循序表的存储结构：
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_135" class="md-nav__link">
    初始化
  </a>
  
    <nav class="md-nav" aria-label="初始化">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_136" class="md-nav__link">
    获取元素
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_137" class="md-nav__link">
    查找元素
  </a>
  
    <nav class="md-nav" aria-label="查找元素">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#aslaverage-search-length" class="md-nav__link">
    平均查找长度ASL(Average Search Length)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_138" class="md-nav__link">
    为查找第个元素成功的概率
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_139" class="md-nav__link">
    为查找第个元素需要比较的次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_140" class="md-nav__link">
    可知
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_141" class="md-nav__link">
    为第个元素在表中位置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_142" class="md-nav__link">
    因此可知 的时间复杂度为
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_143" class="md-nav__link">
    插入
  </a>
  
    <nav class="md-nav" aria-label="插入">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_144" class="md-nav__link">
    表示插入元素所需要移动元素次数的期望值平均次数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_145" class="md-nav__link">
    假设在各个位置上插入元素的概率相等
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_146" class="md-nav__link">
    因此
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_147" class="md-nav__link">
    删除
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_148" class="md-nav__link">
    销毁，清空，检查为空
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_149" class="md-nav__link">
    顺序表的头文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#single-linked-list_1" class="md-nav__link">
    单链表(Single Linked List)
  </a>
  
    <nav class="md-nav" aria-label="单链表(Single Linked List)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#n" class="md-nav__link">
    单链表由头节点(不存放数据只存放下个节点的地址)和n个节点组成，
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_150" class="md-nav__link">
    每个节点分为两个域：数据域和指针域(存放下个节点的地址)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nnull" class="md-nav__link">
    第n个节点的指针域为NULL
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_151" class="md-nav__link">
    如下图所示
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_152" class="md-nav__link">
    初始化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_153" class="md-nav__link">
    创建链表(头插法)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_154" class="md-nav__link">
    创建链表(尾插法)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_155" class="md-nav__link">
    获取元素
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_156" class="md-nav__link">
    查找元素
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_157" class="md-nav__link">
    插入元素
  </a>
  
    <nav class="md-nav" aria-label="插入元素">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_158" class="md-nav__link">
    想在 ， 之间插入 ,需要先知道 节点的地址
  </a>
  
    <nav class="md-nav" aria-label="想在 ， 之间插入 ,需要先知道 节点的地址">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_159" class="md-nav__link">
    如图所示，如果想要在位置 插入节点，则需要知道位置 节点的位置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#getelem" class="md-nav__link">
    注意因为插入操作和GetElem操作不同
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0-pl" class="md-nav__link">
    要从 0 开始，p要从L开始
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-l-1" class="md-nav__link">
    如果从 1 和L开始的话，无法再位置 1 插入元素
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_160" class="md-nav__link">
    删除元素
  </a>
  
    <nav class="md-nav" aria-label="删除元素">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_161" class="md-nav__link">
    想要删除 ，则必须先知道 的地址
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#getelem_1" class="md-nav__link">
    注意因为插入操作和GetElem操作不同
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0-pl_1" class="md-nav__link">
    要从 0 开始，p要从L开始
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-l-1_1" class="md-nav__link">
    如果从 1 和L开始的话，无法再位置 1 插入元素
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_162" class="md-nav__link">
    总结插入和删除操作算法的不同
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_163" class="md-nav__link">
    销毁链表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_164" class="md-nav__link">
    单链表头文件
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#circular-linked-list_1" class="md-nav__link">
    循环链表(Circular Linked List)
  </a>
  
    <nav class="md-nav" aria-label="循环链表(Circular Linked List)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_165" class="md-nav__link">
    循环链表的特点：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_166" class="md-nav__link">
    最后一个节点的指针域指向头节点，整个表链形成一个环
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_167" class="md-nav__link">
    由此，从表中任意节点出发，可以找到其他节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#next_1" class="md-nav__link">
    和单链表很像，区别就是最后一个节点的next域指向头节点
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#double-linked-list_1" class="md-nav__link">
    双向链表(Double Linked List)
  </a>
  
    <nav class="md-nav" aria-label="双向链表(Double Linked List)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_168" class="md-nav__link">
    有两个指针域，一个指向直接前驱，另一个指向直接后继
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_169" class="md-nav__link">
    数据类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_170" class="md-nav__link">
    初始化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_171" class="md-nav__link">
    创建双向链表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_172" class="md-nav__link">
    插入和删除
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_173" class="md-nav__link">
    线性表玩具
  </a>
  
    <nav class="md-nav" aria-label="线性表玩具">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_174" class="md-nav__link">
    线性表合并
  </a>
  
    <nav class="md-nav" aria-label="线性表合并">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_175" class="md-nav__link">
    已知两个集合
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_176" class="md-nav__link">
    求出合并后集合
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_177" class="md-nav__link">
    有序表合并(并归排序的基础)
  </a>
  
    <nav class="md-nav" aria-label="有序表合并(并归排序的基础)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_178" class="md-nav__link">
    合并成新集合
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_179" class="md-nav__link">
    有序链表合并
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#and_1" class="md-nav__link">
    多项式创建 and 多项式相加
  </a>
  
    <nav class="md-nav" aria-label="多项式创建 and 多项式相加">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_180" class="md-nav__link">
    创建一个多项式，并按照指数的高低排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_181" class="md-nav__link">
    多项式结构体
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_182" class="md-nav__link">
    多项式创建
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polynomial-q-polynimial-pre" class="md-nav__link">
    核心变量为 Polynomial q; Polynimial pre;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#whileq-q-exponent-pnew-exponent" class="md-nav__link">
    核心语句为 while(q &amp;&amp; q-&gt;exponent &lt; pnew-&gt;exponent)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_183" class="md-nav__link">
    主程序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-stack-and-queue_1" class="md-nav__link">
    2. 栈和队列(Stack and Queue)
  </a>
  
    <nav class="md-nav" aria-label="2. 栈和队列(Stack and Queue)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sequence-stack_1" class="md-nav__link">
    顺序栈(Sequence Stack)
  </a>
  
    <nav class="md-nav" aria-label="顺序栈(Sequence Stack)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#topbottom" class="md-nav__link">
    栈是限定仅在表尾进行插入或删除操作的线性表，表末端为栈顶(Top)，表头称为栈顶(Bottom),不含元
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_184" class="md-nav__link">
    素称为空战
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_185" class="md-nav__link">
    (用顺序表存储的栈更常见)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#last-in-first-out-lifo" class="md-nav__link">
    因此栈又称为后进先出(Last in First out, LIFO)的线性表，如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_186" class="md-nav__link">
    栈的类型定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_187" class="md-nav__link">
    栈的初始化
  </a>
  
    <nav class="md-nav" aria-label="栈的初始化">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#top" class="md-nav__link">
    观察上图，发现top指向内存空间不存放元素
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#push_2" class="md-nav__link">
    入栈(Push)
  </a>
  
    <nav class="md-nav" aria-label="入栈(Push)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#topbasetop" class="md-nav__link">
    因为top指向的内存不存放空间，当为base分配的空间存满元素时，top = 分配空间的最后一个元素的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1top-base-stacksize" class="md-nav__link">
    地址+1，此时表示栈满，即top-base = stacksize
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pop_2" class="md-nav__link">
    出栈(Pop)
  </a>
  
    <nav class="md-nav" aria-label="出栈(Pop)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#base-top" class="md-nav__link">
    当 base == top 时，表示栈空
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_188" class="md-nav__link">
    栈的其他操作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_189" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linked-stack_1" class="md-nav__link">
    链栈(Linked Stack)
  </a>
  
    <nav class="md-nav" aria-label="链栈(Linked Stack)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pushpoptop" class="md-nav__link">
    由于栈的主要操作是对栈顶进行Push和Pop，所以选用top作为链表的头节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_190" class="md-nav__link">
    链栈的类型定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_191" class="md-nav__link">
    链栈初始化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#push_3" class="md-nav__link">
    链栈Push
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pop_3" class="md-nav__link">
    链栈Pop
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_192" class="md-nav__link">
    链栈的其他操作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_193" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stackh_1" class="md-nav__link">
    Stack.h
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_194" class="md-nav__link">
    栈与递归
  </a>
  
    <nav class="md-nav" aria-label="栈与递归">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_195" class="md-nav__link">
    函数的调用过程
  </a>
  
    <nav class="md-nav" aria-label="函数的调用过程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_196" class="md-nav__link">
    调用前系统完成：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_3" class="md-nav__link">
    1. 将实参，返回地址(下行代码地址)等传递给被调用函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_1" class="md-nav__link">
    2. 为被调用函数的局部变量分配空间
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_2" class="md-nav__link">
    3. 将控制转移到被调用函数的入口
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_197" class="md-nav__link">
    调用后，系统完成：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_4" class="md-nav__link">
    1. 保存被调用函数的计算结果(返回值)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_2" class="md-nav__link">
    2. 释放被调用函数的数据区
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_3" class="md-nav__link">
    3. 依照被调用函数保存的返回地址，将控制转移到调用函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_198" class="md-nav__link">
    递归调用函数时，如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_199" class="md-nav__link">
    按照调用顺序依此把各个函数入栈
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#returnfislo" class="md-nav__link">
    当栈顶函数满足return条件时，依此出栈(按照FISLO原则)，并且返回值从上向下传递
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fact4" class="md-nav__link">
    直到主程序调用的fact(4)出栈后，递归完成
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_200" class="md-nav__link">
    循环队列
  </a>
  
    <nav class="md-nav" aria-label="循环队列">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_201" class="md-nav__link">
    定义：只能在表的一端进行插入运算，在表的另一端进行删除运算的 线性表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#first-in-firs-out" class="md-nav__link">
    先进先出(First in Firs out)原则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_202" class="md-nav__link">
    数据类型定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drear" class="md-nav__link">
    如上图，(d)虽然数组中的空间没有满，但是rear却不能继续增加，假溢出
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#base" class="md-nav__link">
    解决方法：把base数组想象成一个环形的循环队列如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#front-rere-front-rere1-qmaxsize" class="md-nav__link">
    此时如果 front == rere表示 队空 ，而 front == (rere+1) % QMAXSIZE时表示 队满
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_203" class="md-nav__link">
    顺换队列初始化
  </a>
  
    <nav class="md-nav" aria-label="顺换队列初始化">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#front-rere-0" class="md-nav__link">
    把 front 和 rere 初始化为 0
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_204" class="md-nav__link">
    顺换队列入队
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_205" class="md-nav__link">
    循环队列出队
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_206" class="md-nav__link">
    循环队列其他操作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_207" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_208" class="md-nav__link">
    链队
  </a>
  
    <nav class="md-nav" aria-label="链队">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#front-rere" class="md-nav__link">
    链队结构类似于链表，不同于链表的头指针，用两个指针域 front rere 来表示队列，如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_209" class="md-nav__link">
    数据类型定义：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_210" class="md-nav__link">
    链队初始化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_211" class="md-nav__link">
    链队入队
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_212" class="md-nav__link">
    链队出队
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_213" class="md-nav__link">
    栈和队列玩具
  </a>
  
    <nav class="md-nav" aria-label="栈和队列玩具">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_214" class="md-nav__link">
    进制转化
  </a>
  
    <nav class="md-nav" aria-label="进制转化">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#nn-8" class="md-nav__link">
    一个进转换函数，有一个参数n(十进制)，要求输出n的 8 进制
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_215" class="md-nav__link">
    括号的匹配
  </a>
  
    <nav class="md-nav" aria-label="括号的匹配">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_216" class="md-nav__link">
    输入括号()[]，判断括号是否匹配成功，#字符表示输入结束
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_217" class="md-nav__link">
    例: ([()])成功 [(())]] 失败
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_5" class="md-nav__link">
    写法 1 ：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_3" class="md-nav__link">
    写法 2 ：
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#10_1" class="md-nav__link">
    10 以内的计算器
  </a>
  
    <nav class="md-nav" aria-label="10 以内的计算器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#10_2" class="md-nav__link">
    写出一个只有加减乘除的计算器，要求每一步计算结果小于 10
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_218" class="md-nav__link">
    运算符顺序要求如下(#代表结束标志，且#运算级最小)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_219" class="md-nav__link">
    测试代码:
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_4" class="md-nav__link">
    3. 字符串，数组，广义表
  </a>
  
    <nav class="md-nav" aria-label="3. 字符串，数组，广义表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_220" class="md-nav__link">
    字符串匹配
  </a>
  
    <nav class="md-nav" aria-label="字符串匹配">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_221" class="md-nav__link">
    字符串的存储结构可以分为两类：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_222" class="md-nav__link">
    顺序存储结构：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_223" class="md-nav__link">
    链式存储结构：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_224" class="md-nav__link">
    本笔记只记录顺序存储结构的字符串
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_225" class="md-nav__link">
    输入字符串函数和初始化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bfbrute-force_1" class="md-nav__link">
    BF算法(Brute Force)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bf" class="md-nav__link">
    BF算法效率分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_226" class="md-nav__link">
    令主串长度为 子串长度为 ，若从主串的第个位置开始与模式串匹配成功
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_227" class="md-nav__link">
    则在前 趟匹配中字符总共比较了 次
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_228" class="md-nav__link">
    若第趟匹配成功，则比较次数为 ，总比较次数为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_229" class="md-nav__link">
    即
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_230" class="md-nav__link">
    最坏情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_231" class="md-nav__link">
    假设从主串对的第个位置开始与模式串匹配成功，则在前 趟中总共比较了 次
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_232" class="md-nav__link">
    若第趟匹配成功，则第趟需要 次匹配，总比较次数为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kmp_1" class="md-nav__link">
    KMP算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_233" class="md-nav__link">
    令字符串 ，和模式串
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_234" class="md-nav__link">
    匹配到 和 时失匹 则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_235" class="md-nav__link">
    下标由来： 为失匹之前成功匹配的子串长度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_236" class="md-nav__link">
    指向 中失配字符，则有
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_237" class="md-nav__link">
    下标由来：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_238" class="md-nav__link">
    由 可知，
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_239" class="md-nav__link">
    由 可知，如果 和 失匹，无需从 开始和 比较，只需要把 滑动到 的位置比较即可
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_240" class="md-nav__link">
    令 表示在匹配中 失匹时，让 与 比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_241" class="md-nav__link">
    可得
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_242" class="md-nav__link">
    ，因为当 失匹时字符串来到 位置空串，有 空串
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_243" class="md-nav__link">
    且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_244" class="md-nav__link">
    需要从 开始重新比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#next_2" class="md-nav__link">
    求next数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_245" class="md-nav__link">
    求 数组的过程实际上是 的过程，即如果存在，那么 必然存在
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_246" class="md-nav__link">
    也是模式串的字串匹配模式串的过程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_247" class="md-nav__link">
    设 即有
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_248" class="md-nav__link">
    第一种情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_249" class="md-nav__link">
    此时则有
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_250" class="md-nav__link">
    那么则有
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_251" class="md-nav__link">
    第二种情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_252" class="md-nav__link">
    说明在 处失匹，则回溯到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_253" class="md-nav__link">
    如果 如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_254" class="md-nav__link">
    那么
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_255" class="md-nav__link">
    如果
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_256" class="md-nav__link">
    那么一直回溯 若出现 则同上，若未出现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#next_3" class="md-nav__link">
    未优化前，求next数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_257" class="md-nav__link">
    考虑如下问题，如果回溯的 也等于 会出现什么问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_258" class="md-nav__link">
    会出现无意义比较，解决办法让 也进行回溯
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_259" class="md-nav__link">
    优化后
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kmp_2" class="md-nav__link">
    KMP算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_260" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_261" class="md-nav__link">
    字符串匹配玩具
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_262" class="md-nav__link">
    输入一个病毒序列长度为 ，从文件中读取病人样本，确认病人是否被感染
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_263" class="md-nav__link">
    注意 病毒序列是环状的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_264" class="md-nav__link">
    比如病毒序列为 那么 都属于病毒
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_265" class="md-nav__link">
    思路 利用一个数组存储病毒序列，并把该序列扩大到 长度，依此比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_266" class="md-nav__link">
    实现代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_267" class="md-nav__link">
    数组
  </a>
  
    <nav class="md-nav" aria-label="数组">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_268" class="md-nav__link">
    声明格式 数据类型变量名称行数 列数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_269" class="md-nav__link">
    如
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_270" class="md-nav__link">
    一个二维数组也可以被定义成一维数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_271" class="md-nav__link">
    例如:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_272" class="md-nav__link">
    三维数组 每个元素都是二维数组，且二维数组中的每个元素又都是一维数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_273" class="md-nav__link">
    维数组 每个元素都是 维数组，且 维数组的每个元素都是 维数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_274" class="md-nav__link">
    维数组中的每个元素都是一维数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_275" class="md-nav__link">
    若有三维数组 各元素维
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_276" class="md-nav__link">
    则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_277" class="md-nav__link">
    可以抽象成下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_278" class="md-nav__link">
    若有 维数组，各个维度的元素个数为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_279" class="md-nav__link">
    则
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generalized-list_1" class="md-nav__link">
    广义表(Generalized List)
  </a>
  
    <nav class="md-nav" aria-label="广义表(Generalized List)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_280" class="md-nav__link">
    广义表通常记作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_281" class="md-nav__link">
    为表名通常用大写字母表示
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_282" class="md-nav__link">
    为长度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_283" class="md-nav__link">
    为表的元素
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_284" class="md-nav__link">
    表头 若 非空 ，则第一元素 就是表头
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_285" class="md-nav__link">
    表尾 除表头之外的其他元素组成的表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_286" class="md-nav__link">
    注意 表尾不是一个元素，而是一个子表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_287" class="md-nav__link">
    例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_288" class="md-nav__link">
    空表，
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_289" class="md-nav__link">
    ， 和 都是 但并不是同一
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_290" class="md-nav__link">
    广义表的性质:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_291" class="md-nav__link">
    广义表中的元素有相对次序 一个直接前驱和一个直接后继
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_292" class="md-nav__link">
    广义表的长度定义为最外层所包含的元素个数 广义表的深度定义为该广义表展开后所含括号的层数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_293" class="md-nav__link">
    如 深度 ， 深度 ， 深度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_294" class="md-nav__link">
    注意 原子的深度为 ，空表的深度为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_295" class="md-nav__link">
    在广义表中可以为其他广义表共享，如上述广义表 就共享
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_296" class="md-nav__link">
    广义表可以是一个递归的表，如上述 广义表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_297" class="md-nav__link">
    注意 递归表的长度是有限的，但是深度是
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_298" class="md-nav__link">
    广义表的基本运算
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4_1" class="md-nav__link">
    4. 树、二叉树、森林
  </a>
  
    <nav class="md-nav" aria-label="4. 树、二叉树、森林">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_299" class="md-nav__link">
    定义
  </a>
  
    <nav class="md-nav" aria-label="定义">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_300" class="md-nav__link">
    树是 个节点的有限集合
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_301" class="md-nav__link">
    当 时为空树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_302" class="md-nav__link">
    有且仅有一个称之为根的节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_303" class="md-nav__link">
    令一颗树为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_304" class="md-nav__link">
    除根节点外，可分为 个互不相交的有限集 ，其中一个集合又是一棵树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_305" class="md-nav__link">
    称其为 的子树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_306" class="md-nav__link">
    如下图
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_307" class="md-nav__link">
    树的基本术语
  </a>
  
    <nav class="md-nav" aria-label="树的基本术语">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_308" class="md-nav__link">
    节点的度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_309" class="md-nav__link">
    节点拥有的子树个数成为节点的度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_310" class="md-nav__link">
    如上图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_311" class="md-nav__link">
    树的度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_312" class="md-nav__link">
    树的度是树内各节点度的最大值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_313" class="md-nav__link">
    上图的度为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_314" class="md-nav__link">
    层次
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_315" class="md-nav__link">
    节点的层次从根开始定义，根为第一层，根的孩子为第二层
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_316" class="md-nav__link">
    树中任意节点的层次 它的双亲层次
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_317" class="md-nav__link">
    高度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_318" class="md-nav__link">
    树中节点的最大层次成为树的高度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_319" class="md-nav__link">
    如上图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_320" class="md-nav__link">
    森林
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_321" class="md-nav__link">
    是 颗互不相交的树的集合
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_322" class="md-nav__link">
    对任意一棵树而言，其子树组成森林
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_323" class="md-nav__link">
    二叉树的定义
  </a>
  
    <nav class="md-nav" aria-label="二叉树的定义">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_324" class="md-nav__link">
    是 个节点组成的集合， 时为空树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_325" class="md-nav__link">
    对于非空树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_326" class="md-nav__link">
    有且仅有一个根节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_327" class="md-nav__link">
    除根结点外，有互不相交的 两棵子树可以为空树，分别称其为 的左右子树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_328" class="md-nav__link">
    二叉树的性质
  </a>
  
    <nav class="md-nav" aria-label="二叉树的性质">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_329" class="md-nav__link">
    每个节点最多有两棵子树即
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_330" class="md-nav__link">
    子树有左右之分，不可颠倒
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_331" class="md-nav__link">
    二叉树定理
  </a>
  
    <nav class="md-nav" aria-label="二叉树定理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_332" class="md-nav__link">
    定理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_333" class="md-nav__link">
    在二叉树的第层上，最多有 个节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_334" class="md-nav__link">
    定理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_335" class="md-nav__link">
    深度为 的二叉树，最多有 个节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_336" class="md-nav__link">
    定理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_337" class="md-nav__link">
    令一颗二叉树 有 个节点，其中 分别为 的节点个数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_338" class="md-nav__link">
    即有
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_339" class="md-nav__link">
    可知 的根无双亲节点，而其他的节点都有双亲 令这些节点的个数为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_340" class="md-nav__link">
    即
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_341" class="md-nav__link">
    由 可知
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_342" class="md-nav__link">
    所以
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_343" class="md-nav__link">
    完全二叉树性质及定理
  </a>
  
    <nav class="md-nav" aria-label="完全二叉树性质及定理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_344" class="md-nav__link">
    定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_345" class="md-nav__link">
    深度为 的，由 个节点的二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_346" class="md-nav__link">
    当且仅当其每一个节点都与深度为 的满二叉树中编号从 到 的节点一一对应时
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_347" class="md-nav__link">
    称其为完全二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_348" class="md-nav__link">
    如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_349" class="md-nav__link">
    特点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_350" class="md-nav__link">
    对完全二叉树的任意节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_351" class="md-nav__link">
    若其右分支的子孙最大层次为 ，则其左分支的子孙最大层次为 或
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_352" class="md-nav__link">
    定理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_353" class="md-nav__link">
    若一个完全二叉树有 个节点，深度为 ，则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_354" class="md-nav__link">
    根据完全二叉树性质可知
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_355" class="md-nav__link">
    对其 化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_356" class="md-nav__link">
    因为 所以
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_357" class="md-nav__link">
    定理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_358" class="md-nav__link">
    一颗完全二叉树 ，有 个节点，若按照节点层次从左到右给其编号，则对于任意节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_359" class="md-nav__link">
    无双亲
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_360" class="md-nav__link">
    的双亲为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_361" class="md-nav__link">
    则无左孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_362" class="md-nav__link">
    为的左孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_363" class="md-nav__link">
    则无右孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_364" class="md-nav__link">
    则 为的右孩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_365" class="md-nav__link">
    如下图
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_366" class="md-nav__link">
    链式二叉树
  </a>
  
    <nav class="md-nav" aria-label="链式二叉树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_367" class="md-nav__link">
    存储结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_368" class="md-nav__link">
    遍历方式(递归)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_369" class="md-nav__link">
    遍历方式(非递归)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_370" class="md-nav__link">
    先序遍历创建二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_371" class="md-nav__link">
    测试(创建，遍历)
  </a>
  
    <nav class="md-nav" aria-label="测试(创建，遍历)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_372" class="md-nav__link">
    输入如下一棵树，按照中序遍历方式输出
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_373" class="md-nav__link">
    层次遍历算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_374" class="md-nav__link">
    复制二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_375" class="md-nav__link">
    求深度和节点数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_376" class="md-nav__link">
    销毁二叉树(递归和非递归)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_377" class="md-nav__link">
    头文件
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#threaded-binary-tree_1" class="md-nav__link">
    线索二叉树 Threaded Binary Tree(了解即可)
  </a>
  
    <nav class="md-nav" aria-label="线索二叉树 Threaded Binary Tree(了解即可)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_378" class="md-nav__link">
    问题，如何寻找特点遍历顺序中二叉树节点的前驱和后继
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_379" class="md-nav__link">
    办法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_380" class="md-nav__link">
    通过遍历，浪费时间
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_381" class="md-nav__link">
    给结构体内增加前驱和后继指针，增加存储负担
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_382" class="md-nav__link">
    利用二叉链表中的空指针域
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_383" class="md-nav__link">
    定理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_384" class="md-nav__link">
    如果一个二叉树有 个节点，那么空指针域为 个
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_385" class="md-nav__link">
    总指针域为 个，除去根节点，一个有 个节点，即需要 个指针域
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_386" class="md-nav__link">
    线索二叉树的定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_387" class="md-nav__link">
    如果某个节点的左孩子为空，那么利用左孩子指针域，把它指向它的前驱
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_388" class="md-nav__link">
    如果右孩子为空，则指向它后继
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_389" class="md-nav__link">
    这种改变指向的指针称为线索
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_390" class="md-nav__link">
    数据类型定义
  </a>
  
    <nav class="md-nav" aria-label="数据类型定义">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_391" class="md-nav__link">
    左孩子为空
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_392" class="md-nav__link">
    左孩子指向前驱
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_393" class="md-nav__link">
    右孩子为空
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_394" class="md-nav__link">
    右孩子指向前驱
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_395" class="md-nav__link">
    如果按照遍历的顺序，那么序列中第一个元素必然没有前驱
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_396" class="md-nav__link">
    把该节点的左孩子指向一个头指针
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_397" class="md-nav__link">
    该头指针的左孩子指向根节点，右孩子指向序列最后一个节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_398" class="md-nav__link">
    一个中序遍历为 的线索二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_399" class="md-nav__link">
    如下图
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_400" class="md-nav__link">
    树和森林
  </a>
  
    <nav class="md-nav" aria-label="树和森林">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_401" class="md-nav__link">
    树的存储结构
  </a>
  
    <nav class="md-nav" aria-label="树的存储结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_6" class="md-nav__link">
    1. 双亲表示法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_4" class="md-nav__link">
    2. 孩子链表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_5" class="md-nav__link">
    3. 孩子兄弟表示法(树转化二叉树的基础)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_402" class="md-nav__link">
    树与二叉树之间相互转换
  </a>
  
    <nav class="md-nav" aria-label="树与二叉树之间相互转换">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_403" class="md-nav__link">
    树转二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_404" class="md-nav__link">
    在兄弟之间连线
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_405" class="md-nav__link">
    对于任意一个节点 ，除了其左孩子外，去除掉所有孩子与其的关系
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_406" class="md-nav__link">
    以根节点的左孩子为中心，顺时针旋转 ，再与根节点相连
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_407" class="md-nav__link">
    二叉树转树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_408" class="md-nav__link">
    若 节点是双亲节点的左孩子，则将 的右孩子，右孩子的右孩子 连接到 的双亲结点上
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_409" class="md-nav__link">
    抹掉所有双亲结点和右孩子之间关系
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_410" class="md-nav__link">
    整理成树状
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_411" class="md-nav__link">
    森林与二叉树之间的转化
  </a>
  
    <nav class="md-nav" aria-label="森林与二叉树之间的转化">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_412" class="md-nav__link">
    森林转二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_413" class="md-nav__link">
    将森林中的各棵树转化为二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_414" class="md-nav__link">
    链接这些二叉树的根节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_415" class="md-nav__link">
    第一棵树的根为二叉树的根，进行调整
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_416" class="md-nav__link">
    二叉树转森林
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_417" class="md-nav__link">
    若是二叉树的根，则取消所有 的右孩子，右孩子的右孩子 之间的关系
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_418" class="md-nav__link">
    此时有 颗孤立的二叉树，把这些二叉树转成树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_419" class="md-nav__link">
    树和森林的遍历
  </a>
  
    <nav class="md-nav" aria-label="树和森林的遍历">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_420" class="md-nav__link">
    树的遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_421" class="md-nav__link">
    先根遍历 若树不为空，则先访问根节点，然后再依次先根遍历遍历各个子树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_422" class="md-nav__link">
    后根遍历 若树不为空，先依次后根遍历各个子树，再访问根节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_423" class="md-nav__link">
    层次遍历 自上到下，从左到右
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#s" class="md-nav__link">
    s
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_424" class="md-nav__link">
    先根遍历为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_425" class="md-nav__link">
    后根遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_426" class="md-nav__link">
    森林的遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_427" class="md-nav__link">
    假设有森林 ，有 棵互不相交的树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_428" class="md-nav__link">
    将森林看成三部分
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_429" class="md-nav__link">
    森林中第一棵树的根节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_430" class="md-nav__link">
    森林中第一棵树的所有子树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_431" class="md-nav__link">
    森林中 到 颗树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_432" class="md-nav__link">
    先序遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_433" class="md-nav__link">
    访问 的根节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_434" class="md-nav__link">
    先序遍历 的所有子树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_435" class="md-nav__link">
    先序遍历 到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_436" class="md-nav__link">
    即从左到右依次对 进行先根遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_437" class="md-nav__link">
    中序遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_438" class="md-nav__link">
    中序遍历 的所有子树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_439" class="md-nav__link">
    访问 的根节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_440" class="md-nav__link">
    中序遍历 到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_441" class="md-nav__link">
    即从左到右依次对 进行后根遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_442" class="md-nav__link">
    对上图进行先序遍历和中序遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_443" class="md-nav__link">
    先序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_444" class="md-nav__link">
    中序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_445" class="md-nav__link">
    哈夫曼树
  </a>
  
    <nav class="md-nav" aria-label="哈夫曼树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_446" class="md-nav__link">
    术语
  </a>
  
    <nav class="md-nav" aria-label="术语">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_447" class="md-nav__link">
    路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_448" class="md-nav__link">
    从树中一个节点到另一个节点之间的分支，组成两个节点间的路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_449" class="md-nav__link">
    节点的路径长度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_450" class="md-nav__link">
    两节点间路径上的分支数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_451" class="md-nav__link">
    树的路径长度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_452" class="md-nav__link">
    从树根到每一个节点的路径长度之和，记作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_453" class="md-nav__link">
    节点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_454" class="md-nav__link">
    权
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_455" class="md-nav__link">
    将树中节点赋给一个含有某种意义的值，这个值叫
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_456" class="md-nav__link">
    结点的带权路径长度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_457" class="md-nav__link">
    从根节点到该节点之间的路径长度与该节点的乘积，即
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_458" class="md-nav__link">
    树的带权路径长度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_459" class="md-nav__link">
    树中所有叶子节点的带权路径长度之和
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_460" class="md-nav__link">
    如下图
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_461" class="md-nav__link">
    最优二叉树
  </a>
  
    <nav class="md-nav" aria-label="最优二叉树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_462" class="md-nav__link">
    哈夫曼树，又称最优二叉树，即带权路径 最短的树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_463" class="md-nav__link">
    注意
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_464" class="md-nav__link">
    是 相同的树比较之下
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_465" class="md-nav__link">
    完全二叉树包括满二叉树不一定是哈夫曼树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_466" class="md-nav__link">
    哈夫曼树中权值越大的叶子节点离根节点越近
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_467" class="md-nav__link">
    具有相同带权路径的哈夫曼树，节点位置不唯一
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_468" class="md-nav__link">
    构造哈夫曼树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#step_1" class="md-nav__link">
    step和定理
  </a>
  
    <nav class="md-nav" aria-label="step和定理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_469" class="md-nav__link">
    根据 个给定的权值 构成 个只有根节点的森林 森林里全是根
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_470" class="md-nav__link">
    在 中选取两个权值最小的树 ，构造一颗新的二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_471" class="md-nav__link">
    在 中删除 ，把 加入 中
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_472" class="md-nav__link">
    重复如上步骤，直到 中只有一颗树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_473" class="md-nav__link">
    定理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_474" class="md-nav__link">
    包含 个节点的树，需要经过 次合并才能形成哈夫曼树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_475" class="md-nav__link">
    定理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_476" class="md-nav__link">
    把一颗含有 个节点的树，转化成哈夫曼树，那么这个哈夫曼树一共有 个
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_477" class="md-nav__link">
    定理
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_478" class="md-nav__link">
    代码实现
  </a>
  
    <nav class="md-nav" aria-label="代码实现">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_479" class="md-nav__link">
    数据类型定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_480" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_481" class="md-nav__link">
    哈夫曼编码
  </a>
  
    <nav class="md-nav" aria-label="哈夫曼编码">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_482" class="md-nav__link">
    讨论的背景
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_483" class="md-nav__link">
    在远程通信中传递字符串时，需要转换成二进制的字符串
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_484" class="md-nav__link">
    即，让待传递字符串中出现次数多的字符采用尽可能短的编码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_485" class="md-nav__link">
    这样的话二进制字符串的编码就会缩短
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_486" class="md-nav__link">
    但，由于二进制只有 和 ，所以有可能二进制代码转成字符时，出现二义性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_487" class="md-nav__link">
    所以要设计长度不等的编码，则必须使任一字符的编码都不是另一个字符编码的前缀
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_488" class="md-nav__link">
    如上形式的编码称为 前缀码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_489" class="md-nav__link">
    哈夫曼编码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_490" class="md-nav__link">
    哈夫曼编码是总长最短的前缀码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_491" class="md-nav__link">
    统计字符集中每个字符在电文中出现的平均概率概率越大，编码要求最短
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_492" class="md-nav__link">
    利用哈夫曼树的特点 权值越大的叶子离根越近 将每个字符的概率值最为权值，构造哈夫曼树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_493" class="md-nav__link">
    在哈夫曼树的每个分支上标 和 ，左分支为 ，右分支为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_494" class="md-nav__link">
    为什么哈夫曼编码是最短的前缀码？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_495" class="md-nav__link">
    根据哈夫曼树的特性，原树中的 个节点，在哈夫曼树中变成了叶子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_496" class="md-nav__link">
    叶子节点不会是另一个叶子的双亲或是祖先，所以是前缀码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_497" class="md-nav__link">
    哈夫曼树的性质
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_498" class="md-nav__link">
    性质 哈夫曼编码是前缀码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_499" class="md-nav__link">
    性质 哈夫曼编码是最优前缀码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_500" class="md-nav__link">
    代码实现
  </a>
  
    <nav class="md-nav" aria-label="代码实现">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_501" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_502" class="md-nav__link">
    构建如下哈夫曼编码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#define-nodes-7" class="md-nav__link">
    define NODES 7
  </a>
  
    <nav class="md-nav" aria-label="define NODES 7">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_503" class="md-nav__link">
    整体头文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5-graph_1" class="md-nav__link">
    5. 图(Graph)
  </a>
  
    <nav class="md-nav" aria-label="5. 图(Graph)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_504" class="md-nav__link">
    图的定义和术语
  </a>
  
    <nav class="md-nav" aria-label="图的定义和术语">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_505" class="md-nav__link">
    图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_506" class="md-nav__link">
    顶点的有限非空集合
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_507" class="md-nav__link">
    边的有限集合
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_508" class="md-nav__link">
    图分为有向图 和无向图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_509" class="md-nav__link">
    如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_510" class="md-nav__link">
    完全图
  </a>
  
    <nav class="md-nav" aria-label="完全图">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_511" class="md-nav__link">
    完全图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_512" class="md-nav__link">
    任意两个点都有一条边相连
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_513" class="md-nav__link">
    若有 个顶点的无向完全图，则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_514" class="md-nav__link">
    若有 个顶点的有向完全图，则
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sparse-graphdense-gaph_1" class="md-nav__link">
    稀疏图(Sparse Graph)和稠密图(Dense Gaph)
  </a>
  
    <nav class="md-nav" aria-label="稀疏图(Sparse Graph)和稠密图(Dense Gaph)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_515" class="md-nav__link">
    稠密图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_516" class="md-nav__link">
    稠密图 有较多边的图
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#degree_1" class="md-nav__link">
    顶点的度(degree)
  </a>
  
    <nav class="md-nav" aria-label="顶点的度(degree)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_517" class="md-nav__link">
    与该顶点相关联的边的数量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_518" class="md-nav__link">
    中，顶点的度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_519" class="md-nav__link">
    问题 当 中，仅有一个顶点的 为 ，其余顶点的 ，此时图为什么形状
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_520" class="md-nav__link">
    答 树，有向树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#path_1" class="md-nav__link">
    路径(path)
  </a>
  
    <nav class="md-nav" aria-label="路径(path)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_521" class="md-nav__link">
    路径 接续的边构成的顶点序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_522" class="md-nav__link">
    路径长度 路径上边的数量或权值之和
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_523" class="md-nav__link">
    回路 第一个顶点和最后一个顶点相同的路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_524" class="md-nav__link">
    路径 路径上的顶点均不相同
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_525" class="md-nav__link">
    回路 除路径起点和终点可以相同外，其余顶点均不相同的路径
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#connected-graph_1" class="md-nav__link">
    连通图(Connected Graph)
  </a>
  
    <nav class="md-nav" aria-label="连通图(Connected Graph)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_526" class="md-nav__link">
    若连通图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_527" class="md-nav__link">
    在无向图 中
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_528" class="md-nav__link">
    若对任何两个顶点 ，都存在 路径，则 是连通图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_529" class="md-nav__link">
    弱连通图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_530" class="md-nav__link">
    若把有向图 中所有的边替换成无向边，此时得到的图为 的基图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_531" class="md-nav__link">
    若它的基图为连通图，则 为若连通
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_532" class="md-nav__link">
    强连通
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_533" class="md-nav__link">
    任取有向图 中两个顶点 ，若 和 中间存在路径，则 为强连通
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#connected-component_1" class="md-nav__link">
    连通子图和连通分量(Connected Component)
  </a>
  
    <nav class="md-nav" aria-label="连通子图和连通分量(Connected Component)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_534" class="md-nav__link">
    无向图 的极大连通子图称为 的连通分量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_535" class="md-nav__link">
    极大连通子图 若无向图 的子图 为连通图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_536" class="md-nav__link">
    任取 即
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_537" class="md-nav__link">
    若把 加入到 中，如果 不再连通，则称 为 的极大连通子图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_538" class="md-nav__link">
    如下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_539" class="md-nav__link">
    强连通分量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_540" class="md-nav__link">
    有向图 的极大强连通子图称为 的连通分量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_541" class="md-nav__link">
    若有向图 的子图 为连通图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_542" class="md-nav__link">
    任取 即
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_543" class="md-nav__link">
    若把 加入到 中，如果 不再连通，则称 为 的极大强连通子图
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#spanning-tree_2" class="md-nav__link">
    极小连通子图和生成树(Spanning Tree)
  </a>
  
    <nav class="md-nav" aria-label="极小连通子图和生成树(Spanning Tree)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_544" class="md-nav__link">
    若子图 是 的连通子图，在改子图中删除任意一条边， 不再连通，则称 是 的极小连通子图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_545" class="md-nav__link">
    注意 极小连通子图中不存在 ，极大连通子图可以存在
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_546" class="md-nav__link">
    生成树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_547" class="md-nav__link">
    若无向图 ， 中所有的点构成的极小连通子图就是 的生成树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_548" class="md-nav__link">
    图的存储结构
  </a>
  
    <nav class="md-nav" aria-label="图的存储结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#adjacency-matrix_1" class="md-nav__link">
    邻接矩阵(Adjacency Matrix)
  </a>
  
    <nav class="md-nav" aria-label="邻接矩阵(Adjacency Matrix)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_549" class="md-nav__link">
    若有图 ，有 个顶点，则对应 矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_550" class="md-nav__link">
    注意 无向图的邻接矩阵为对称矩阵，而有向图的邻接矩阵未必
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_551" class="md-nav__link">
    无向图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_552" class="md-nav__link">
    的邻接矩阵为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_553" class="md-nav__link">
    行中 的个数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_554" class="md-nav__link">
    有向图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_555" class="md-nav__link">
    第列 的个数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_556" class="md-nav__link">
    第行 的个数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#weighted-graph_1" class="md-nav__link">
    带权图(网) weighted Graph
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_557" class="md-nav__link">
    若有带权图 ，有 个顶点，则对应 矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_558" class="md-nav__link">
    代码实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_559" class="md-nav__link">
    数据类型定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_560" class="md-nav__link">
    无向无权图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_561" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_562" class="md-nav__link">
    无向带权图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_563" class="md-nav__link">
    有向带权图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_564" class="md-nav__link">
    有向无权图
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adjacency-list_1" class="md-nav__link">
    邻接表(Adjacency List)
  </a>
  
    <nav class="md-nav" aria-label="邻接表(Adjacency List)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_565" class="md-nav__link">
    数据类型定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_566" class="md-nav__link">
    代码实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_567" class="md-nav__link">
    无向无权图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#weight" class="md-nav__link">
    无向有权，有向无权，有向有权图的创建方法和此方法类似，只需改动weight,和新建节点个数即可
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_568" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_569" class="md-nav__link">
    邻接表和邻接矩阵的比较
  </a>
  
    <nav class="md-nav" aria-label="邻接表和邻接矩阵的比较">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_570" class="md-nav__link">
    邻接矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_571" class="md-nav__link">
    优点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_572" class="md-nav__link">
    便于判断顶点间是否有边
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_573" class="md-nav__link">
    便于计算各个顶点的度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_574" class="md-nav__link">
    缺点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_575" class="md-nav__link">
    不便于插入和删除顶点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_576" class="md-nav__link">
    不便于统计边数，需要扫描矩阵才能计算.
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_577" class="md-nav__link">
    空间复杂度较高，但如果 较大时，可以采用上三角或下三角矩阵(因为矩阵是对称的)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_578" class="md-nav__link">
    邻接表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_579" class="md-nav__link">
    优点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_580" class="md-nav__link">
    便于增加和删除顶点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_581" class="md-nav__link">
    便于统计边的数量，按顶点顺序扫描所有边即可。
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_582" class="md-nav__link">
    空间效率高，无向图 ，有向图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_583" class="md-nav__link">
    缺点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_584" class="md-nav__link">
    不便于判断两顶点间是否有边(相对于矩阵的随机取值而言)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_585" class="md-nav__link">
    不便于计算各个顶点的度。
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_586" class="md-nav__link">
    对于无向图， 第个表的节点个数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_587" class="md-nav__link">
    对无向图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_588" class="md-nav__link">
    )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_589" class="md-nav__link">
    ，入度为第个表的节点个数，但是出度却要历遍所有的表
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_590" class="md-nav__link">
    十字链表
  </a>
  
    <nav class="md-nav" aria-label="十字链表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#degree_2" class="md-nav__link">
    十字链表可以解决用邻接链表储存的有向图求顶点degree的问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_591" class="md-nav__link">
    根据上图可知，一条边即是一个顶点的入度，也是另外一个顶点的出度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_592" class="md-nav__link">
    设是 的一条边
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_593" class="md-nav__link">
    当建立边节点 时，使 的 域指向，使 的 指向
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_594" class="md-nav__link">
    当 再次有出度边 时，使 的 域指向 的 所指节点 指向
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_595" class="md-nav__link">
    当 再次有入度边 时，使 的 域指向 的 所指节点 指向
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_596" class="md-nav__link">
    邻接多重链表
  </a>
  
    <nav class="md-nav" aria-label="邻接多重链表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_597" class="md-nav__link">
    用于 解决 用 邻接表 存储的 无向图 每条边都要存储 两遍 的问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_598" class="md-nav__link">
    如上图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_599" class="md-nav__link">
    记录该边是否被搜索过
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_600" class="md-nav__link">
    分别表示边 顶点的下标
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_601" class="md-nav__link">
    分别表示 的下条边节点， 的下条边节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_602" class="md-nav__link">
    令
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_603" class="md-nav__link">
    使 的 指向 的 域， 的 指向 的 域
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_604" class="md-nav__link">
    的 的下标， 的 的下标
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_605" class="md-nav__link">
    使 和 的 指向
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_606" class="md-nav__link">
    遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_607" class="md-nav__link">
    令 的 为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_608" class="md-nav__link">
    打印
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_609" class="md-nav__link">
    图的遍历
  </a>
  
    <nav class="md-nav" aria-label="图的遍历">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_610" class="md-nav__link">
    图中可能存在 ，且图的任何一点都有可能和其他顶点相连
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_611" class="md-nav__link">
    在访问完某个顶点之后，可能会沿着某些边又回到了曾经访问过的顶点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_612" class="md-nav__link">
    解决思路
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_613" class="md-nav__link">
    设置辅助数组 ，用来标记顶点是否被访问过
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_614" class="md-nav__link">
    顶点未被访问过
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_615" class="md-nav__link">
    顶点被访问过
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#depth-first-search_1" class="md-nav__link">
    深度优先 (Depth First Search)
  </a>
  
    <nav class="md-nav" aria-label="深度优先 (Depth First Search)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_616" class="md-nav__link">
    算法描述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_617" class="md-nav__link">
    先访问 ，再访问 的邻接点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_618" class="md-nav__link">
    再访问 的邻接点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_619" class="md-nav__link">
    开始出栈，控制节点再次来到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_620" class="md-nav__link">
    因为 已经被访问过，所以开始访问
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_621" class="md-nav__link">
    全部出栈完，控制再次回到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_622" class="md-nav__link">
    出栈，结束
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_623" class="md-nav__link">
    代码实现下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_624" class="md-nav__link">
    注意上图中的当访问完 之后，并不是直接回到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_625" class="md-nav__link">
    而是退回到 ，需要依次出栈
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_626" class="md-nav__link">
    遍历矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_627" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_628" class="md-nav__link">
    遍历邻接表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_629" class="md-nav__link">
    注意:使用邻接表时，遍历的顺序和邻接矩阵不一样，因为创建邻接表使用头插法(如果使用尾插法顺序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_630" class="md-nav__link">
    则一样)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_631" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#breadth-first-search_1" class="md-nav__link">
    广度优先 (Breadth First Search)
  </a>
  
    <nav class="md-nav" aria-label="广度优先 (Breadth First Search)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_632" class="md-nav__link">
    从图的 出发，首先访问 ，然后访问 的所有邻接点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_633" class="md-nav__link">
    然后按照 的顺序，依次访问他们的邻接点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_634" class="md-nav__link">
    实现遍历下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_635" class="md-nav__link">
    代码实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_636" class="md-nav__link">
    遍历矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_637" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_638" class="md-nav__link">
    遍历邻接表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_639" class="md-nav__link">
    注意:使用邻接表时，遍历的顺序和邻接矩阵不一样，因为创建邻接表使用头插法(如果使用尾插法顺序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_640" class="md-nav__link">
    则一样)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_641" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_642" class="md-nav__link">
    算法效率
  </a>
  
    <nav class="md-nav" aria-label="算法效率">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_643" class="md-nav__link">
    可知，邻接矩阵的时间效率为 邻接表的时间效率为
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#spanning-tree_3" class="md-nav__link">
    最小生成树 Spanning Tree
  </a>
  
    <nav class="md-nav" aria-label="最小生成树 Spanning Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#prim_1" class="md-nav__link">
    Prim 算法
  </a>
  
    <nav class="md-nav" aria-label="Prim 算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_644" class="md-nav__link">
    令 为连通图带权，且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_645" class="md-nav__link">
    设起点为 把 加入到 中
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_646" class="md-nav__link">
    选取 为最小
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_647" class="md-nav__link">
    输出 边
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_648" class="md-nav__link">
    把 加入 中
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_649" class="md-nav__link">
    选取 为最小
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_650" class="md-nav__link">
    输出 边
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_651" class="md-nav__link">
    直到存在 条边
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_652" class="md-nav__link">
    此时输出的边即为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_653" class="md-nav__link">
    代码实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#spanning-tree_4" class="md-nav__link">
    实现下图的Spanning Tree
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#u" class="md-nav__link">
    需要辅助集合U
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_654" class="md-nav__link">
    邻接矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_655" class="md-nav__link">
    前置算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_656" class="md-nav__link">
    邻接表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_657" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kruskal_1" class="md-nav__link">
    Kruskal 算法
  </a>
  
    <nav class="md-nav" aria-label="Kruskal 算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_658" class="md-nav__link">
    定理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_659" class="md-nav__link">
    若无向有权无环图 为 图的最大连通子图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_660" class="md-nav__link">
    ，作为连通依赖点，则 集合所有点必然存在一条通往 的路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_661" class="md-nav__link">
    单个顶点的连通依赖点为自身注意 表示为 不可以这么表示
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_662" class="md-nav__link">
    令 为连通依赖点，且 使 之间并不存在路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_663" class="md-nav__link">
    为连通图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_664" class="md-nav__link">
    引理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_665" class="md-nav__link">
    若 分别为 的最大连通子图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_666" class="md-nav__link">
    若 ，则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_667" class="md-nav__link">
    利用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_668" class="md-nav__link">
    若 ，则说明 中所有的点都有一条通往 的路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_669" class="md-nav__link">
    为最大连通子图子图 同理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_670" class="md-nav__link">
    算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_671" class="md-nav__link">
    若存在无向带权图 且 连通
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_672" class="md-nav__link">
    令集合
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_673" class="md-nav__link">
    对 进行排序，取 ，把 加入 中
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_674" class="md-nav__link">
    循环对 进行如下操作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_675" class="md-nav__link">
    如果 的连通依赖点 的联通点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_676" class="md-nav__link">
    则把 加入到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_677" class="md-nav__link">
    直到遍历所有边
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_678" class="md-nav__link">
    集合中为 的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_679" class="md-nav__link">
    代码实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_680" class="md-nav__link">
    数据类型定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_681" class="md-nav__link">
    采用冒泡排序，可以灵活变换
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_682" class="md-nav__link">
    邻接矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_683" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_684" class="md-nav__link">
    邻接表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_685" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_686" class="md-nav__link">
    最短路径
  </a>
  
    <nav class="md-nav" aria-label="最短路径">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dijkstra_1" class="md-nav__link">
    Dijkstra 算法
  </a>
  
    <nav class="md-nav" aria-label="Dijkstra 算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_687" class="md-nav__link">
    若有无向带权网
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_688" class="md-nav__link">
    以 为顶点，求出所有 和 间的最路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_689" class="md-nav__link">
    令 为 到 间的路径长度，集合
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_690" class="md-nav__link">
    若 存在，则初始化 ，若不存在则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_691" class="md-nav__link">
    遍历所有点之后，把 加入到 中
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_692" class="md-nav__link">
    把 加入到 中，若 为 的邻接点，且
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_693" class="md-nav__link">
    则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_694" class="md-nav__link">
    重复上步骤，直到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_695" class="md-nav__link">
    用代码实现此图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_696" class="md-nav__link">
    代码实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_697" class="md-nav__link">
    邻接矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_698" class="md-nav__link">
    测试代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#floyd_1" class="md-nav__link">
    Floyd算法
  </a>
  
    <nav class="md-nav" aria-label="Floyd算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_699" class="md-nav__link">
    本质上为暴力算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_700" class="md-nav__link">
    令矩阵 存储图 的权值，其中 有 个顶点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_701" class="md-nav__link">
    表示到的 表示 到 的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_702" class="md-nav__link">
    遍历矩阵所有元素，向 之间插入点 ，如果
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_703" class="md-nav__link">
    则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_704" class="md-nav__link">
    遍历结束后，矩阵 记录 的最短路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_705" class="md-nav__link">
    代码实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_706" class="md-nav__link">
    邻接矩阵
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#directed-acycline-graph_1" class="md-nav__link">
    有向无环图(Directed Acycline Graph)
  </a>
  
    <nav class="md-nav" aria-label="有向无环图(Directed Acycline Graph)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#aocaoe_1" class="md-nav__link">
    AOC和AOE
  </a>
  
    <nav class="md-nav" aria-label="AOC和AOE">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_707" class="md-nav__link">
    网
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_708" class="md-nav__link">
    用一个有向图表示一个工程的各个子工程及其相互制约关系
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_709" class="md-nav__link">
    其中顶点表示活动，弧表示优先制约关系
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_710" class="md-nav__link">
    网
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_711" class="md-nav__link">
    弧表示活动，以顶点表示活动开始或结束事件
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_712" class="md-nav__link">
    拓扑排序
  </a>
  
    <nav class="md-nav" aria-label="拓扑排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_713" class="md-nav__link">
    在 网没有回路的前提下，将全部活动排列成一个线性序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_714" class="md-nav__link">
    网中边 存在，则在这个序列中一定排在的前面
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_715" class="md-nav__link">
    对 网进行如上排序，即为拓扑排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_716" class="md-nav__link">
    算法思路
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_717" class="md-nav__link">
    若 图中 ，则去除掉所有和 相关的边
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_718" class="md-nav__link">
    令 ，把 加入到 中
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_719" class="md-nav__link">
    更新所有 的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_720" class="md-nav__link">
    直到
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_721" class="md-nav__link">
    此时 的序列则为拓扑序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_722" class="md-nav__link">
    代码实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_723" class="md-nav__link">
    实现下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_724" class="md-nav__link">
    邻接表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_725" class="md-nav__link">
    前置函数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_726" class="md-nav__link">
    关键路径
  </a>
  
    <nav class="md-nav" aria-label="关键路径">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_727" class="md-nav__link">
    如上图 网，源点 表示事件整体的开始，汇点 表示事件整体结束
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_728" class="md-nav__link">
    其他的点则表示一个活动的结束，同时也表示另外一个活动的开始
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_729" class="md-nav__link">
    关 表示时间，而 表示活动， 表示活动所需要的时间
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_730" class="md-nav__link">
    令 表示 的最早开始时间，即 时间之前的活动必须完成， 才能开始
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_731" class="md-nav__link">
    即 为的直接前驱
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_732" class="md-nav__link">
    令 表示 的最迟开始时间 即 的后继点 需要为 留出时间 为 的直接前驱
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_733" class="md-nav__link">
    若已知 ，则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_734" class="md-nav__link">
    活动时间 表示边 的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_735" class="md-nav__link">
    表示， 发生的最早时间，只有 发生了， 才能发生
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_736" class="md-nav__link">
    所以
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_737" class="md-nav__link">
    注意
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_738" class="md-nav__link">
    ，即源点 的最早发生时间为
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_739" class="md-nav__link">
    即汇点 的发生最早时间 的最迟时间
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_740" class="md-nav__link">
    由此可知 从源点开始向前递归 从后向前递归
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_741" class="md-nav__link">
    表示 的最迟发生时间
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_742" class="md-nav__link">
    若 则说明活动 没有缓冲时间，为关键路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_743" class="md-nav__link">
    如果 这说明活动 有 时间可以调整
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_744" class="md-nav__link">
    代码实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_745" class="md-nav__link">
    实现下图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_746" class="md-nav__link">
    邻接表
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_747" class="md-nav__link">
    图的头文件
  </a>
  
    <nav class="md-nav" aria-label="图的头文件">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#define_graphh_1" class="md-nav__link">
    define_Graph.h
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#amgraphh_1" class="md-nav__link">
    AMGraph.h
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#algraphh_1" class="md-nav__link">
    ALGraph.h
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#endif" class="md-nav__link">
    endif
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h6 id="_1">数据结构<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h6>
<h6 id="_2">宏定义<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h6>
<h6 id="1">1. 线性表<a class="headerlink" href="#1" title="Permanent link">&para;</a></h6>
<h6 id="sequence-list">顺序表(Sequence List)<a class="headerlink" href="#sequence-list" title="Permanent link">&para;</a></h6>
<h6 id="_3">初始化<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h6>
<h6 id="_4">获取元素<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h6>
<h6 id="_5">查找元素<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h6>
<h6 id="_6">插入<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h6>
<h6 id="_7">删除<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h6>
<h6 id="_8">销毁，清空，检查为空<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h6>
<h6 id="_9">顺序表的头文件<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h6>
<h6 id="single-linked-list">单链表(Single Linked List)<a class="headerlink" href="#single-linked-list" title="Permanent link">&para;</a></h6>
<h6 id="_10">初始化<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h6>
<h6 id="_11">创建链表(头插法)<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h6>
<h6 id="_12">创建链表(尾插法)<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h6>
<h6 id="_13">获取元素<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h6>
<h6 id="_14">查找元素<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h6>
<h6 id="_15">插入元素<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h6>
<h6 id="_16">删除元素<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h6>
<h6 id="_17">总结插入和删除操作算法的不同<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h6>
<h6 id="_18">销毁链表<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h6>
<h6 id="_19">单链表头文件<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h6>
<h6 id="circular-linked-list">循环链表(Circular Linked List)<a class="headerlink" href="#circular-linked-list" title="Permanent link">&para;</a></h6>
<h6 id="double-linked-list">双向链表(Double Linked List)<a class="headerlink" href="#double-linked-list" title="Permanent link">&para;</a></h6>
<h6 id="_20">初始化<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h6>
<h6 id="_21">创建双向链表<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h6>
<h6 id="_22">插入和删除<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h6>
<h6 id="_23">线性表玩具<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h6>
<h6 id="_24">线性表合并<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h6>
<h6 id="_25">有序表合并(并归排序的基础)<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h6>
<h6 id="_26">有序链表合并<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h6>
<h6 id="and">多项式创建 and 多项式相加<a class="headerlink" href="#and" title="Permanent link">&para;</a></h6>
<h6 id="2-stack-and-queue">2. 栈和队列(Stack and Queue)<a class="headerlink" href="#2-stack-and-queue" title="Permanent link">&para;</a></h6>
<h6 id="sequence-stack">顺序栈(Sequence Stack)<a class="headerlink" href="#sequence-stack" title="Permanent link">&para;</a></h6>
<h6 id="_27">栈的类型定义<a class="headerlink" href="#_27" title="Permanent link">&para;</a></h6>
<h6 id="_28">栈的初始化<a class="headerlink" href="#_28" title="Permanent link">&para;</a></h6>
<h6 id="push">入栈(Push)<a class="headerlink" href="#push" title="Permanent link">&para;</a></h6>
<h6 id="pop">出栈(Pop)<a class="headerlink" href="#pop" title="Permanent link">&para;</a></h6>
<h6 id="_29">栈的其他操作<a class="headerlink" href="#_29" title="Permanent link">&para;</a></h6>
<h6 id="_30">测试代码<a class="headerlink" href="#_30" title="Permanent link">&para;</a></h6>
<h6 id="linked-stack">链栈(Linked Stack)<a class="headerlink" href="#linked-stack" title="Permanent link">&para;</a></h6>
<h6 id="_31">链栈的类型定义<a class="headerlink" href="#_31" title="Permanent link">&para;</a></h6>
<h6 id="_32">链栈初始化<a class="headerlink" href="#_32" title="Permanent link">&para;</a></h6>
<h6 id="push_1">链栈Push<a class="headerlink" href="#push_1" title="Permanent link">&para;</a></h6>
<h6 id="pop_1">链栈Pop<a class="headerlink" href="#pop_1" title="Permanent link">&para;</a></h6>
<h6 id="_33">链栈的其他操作<a class="headerlink" href="#_33" title="Permanent link">&para;</a></h6>
<h6 id="_34">测试代码<a class="headerlink" href="#_34" title="Permanent link">&para;</a></h6>
<h6 id="stackh">Stack.h<a class="headerlink" href="#stackh" title="Permanent link">&para;</a></h6>
<h6 id="_35">栈与递归<a class="headerlink" href="#_35" title="Permanent link">&para;</a></h6>
<h6 id="_36">函数的调用过程<a class="headerlink" href="#_36" title="Permanent link">&para;</a></h6>
<h6 id="_37">循环队列<a class="headerlink" href="#_37" title="Permanent link">&para;</a></h6>
<h6 id="_38">顺换队列初始化<a class="headerlink" href="#_38" title="Permanent link">&para;</a></h6>
<h6 id="_39">顺换队列入队<a class="headerlink" href="#_39" title="Permanent link">&para;</a></h6>
<h6 id="_40">循环队列出队<a class="headerlink" href="#_40" title="Permanent link">&para;</a></h6>
<h6 id="_41">循环队列其他操作<a class="headerlink" href="#_41" title="Permanent link">&para;</a></h6>
<h6 id="_42">测试代码<a class="headerlink" href="#_42" title="Permanent link">&para;</a></h6>
<h6 id="_43">链队<a class="headerlink" href="#_43" title="Permanent link">&para;</a></h6>
<h6 id="_44">链队初始化<a class="headerlink" href="#_44" title="Permanent link">&para;</a></h6>
<h6 id="_45">链队入队<a class="headerlink" href="#_45" title="Permanent link">&para;</a></h6>
<h6 id="_46">链队出队<a class="headerlink" href="#_46" title="Permanent link">&para;</a></h6>
<h6 id="_47">栈和队列玩具<a class="headerlink" href="#_47" title="Permanent link">&para;</a></h6>
<h6 id="_48">进制转化<a class="headerlink" href="#_48" title="Permanent link">&para;</a></h6>
<h6 id="_49">括号的匹配<a class="headerlink" href="#_49" title="Permanent link">&para;</a></h6>
<h6 id="10">10 以内的计算器<a class="headerlink" href="#10" title="Permanent link">&para;</a></h6>
<h6 id="3">3. 字符串，数组，广义表<a class="headerlink" href="#3" title="Permanent link">&para;</a></h6>
<h6 id="_50">字符串匹配<a class="headerlink" href="#_50" title="Permanent link">&para;</a></h6>
<h6 id="bfbrute-force">BF算法(Brute Force)<a class="headerlink" href="#bfbrute-force" title="Permanent link">&para;</a></h6>
<h6 id="kmp">KMP算法<a class="headerlink" href="#kmp" title="Permanent link">&para;</a></h6>
<h6 id="next">求next数组<a class="headerlink" href="#next" title="Permanent link">&para;</a></h6>
<h6 id="_51">字符串匹配玩具<a class="headerlink" href="#_51" title="Permanent link">&para;</a></h6>
<h6 id="_52">数组<a class="headerlink" href="#_52" title="Permanent link">&para;</a></h6>
<h6 id="generalized-list">广义表(Generalized List)<a class="headerlink" href="#generalized-list" title="Permanent link">&para;</a></h6>
<h6 id="4">4. 树、二叉树、森林<a class="headerlink" href="#4" title="Permanent link">&para;</a></h6>
<h6 id="_53">定义<a class="headerlink" href="#_53" title="Permanent link">&para;</a></h6>
<h6 id="_54">树的基本术语<a class="headerlink" href="#_54" title="Permanent link">&para;</a></h6>
<h6 id="_55">二叉树的定义<a class="headerlink" href="#_55" title="Permanent link">&para;</a></h6>
<h6 id="_56">二叉树的性质<a class="headerlink" href="#_56" title="Permanent link">&para;</a></h6>
<h6 id="_57">二叉树定理<a class="headerlink" href="#_57" title="Permanent link">&para;</a></h6>
<h6 id="_58">完全二叉树性质及定理<a class="headerlink" href="#_58" title="Permanent link">&para;</a></h6>
<h6 id="_59">链式二叉树<a class="headerlink" href="#_59" title="Permanent link">&para;</a></h6>
<h6 id="_60">存储结构<a class="headerlink" href="#_60" title="Permanent link">&para;</a></h6>
<h6 id="_61">遍历方式(递归)<a class="headerlink" href="#_61" title="Permanent link">&para;</a></h6>
<h6 id="_62">遍历方式(非递归)<a class="headerlink" href="#_62" title="Permanent link">&para;</a></h6>
<h6 id="_63">先序遍历创建二叉树<a class="headerlink" href="#_63" title="Permanent link">&para;</a></h6>
<h6 id="_64">测试(创建，遍历)<a class="headerlink" href="#_64" title="Permanent link">&para;</a></h6>
<h6 id="_65">层次遍历算法<a class="headerlink" href="#_65" title="Permanent link">&para;</a></h6>
<h6 id="_66">复制二叉树<a class="headerlink" href="#_66" title="Permanent link">&para;</a></h6>
<h6 id="_67">求深度和节点数<a class="headerlink" href="#_67" title="Permanent link">&para;</a></h6>
<h6 id="_68">销毁二叉树(递归和非递归)<a class="headerlink" href="#_68" title="Permanent link">&para;</a></h6>
<h6 id="_69">头文件<a class="headerlink" href="#_69" title="Permanent link">&para;</a></h6>
<h6 id="threaded-binary-tree">线索二叉树 Threaded Binary Tree(了解即可)<a class="headerlink" href="#threaded-binary-tree" title="Permanent link">&para;</a></h6>
<h6 id="_70">数据类型定义<a class="headerlink" href="#_70" title="Permanent link">&para;</a></h6>
<h6 id="_71">树和森林<a class="headerlink" href="#_71" title="Permanent link">&para;</a></h6>
<h6 id="_72">树的存储结构<a class="headerlink" href="#_72" title="Permanent link">&para;</a></h6>
<h6 id="1_1">1. 双亲表示法<a class="headerlink" href="#1_1" title="Permanent link">&para;</a></h6>
<h6 id="2">2. 孩子链表<a class="headerlink" href="#2" title="Permanent link">&para;</a></h6>
<h6 id="3_1">3. 孩子兄弟表示法(树转化二叉树的基础)<a class="headerlink" href="#3_1" title="Permanent link">&para;</a></h6>
<h6 id="_73">树与二叉树之间相互转换<a class="headerlink" href="#_73" title="Permanent link">&para;</a></h6>
<h6 id="_74">树转二叉树<a class="headerlink" href="#_74" title="Permanent link">&para;</a></h6>
<h6 id="_75">二叉树转树<a class="headerlink" href="#_75" title="Permanent link">&para;</a></h6>
<h6 id="_76">森林与二叉树之间的转化<a class="headerlink" href="#_76" title="Permanent link">&para;</a></h6>
<h6 id="_77">森林转二叉树<a class="headerlink" href="#_77" title="Permanent link">&para;</a></h6>
<h6 id="_78">二叉树转森林<a class="headerlink" href="#_78" title="Permanent link">&para;</a></h6>
<h6 id="_79">树和森林的遍历<a class="headerlink" href="#_79" title="Permanent link">&para;</a></h6>
<h6 id="_80">树的遍历<a class="headerlink" href="#_80" title="Permanent link">&para;</a></h6>
<h6 id="_81">森林的遍历<a class="headerlink" href="#_81" title="Permanent link">&para;</a></h6>
<h6 id="_82">哈夫曼树<a class="headerlink" href="#_82" title="Permanent link">&para;</a></h6>
<h6 id="_83">术语<a class="headerlink" href="#_83" title="Permanent link">&para;</a></h6>
<h6 id="_84">最优二叉树<a class="headerlink" href="#_84" title="Permanent link">&para;</a></h6>
<h6 id="_85">构造哈夫曼树<a class="headerlink" href="#_85" title="Permanent link">&para;</a></h6>
<h6 id="step">step和定理<a class="headerlink" href="#step" title="Permanent link">&para;</a></h6>
<h6 id="_86">代码实现<a class="headerlink" href="#_86" title="Permanent link">&para;</a></h6>
<h6 id="_87">哈夫曼编码<a class="headerlink" href="#_87" title="Permanent link">&para;</a></h6>
<h6 id="_88">代码实现<a class="headerlink" href="#_88" title="Permanent link">&para;</a></h6>
<h6 id="_89">整体头文件<a class="headerlink" href="#_89" title="Permanent link">&para;</a></h6>
<h6 id="5-graph">5. 图(Graph)<a class="headerlink" href="#5-graph" title="Permanent link">&para;</a></h6>
<h6 id="_90">图的定义和术语<a class="headerlink" href="#_90" title="Permanent link">&para;</a></h6>
<h6 id="_91">完全图<a class="headerlink" href="#_91" title="Permanent link">&para;</a></h6>
<h6 id="sparse-graphdense-gaph">稀疏图(Sparse Graph)和稠密图(Dense Gaph)<a class="headerlink" href="#sparse-graphdense-gaph" title="Permanent link">&para;</a></h6>
<h6 id="degree">顶点的度(degree)<a class="headerlink" href="#degree" title="Permanent link">&para;</a></h6>
<h6 id="path">路径(path)<a class="headerlink" href="#path" title="Permanent link">&para;</a></h6>
<h6 id="connected-graph">连通图(Connected Graph)<a class="headerlink" href="#connected-graph" title="Permanent link">&para;</a></h6>
<h6 id="connected-component">连通子图和连通分量(Connected Component)<a class="headerlink" href="#connected-component" title="Permanent link">&para;</a></h6>
<h6 id="spanning-tree">极小连通子图和生成树(Spanning Tree)<a class="headerlink" href="#spanning-tree" title="Permanent link">&para;</a></h6>
<h6 id="_92">图的存储结构<a class="headerlink" href="#_92" title="Permanent link">&para;</a></h6>
<h6 id="adjacency-matrix">邻接矩阵(Adjacency Matrix)<a class="headerlink" href="#adjacency-matrix" title="Permanent link">&para;</a></h6>
<h6 id="_93">无向图<a class="headerlink" href="#_93" title="Permanent link">&para;</a></h6>
<h6 id="_94">有向图<a class="headerlink" href="#_94" title="Permanent link">&para;</a></h6>
<h6 id="weighted-graph">带权图(网) weighted Graph<a class="headerlink" href="#weighted-graph" title="Permanent link">&para;</a></h6>
<h6 id="_95">代码实现<a class="headerlink" href="#_95" title="Permanent link">&para;</a></h6>
<h6 id="_96">无向无权图<a class="headerlink" href="#_96" title="Permanent link">&para;</a></h6>
<h6 id="_97">无向带权图<a class="headerlink" href="#_97" title="Permanent link">&para;</a></h6>
<h6 id="_98">有向带权图<a class="headerlink" href="#_98" title="Permanent link">&para;</a></h6>
<h6 id="_99">有向无权图<a class="headerlink" href="#_99" title="Permanent link">&para;</a></h6>
<h6 id="adjacency-list">邻接表(Adjacency List)<a class="headerlink" href="#adjacency-list" title="Permanent link">&para;</a></h6>
<h6 id="_100">代码实现<a class="headerlink" href="#_100" title="Permanent link">&para;</a></h6>
<h6 id="_101">无向无权图<a class="headerlink" href="#_101" title="Permanent link">&para;</a></h6>
<h6 id="_102">邻接表和邻接矩阵的比较<a class="headerlink" href="#_102" title="Permanent link">&para;</a></h6>
<h6 id="_103">十字链表<a class="headerlink" href="#_103" title="Permanent link">&para;</a></h6>
<h6 id="_104">邻接多重链表<a class="headerlink" href="#_104" title="Permanent link">&para;</a></h6>
<h6 id="_105">图的遍历<a class="headerlink" href="#_105" title="Permanent link">&para;</a></h6>
<h6 id="depth-first-search">深度优先 (Depth First Search)<a class="headerlink" href="#depth-first-search" title="Permanent link">&para;</a></h6>
<h6 id="_106">遍历矩阵<a class="headerlink" href="#_106" title="Permanent link">&para;</a></h6>
<h6 id="_107">遍历邻接表<a class="headerlink" href="#_107" title="Permanent link">&para;</a></h6>
<h6 id="breadth-first-search">广度优先 (Breadth First Search)<a class="headerlink" href="#breadth-first-search" title="Permanent link">&para;</a></h6>
<h6 id="_108">遍历矩阵<a class="headerlink" href="#_108" title="Permanent link">&para;</a></h6>
<h6 id="_109">遍历邻接表<a class="headerlink" href="#_109" title="Permanent link">&para;</a></h6>
<h6 id="_110">算法效率<a class="headerlink" href="#_110" title="Permanent link">&para;</a></h6>
<h6 id="spanning-tree_1">最小生成树 Spanning Tree<a class="headerlink" href="#spanning-tree_1" title="Permanent link">&para;</a></h6>
<h6 id="prim">Prim 算法<a class="headerlink" href="#prim" title="Permanent link">&para;</a></h6>
<h6 id="_111">代码实现<a class="headerlink" href="#_111" title="Permanent link">&para;</a></h6>
<h6 id="_112">邻接矩阵<a class="headerlink" href="#_112" title="Permanent link">&para;</a></h6>
<h6 id="_113">邻接表<a class="headerlink" href="#_113" title="Permanent link">&para;</a></h6>
<h6 id="kruskal">Kruskal 算法<a class="headerlink" href="#kruskal" title="Permanent link">&para;</a></h6>
<h6 id="_114">代码实现<a class="headerlink" href="#_114" title="Permanent link">&para;</a></h6>
<h6 id="_115">邻接矩阵<a class="headerlink" href="#_115" title="Permanent link">&para;</a></h6>
<h6 id="_116">邻接表<a class="headerlink" href="#_116" title="Permanent link">&para;</a></h6>
<h6 id="_117">最短路径<a class="headerlink" href="#_117" title="Permanent link">&para;</a></h6>
<h6 id="dijkstra">Dijkstra 算法<a class="headerlink" href="#dijkstra" title="Permanent link">&para;</a></h6>
<h6 id="_118">代码实现<a class="headerlink" href="#_118" title="Permanent link">&para;</a></h6>
<h6 id="_119">邻接矩阵<a class="headerlink" href="#_119" title="Permanent link">&para;</a></h6>
<h6 id="floyd">Floyd算法<a class="headerlink" href="#floyd" title="Permanent link">&para;</a></h6>
<h6 id="_120">代码实现<a class="headerlink" href="#_120" title="Permanent link">&para;</a></h6>
<h6 id="_121">邻接矩阵<a class="headerlink" href="#_121" title="Permanent link">&para;</a></h6>
<h6 id="directed-acycline-graph">有向无环图(Directed Acycline Graph)<a class="headerlink" href="#directed-acycline-graph" title="Permanent link">&para;</a></h6>
<h6 id="aocaoe">AOC和AOE<a class="headerlink" href="#aocaoe" title="Permanent link">&para;</a></h6>
<h6 id="_122">拓扑排序<a class="headerlink" href="#_122" title="Permanent link">&para;</a></h6>
<h6 id="_123">代码实现<a class="headerlink" href="#_123" title="Permanent link">&para;</a></h6>
<h6 id="_124">邻接表<a class="headerlink" href="#_124" title="Permanent link">&para;</a></h6>
<h6 id="_125">关键路径<a class="headerlink" href="#_125" title="Permanent link">&para;</a></h6>
<h6 id="_126">代码实现<a class="headerlink" href="#_126" title="Permanent link">&para;</a></h6>
<h6 id="_127">邻接表<a class="headerlink" href="#_127" title="Permanent link">&para;</a></h6>
<h6 id="_128">图的头文件<a class="headerlink" href="#_128" title="Permanent link">&para;</a></h6>
<h6 id="define_graphh">define_Graph.h<a class="headerlink" href="#define_graphh" title="Permanent link">&para;</a></h6>
<h6 id="amgraphh">AMGraph.h<a class="headerlink" href="#amgraphh" title="Permanent link">&para;</a></h6>
<h6 id="algraphh">ALGraph.h<a class="headerlink" href="#algraphh" title="Permanent link">&para;</a></h6>
<h1 id="_129">数据结构<a class="headerlink" href="#_129" title="Permanent link">&para;</a></h1>
<h2 id="_130">宏定义<a class="headerlink" href="#_130" title="Permanent link">&para;</a></h2>
<h6 id="defineh">在本笔记中用到的宏定义，头文件为define.h<a class="headerlink" href="#defineh" title="Permanent link">&para;</a></h6>
<h2 id="1_2">1. 线性表<a class="headerlink" href="#1_2" title="Permanent link">&para;</a></h2>
<h2 id="sequence-list_1">顺序表(Sequence List)<a class="headerlink" href="#sequence-list_1" title="Permanent link">&para;</a></h2>
<h6 id="_131">特点：逻辑上相邻的数据元素，其物理次序也是相邻的<a class="headerlink" href="#_131" title="Permanent link">&para;</a></h6>
<h6 id="_132">线性表中第 个数据元素的存储位置 和第个元素满足下列关系<a class="headerlink" href="#_132" title="Permanent link">&para;</a></h6>
<h6 id="_133">代表每个元素所占的存储单元<a class="headerlink" href="#_133" title="Permanent link">&para;</a></h6>
<h6 id="_134">循序表的存储结构：<a class="headerlink" href="#_134" title="Permanent link">&para;</a></h6>
<h2 id="_135">初始化<a class="headerlink" href="#_135" title="Permanent link">&para;</a></h2>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-0-1">1</a></span>
<span class="normal"><a href="#__codelineno-0-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-0-1" name="__codelineno-0-1"></a>#ifndef __DEFINE_H
<a id="__codelineno-0-2" name="__codelineno-0-2"></a>#define __DEFINE_H
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-1-1">1</a></span>
<span class="normal"><a href="#__codelineno-1-2">2</a></span>
<span class="normal"><a href="#__codelineno-1-3">3</a></span>
<span class="normal"><a href="#__codelineno-1-4">4</a></span>
<span class="normal"><a href="#__codelineno-1-5">5</a></span>
<span class="normal"><a href="#__codelineno-1-6">6</a></span>
<span class="normal"><a href="#__codelineno-1-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-1-1" name="__codelineno-1-1"></a>#define TRUE 1
<a id="__codelineno-1-2" name="__codelineno-1-2"></a>#define FALSE 0
<a id="__codelineno-1-3" name="__codelineno-1-3"></a>#define OK 1
<a id="__codelineno-1-4" name="__codelineno-1-4"></a>#define ERROR 0
<a id="__codelineno-1-5" name="__codelineno-1-5"></a>#define INFEASIBLE -
<a id="__codelineno-1-6" name="__codelineno-1-6"></a>#define OVERFLOW -
<a id="__codelineno-1-7" name="__codelineno-1-7"></a>typedef int Status;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-2-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-2-1" name="__codelineno-2-1"></a>#endif
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-3-1">1</a></span>
<span class="normal"><a href="#__codelineno-3-2">2</a></span>
<span class="normal"><a href="#__codelineno-3-3">3</a></span>
<span class="normal"><a href="#__codelineno-3-4">4</a></span>
<span class="normal"><a href="#__codelineno-3-5">5</a></span>
<span class="normal"><a href="#__codelineno-3-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-3-1" name="__codelineno-3-1"></a>#define SQLMAXSIZE 100
<a id="__codelineno-3-2" name="__codelineno-3-2"></a>typedef int SqlElemType;
<a id="__codelineno-3-3" name="__codelineno-3-3"></a>typedef struct __Sqlist {
<a id="__codelineno-3-4" name="__codelineno-3-4"></a>SqlElemType *base;
<a id="__codelineno-3-5" name="__codelineno-3-5"></a>int length;
<a id="__codelineno-3-6" name="__codelineno-3-6"></a>} Sqlist;
</code></pre></div></td></tr></table></div></p>
<h4 id="_136">获取元素<a class="headerlink" href="#_136" title="Permanent link">&para;</a></h4>
<h4 id="_137">查找元素<a class="headerlink" href="#_137" title="Permanent link">&para;</a></h4>
<h6 id="aslaverage-search-length">平均查找长度ASL(Average Search Length)<a class="headerlink" href="#aslaverage-search-length" title="Permanent link">&para;</a></h6>
<h6 id="_138">为查找第个元素成功的概率<a class="headerlink" href="#_138" title="Permanent link">&para;</a></h6>
<h6 id="_139">为查找第个元素需要比较的次数<a class="headerlink" href="#_139" title="Permanent link">&para;</a></h6>
<h6 id="_140">可知<a class="headerlink" href="#_140" title="Permanent link">&para;</a></h6>
<h6 id="_141">为第个元素在表中位置<a class="headerlink" href="#_141" title="Permanent link">&para;</a></h6>
<h6 id="_142">因此可知 的时间复杂度为<a class="headerlink" href="#_142" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-4-1">1</a></span>
<span class="normal"><a href="#__codelineno-4-2">2</a></span>
<span class="normal"><a href="#__codelineno-4-3">3</a></span>
<span class="normal"><a href="#__codelineno-4-4">4</a></span>
<span class="normal"><a href="#__codelineno-4-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-4-1" name="__codelineno-4-1"></a>Status InitSL(Sqlist *L, int length) {
<a id="__codelineno-4-2" name="__codelineno-4-2"></a>L-&gt;base = (SqlElemType *)malloc(sizeof(SqlElemType) * SQLMAXSIZE);
<a id="__codelineno-4-3" name="__codelineno-4-3"></a>if (!L-&gt;base)
<a id="__codelineno-4-4" name="__codelineno-4-4"></a>return OVERFLOW;
<a id="__codelineno-4-5" name="__codelineno-4-5"></a>L-&gt;length = 0 ;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-5-1">1</a></span>
<span class="normal"><a href="#__codelineno-5-2">2</a></span>
<span class="normal"><a href="#__codelineno-5-3">3</a></span>
<span class="normal"><a href="#__codelineno-5-4">4</a></span>
<span class="normal"><a href="#__codelineno-5-5">5</a></span>
<span class="normal"><a href="#__codelineno-5-6">6</a></span>
<span class="normal"><a href="#__codelineno-5-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-5-1" name="__codelineno-5-1"></a>for (int i = 1 ; i &lt; length + 1 ; i++) {
<a id="__codelineno-5-2" name="__codelineno-5-2"></a>SqlElemType e;
<a id="__codelineno-5-3" name="__codelineno-5-3"></a>scanf(&quot; %d&quot;, &amp;e);
<a id="__codelineno-5-4" name="__codelineno-5-4"></a>SqlInsert(L, i, e);
<a id="__codelineno-5-5" name="__codelineno-5-5"></a>}
<a id="__codelineno-5-6" name="__codelineno-5-6"></a>return OK;
<a id="__codelineno-5-7" name="__codelineno-5-7"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-6-1">1</a></span>
<span class="normal"><a href="#__codelineno-6-2">2</a></span>
<span class="normal"><a href="#__codelineno-6-3">3</a></span>
<span class="normal"><a href="#__codelineno-6-4">4</a></span>
<span class="normal"><a href="#__codelineno-6-5">5</a></span>
<span class="normal"><a href="#__codelineno-6-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-6-1" name="__codelineno-6-1"></a>Status GetElem(Sqlist *L, int position, SqlElemType *e) {
<a id="__codelineno-6-2" name="__codelineno-6-2"></a>if (position &lt; 1 || position &gt; L-&gt;length)
<a id="__codelineno-6-3" name="__codelineno-6-3"></a>return ERROR;
<a id="__codelineno-6-4" name="__codelineno-6-4"></a>*e = L-&gt;base[position - 1 ];
<a id="__codelineno-6-5" name="__codelineno-6-5"></a>return OK;
<a id="__codelineno-6-6" name="__codelineno-6-6"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-7-1">1</a></span>
<span class="normal"><a href="#__codelineno-7-2">2</a></span>
<span class="normal"><a href="#__codelineno-7-3">3</a></span>
<span class="normal"><a href="#__codelineno-7-4">4</a></span>
<span class="normal"><a href="#__codelineno-7-5">5</a></span>
<span class="normal"><a href="#__codelineno-7-6">6</a></span>
<span class="normal"><a href="#__codelineno-7-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-7-1" name="__codelineno-7-1"></a>int LocateElem(Sqlist *L, SqlElemType e) {
<a id="__codelineno-7-2" name="__codelineno-7-2"></a>for (int i = 0 ; i &lt; L-&gt;length; i++) {
<a id="__codelineno-7-3" name="__codelineno-7-3"></a>if (e == L-&gt;base[i])
<a id="__codelineno-7-4" name="__codelineno-7-4"></a>return i + 1 ;
<a id="__codelineno-7-5" name="__codelineno-7-5"></a>}
<a id="__codelineno-7-6" name="__codelineno-7-6"></a>return 0 ; // 0代表查找元素不在循序表中
<a id="__codelineno-7-7" name="__codelineno-7-7"></a>}
</code></pre></div></td></tr></table></div></p>
<h4 id="_143">插入<a class="headerlink" href="#_143" title="Permanent link">&para;</a></h4>
<h6 id="_144">表示插入元素所需要移动元素次数的期望值平均次数<a class="headerlink" href="#_144" title="Permanent link">&para;</a></h6>
<h6 id="_145">假设在各个位置上插入元素的概率相等<a class="headerlink" href="#_145" title="Permanent link">&para;</a></h6>
<h6 id="_146">因此<a class="headerlink" href="#_146" title="Permanent link">&para;</a></h6>
<h4 id="_147">删除<a class="headerlink" href="#_147" title="Permanent link">&para;</a></h4>
<h4 id="_148">销毁，清空，检查为空<a class="headerlink" href="#_148" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-8-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-8-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-8-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-8-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-8-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-8-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-8-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-8-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-8-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-8-10">10</a></span>
<span class="normal"><a href="#__codelineno-8-11">11</a></span>
<span class="normal"><a href="#__codelineno-8-12">12</a></span>
<span class="normal"><a href="#__codelineno-8-13">13</a></span>
<span class="normal"><a href="#__codelineno-8-14">14</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-8-1" name="__codelineno-8-1"></a>Status SqlInsert(Sqlist *L, int position, SqlElemType e) {
<a id="__codelineno-8-2" name="__codelineno-8-2"></a>if (position &lt; 1 || position &gt; L-&gt;length + 1 )
<a id="__codelineno-8-3" name="__codelineno-8-3"></a>return ERROR;
<a id="__codelineno-8-4" name="__codelineno-8-4"></a>if (L-&gt;length == SQLMAXSIZE)
<a id="__codelineno-8-5" name="__codelineno-8-5"></a>return OVERFLOW;
<a id="__codelineno-8-6" name="__codelineno-8-6"></a>for (
<a id="__codelineno-8-7" name="__codelineno-8-7"></a>int i = L-&gt;length - 1 ; i &gt;= position - 1 ;
<a id="__codelineno-8-8" name="__codelineno-8-8"></a>i--) { //注意需要把数组中的元素全部向右移动，需要从数组最右边的元素开始移动
<a id="__codelineno-8-9" name="__codelineno-8-9"></a>L-&gt;base[i + 1 ] = L-&gt;base[i];
<a id="__codelineno-8-10" name="__codelineno-8-10"></a>}
<a id="__codelineno-8-11" name="__codelineno-8-11"></a>L-&gt;base[position - 1 ] = e;
<a id="__codelineno-8-12" name="__codelineno-8-12"></a>L-&gt;length++;
<a id="__codelineno-8-13" name="__codelineno-8-13"></a>return OK;
<a id="__codelineno-8-14" name="__codelineno-8-14"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-9-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-9-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-9-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-9-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-9-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-9-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-9-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-9-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-9-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-9-10">10</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-9-1" name="__codelineno-9-1"></a>Status SqlDelete(Sqlist *L, int position, SqlElemType *e) {
<a id="__codelineno-9-2" name="__codelineno-9-2"></a>if (position &lt; 1 || position &gt; L-&gt;length)
<a id="__codelineno-9-3" name="__codelineno-9-3"></a>return ERROR;
<a id="__codelineno-9-4" name="__codelineno-9-4"></a>for (int i = position; i &lt; L-&gt;length; i++) {
<a id="__codelineno-9-5" name="__codelineno-9-5"></a>L-&gt;base[i - 1 ] = L-&gt;base[i];
<a id="__codelineno-9-6" name="__codelineno-9-6"></a>}
<a id="__codelineno-9-7" name="__codelineno-9-7"></a>*e = L-&gt;base[position - 1 ];
<a id="__codelineno-9-8" name="__codelineno-9-8"></a>L-&gt;length--;
<a id="__codelineno-9-9" name="__codelineno-9-9"></a>return OK;
<a id="__codelineno-9-10" name="__codelineno-9-10"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-10-1">1</a></span>
<span class="normal"><a href="#__codelineno-10-2">2</a></span>
<span class="normal"><a href="#__codelineno-10-3">3</a></span>
<span class="normal"><a href="#__codelineno-10-4">4</a></span>
<span class="normal"><a href="#__codelineno-10-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-10-1" name="__codelineno-10-1"></a>Status SqlDelete(Sqlist *L, int position, SqlElemType *e) {
<a id="__codelineno-10-2" name="__codelineno-10-2"></a>if (position &lt; 1 || position &gt; L-&gt;length)
<a id="__codelineno-10-3" name="__codelineno-10-3"></a>return ERROR;
<a id="__codelineno-10-4" name="__codelineno-10-4"></a>for (int i = position; i &lt; L-&gt;length; i++) {
<a id="__codelineno-10-5" name="__codelineno-10-5"></a>L-&gt;base[i - 1 ] = L-&gt;base[i];
</code></pre></div></td></tr></table></div></p>
<h4 id="_149">顺序表的头文件<a class="headerlink" href="#_149" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-11-1">1</a></span>
<span class="normal"><a href="#__codelineno-11-2">2</a></span>
<span class="normal"><a href="#__codelineno-11-3">3</a></span>
<span class="normal"><a href="#__codelineno-11-4">4</a></span>
<span class="normal"><a href="#__codelineno-11-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-11-1" name="__codelineno-11-1"></a>}
<a id="__codelineno-11-2" name="__codelineno-11-2"></a>*e = L-&gt;base[position - 1 ];
<a id="__codelineno-11-3" name="__codelineno-11-3"></a>L-&gt;length--;
<a id="__codelineno-11-4" name="__codelineno-11-4"></a>return OK;
<a id="__codelineno-11-5" name="__codelineno-11-5"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-12-1">1</a></span>
<span class="normal"><a href="#__codelineno-12-2">2</a></span>
<span class="normal"><a href="#__codelineno-12-3">3</a></span>
<span class="normal"><a href="#__codelineno-12-4">4</a></span>
<span class="normal"><a href="#__codelineno-12-5">5</a></span>
<span class="normal"><a href="#__codelineno-12-6">6</a></span>
<span class="normal"><a href="#__codelineno-12-7">7</a></span>
<span class="normal"><a href="#__codelineno-12-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-12-1" name="__codelineno-12-1"></a>Status SqlDestroy(Sqlist *L) {
<a id="__codelineno-12-2" name="__codelineno-12-2"></a>if (!L-&gt;base)
<a id="__codelineno-12-3" name="__codelineno-12-3"></a>return ERROR;
<a id="__codelineno-12-4" name="__codelineno-12-4"></a>else {
<a id="__codelineno-12-5" name="__codelineno-12-5"></a>free(L-&gt;base);
<a id="__codelineno-12-6" name="__codelineno-12-6"></a>return OK;
<a id="__codelineno-12-7" name="__codelineno-12-7"></a>}
<a id="__codelineno-12-8" name="__codelineno-12-8"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-13-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-13-1" name="__codelineno-13-1"></a>void SqlClear(Sqlist *L) { L-&gt;length = 0 ; }
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-14-1">1</a></span>
<span class="normal"><a href="#__codelineno-14-2">2</a></span>
<span class="normal"><a href="#__codelineno-14-3">3</a></span>
<span class="normal"><a href="#__codelineno-14-4">4</a></span>
<span class="normal"><a href="#__codelineno-14-5">5</a></span>
<span class="normal"><a href="#__codelineno-14-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-14-1" name="__codelineno-14-1"></a>Status SqlIsEmpty(Sqlist *L) {
<a id="__codelineno-14-2" name="__codelineno-14-2"></a>if ( 0 == L-&gt;length)
<a id="__codelineno-14-3" name="__codelineno-14-3"></a>return TRUE;
<a id="__codelineno-14-4" name="__codelineno-14-4"></a>else
<a id="__codelineno-14-5" name="__codelineno-14-5"></a>return FALSE;
<a id="__codelineno-14-6" name="__codelineno-14-6"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-15-1">1</a></span>
<span class="normal"><a href="#__codelineno-15-2">2</a></span>
<span class="normal"><a href="#__codelineno-15-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-15-1" name="__codelineno-15-1"></a>#include &quot;define.h&quot;
<a id="__codelineno-15-2" name="__codelineno-15-2"></a>#include &lt;stdio.h&gt;
<a id="__codelineno-15-3" name="__codelineno-15-3"></a>#include &lt;stdlib.h&gt;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-16-1">1</a></span>
<span class="normal"><a href="#__codelineno-16-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-16-1" name="__codelineno-16-1"></a>#ifndef __SEQUENCELIST_H
<a id="__codelineno-16-2" name="__codelineno-16-2"></a>#define __SEQUENCELIST_H
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-17-1">1</a></span>
<span class="normal"><a href="#__codelineno-17-2">2</a></span>
<span class="normal"><a href="#__codelineno-17-3">3</a></span>
<span class="normal"><a href="#__codelineno-17-4">4</a></span>
<span class="normal"><a href="#__codelineno-17-5">5</a></span>
<span class="normal"><a href="#__codelineno-17-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-17-1" name="__codelineno-17-1"></a>#define SQLMAXSIZE 100
<a id="__codelineno-17-2" name="__codelineno-17-2"></a>typedef int SqlElemType;
<a id="__codelineno-17-3" name="__codelineno-17-3"></a>typedef struct __Sqlist {
<a id="__codelineno-17-4" name="__codelineno-17-4"></a>SqlElemType *base;
<a id="__codelineno-17-5" name="__codelineno-17-5"></a>int length;
<a id="__codelineno-17-6" name="__codelineno-17-6"></a>} Sqlist;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-18-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-18-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-18-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-18-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-18-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-18-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-18-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-18-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-18-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-18-10">10</a></span>
<span class="normal"><a href="#__codelineno-18-11">11</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-18-1" name="__codelineno-18-1"></a>Status InitSL(Sqlist *L, int length);
<a id="__codelineno-18-2" name="__codelineno-18-2"></a>Status GetElem(Sqlist *L, int position, SqlElemType *e);
<a id="__codelineno-18-3" name="__codelineno-18-3"></a>int LocateElem(Sqlist *L, SqlElemType e);
<a id="__codelineno-18-4" name="__codelineno-18-4"></a>Status SqlInsert(Sqlist *L, int position, SqlElemType e);
<a id="__codelineno-18-5" name="__codelineno-18-5"></a>Status SqlDelete(Sqlist *L, int position, SqlElemType *e);
<a id="__codelineno-18-6" name="__codelineno-18-6"></a>Status SqlDestroy(Sqlist *L);
<a id="__codelineno-18-7" name="__codelineno-18-7"></a>void SqlClear(Sqlist *L);
<a id="__codelineno-18-8" name="__codelineno-18-8"></a>Status SqlIsEmpty(Sqlist *L);
<a id="__codelineno-18-9" name="__codelineno-18-9"></a>void MergeList(Sqlist *La, Sqlist *Lb);
<a id="__codelineno-18-10" name="__codelineno-18-10"></a>void Traverse(Sqlist *L);
<a id="__codelineno-18-11" name="__codelineno-18-11"></a>void MergeList_Seq(Sqlist *La, Sqlist *Lb, Sqlist *Lc);
</code></pre></div></td></tr></table></div></p>
<h3 id="single-linked-list_1">单链表(Single Linked List)<a class="headerlink" href="#single-linked-list_1" title="Permanent link">&para;</a></h3>
<h6 id="n">单链表由头节点(不存放数据只存放下个节点的地址)和n个节点组成，<a class="headerlink" href="#n" title="Permanent link">&para;</a></h6>
<h6 id="_150">每个节点分为两个域：数据域和指针域(存放下个节点的地址)<a class="headerlink" href="#_150" title="Permanent link">&para;</a></h6>
<h6 id="nnull">第n个节点的指针域为NULL<a class="headerlink" href="#nnull" title="Permanent link">&para;</a></h6>
<h6 id="_151">如下图所示<a class="headerlink" href="#_151" title="Permanent link">&para;</a></h6>
<h4 id="_152">初始化<a class="headerlink" href="#_152" title="Permanent link">&para;</a></h4>
<h4 id="_153">创建链表(头插法)<a class="headerlink" href="#_153" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-19-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-19-1" name="__codelineno-19-1"></a>#endif
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-20-1">1</a></span>
<span class="normal"><a href="#__codelineno-20-2">2</a></span>
<span class="normal"><a href="#__codelineno-20-3">3</a></span>
<span class="normal"><a href="#__codelineno-20-4">4</a></span>
<span class="normal"><a href="#__codelineno-20-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-20-1" name="__codelineno-20-1"></a>typedef int LlElemtype;
<a id="__codelineno-20-2" name="__codelineno-20-2"></a>typedef struct __LNode {
<a id="__codelineno-20-3" name="__codelineno-20-3"></a>LlElemtype data; //存放单个节点的数据
<a id="__codelineno-20-4" name="__codelineno-20-4"></a>__LNode *next; //存放下个节点的地址
<a id="__codelineno-20-5" name="__codelineno-20-5"></a>} LNode, *LinkList;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-21-1">1</a></span>
<span class="normal"><a href="#__codelineno-21-2">2</a></span>
<span class="normal"><a href="#__codelineno-21-3">3</a></span>
<span class="normal"><a href="#__codelineno-21-4">4</a></span>
<span class="normal"><a href="#__codelineno-21-5">5</a></span>
<span class="normal"><a href="#__codelineno-21-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-21-1" name="__codelineno-21-1"></a>Status InitLL(LinkList *L) // L是个二级指针
<a id="__codelineno-21-2" name="__codelineno-21-2"></a>{
<a id="__codelineno-21-3" name="__codelineno-21-3"></a>(*L) = (LinkList)malloc(sizeof(LNode));
<a id="__codelineno-21-4" name="__codelineno-21-4"></a>(*L)-&gt;next = NULL;
<a id="__codelineno-21-5" name="__codelineno-21-5"></a>return OK;
<a id="__codelineno-21-6" name="__codelineno-21-6"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-22-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-22-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-22-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-22-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-22-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-22-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-22-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-22-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-22-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-22-10">10</a></span>
<span class="normal"><a href="#__codelineno-22-11">11</a></span>
<span class="normal"><a href="#__codelineno-22-12">12</a></span>
<span class="normal"><a href="#__codelineno-22-13">13</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-22-1" name="__codelineno-22-1"></a>void CreatLL_H(LinkList L, int n)
<a id="__codelineno-22-2" name="__codelineno-22-2"></a>//用此方法创建的链表，遍历的顺序和创建的顺序相反
<a id="__codelineno-22-3" name="__codelineno-22-3"></a>{
<a id="__codelineno-22-4" name="__codelineno-22-4"></a>printf(&quot;Please input %d numbers:&quot;, n);
<a id="__codelineno-22-5" name="__codelineno-22-5"></a>for (int i = 0 ; i &lt; n; i++) {
<a id="__codelineno-22-6" name="__codelineno-22-6"></a>LinkList p = (LinkList)malloc(sizeof(LNode));
<a id="__codelineno-22-7" name="__codelineno-22-7"></a>int data;
<a id="__codelineno-22-8" name="__codelineno-22-8"></a>scanf(&quot; %d&quot;, &amp;data); //%d前面的空格代表清除制表符回车等符号
<a id="__codelineno-22-9" name="__codelineno-22-9"></a>p-&gt;data = data;
<a id="__codelineno-22-10" name="__codelineno-22-10"></a>p-&gt;next = L-&gt;next;
<a id="__codelineno-22-11" name="__codelineno-22-11"></a>L-&gt;next = p;
<a id="__codelineno-22-12" name="__codelineno-22-12"></a>}
<a id="__codelineno-22-13" name="__codelineno-22-13"></a>}
</code></pre></div></td></tr></table></div></p>
<h4 id="_154">创建链表(尾插法)<a class="headerlink" href="#_154" title="Permanent link">&para;</a></h4>
<h4 id="_155">获取元素<a class="headerlink" href="#_155" title="Permanent link">&para;</a></h4>
<h4 id="_156">查找元素<a class="headerlink" href="#_156" title="Permanent link">&para;</a></h4>
<h4 id="_157">插入元素<a class="headerlink" href="#_157" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-23-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-23-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-23-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-23-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-23-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-23-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-23-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-23-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-23-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-23-10">10</a></span>
<span class="normal"><a href="#__codelineno-23-11">11</a></span>
<span class="normal"><a href="#__codelineno-23-12">12</a></span>
<span class="normal"><a href="#__codelineno-23-13">13</a></span>
<span class="normal"><a href="#__codelineno-23-14">14</a></span>
<span class="normal"><a href="#__codelineno-23-15">15</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-23-1" name="__codelineno-23-1"></a>void CreatLL_R(LinkList L, int n) {
<a id="__codelineno-23-2" name="__codelineno-23-2"></a>printf(&quot;Please input %d numbers:&quot;, n);
<a id="__codelineno-23-3" name="__codelineno-23-3"></a>LinkList ptail;
<a id="__codelineno-23-4" name="__codelineno-23-4"></a>ptail = L;
<a id="__codelineno-23-5" name="__codelineno-23-5"></a>for (int i = 0 ; i &lt; n; i++) {
<a id="__codelineno-23-6" name="__codelineno-23-6"></a>LinkList pnew;
<a id="__codelineno-23-7" name="__codelineno-23-7"></a>pnew = (LinkList)malloc(sizeof(LNode));
<a id="__codelineno-23-8" name="__codelineno-23-8"></a>int data;
<a id="__codelineno-23-9" name="__codelineno-23-9"></a>scanf(&quot; %d&quot;, &amp;data);
<a id="__codelineno-23-10" name="__codelineno-23-10"></a>pnew-&gt;data = data;
<a id="__codelineno-23-11" name="__codelineno-23-11"></a>pnew-&gt;next = NULL;
<a id="__codelineno-23-12" name="__codelineno-23-12"></a>ptail-&gt;next = pnew;
<a id="__codelineno-23-13" name="__codelineno-23-13"></a>ptail = pnew;
<a id="__codelineno-23-14" name="__codelineno-23-14"></a>}
<a id="__codelineno-23-15" name="__codelineno-23-15"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-24-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-24-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-24-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-24-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-24-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-24-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-24-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-24-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-24-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-24-10">10</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-24-1" name="__codelineno-24-1"></a>Status GetElem(LinkList L, int position, LlElemtype *e) {
<a id="__codelineno-24-2" name="__codelineno-24-2"></a>LinkList p = L-&gt;next;
<a id="__codelineno-24-3" name="__codelineno-24-3"></a>int i = 1 ; //使i和p的位置同步，即i代表着p在链表中的位置
<a id="__codelineno-24-4" name="__codelineno-24-4"></a>if (position &lt; 1 || !p)
<a id="__codelineno-24-5" name="__codelineno-24-5"></a>return ERROR;
<a id="__codelineno-24-6" name="__codelineno-24-6"></a>while (p &amp;&amp; i &lt; position) { //此处不可 i&lt;=position,因为while成立时，内部会i++
<a id="__codelineno-24-7" name="__codelineno-24-7"></a>p = p-&gt;next;
<a id="__codelineno-24-8" name="__codelineno-24-8"></a>i++;
<a id="__codelineno-24-9" name="__codelineno-24-9"></a>}
<a id="__codelineno-24-10" name="__codelineno-24-10"></a>*e = p-&gt;data;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-25-1">1</a></span>
<span class="normal"><a href="#__codelineno-25-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-25-1" name="__codelineno-25-1"></a>return OK;
<a id="__codelineno-25-2" name="__codelineno-25-2"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-26-1">1</a></span>
<span class="normal"><a href="#__codelineno-26-2">2</a></span>
<span class="normal"><a href="#__codelineno-26-3">3</a></span>
<span class="normal"><a href="#__codelineno-26-4">4</a></span>
<span class="normal"><a href="#__codelineno-26-5">5</a></span>
<span class="normal"><a href="#__codelineno-26-6">6</a></span>
<span class="normal"><a href="#__codelineno-26-7">7</a></span>
<span class="normal"><a href="#__codelineno-26-8">8</a></span>
<span class="normal"><a href="#__codelineno-26-9">9</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-26-1" name="__codelineno-26-1"></a>LinkList LocateElem(LinkList L, LlElemtype e) {
<a id="__codelineno-26-2" name="__codelineno-26-2"></a>LinkList p = L-&gt;next;
<a id="__codelineno-26-3" name="__codelineno-26-3"></a>while (p &amp;&amp; p-&gt;data != e) {
<a id="__codelineno-26-4" name="__codelineno-26-4"></a>p = p-&gt;next;
<a id="__codelineno-26-5" name="__codelineno-26-5"></a>}
<a id="__codelineno-26-6" name="__codelineno-26-6"></a>if (!p)
<a id="__codelineno-26-7" name="__codelineno-26-7"></a>return NULL; //如果p的地址为空 说明e不在链表中
<a id="__codelineno-26-8" name="__codelineno-26-8"></a>return p;
<a id="__codelineno-26-9" name="__codelineno-26-9"></a>}
</code></pre></div></td></tr></table></div></p>
<h5 id="_158">想在 ， 之间插入 ,需要先知道 节点的地址<a class="headerlink" href="#_158" title="Permanent link">&para;</a></h5>
<h6 id="_159">如图所示，如果想要在位置 插入节点，则需要知道位置 节点的位置<a class="headerlink" href="#_159" title="Permanent link">&para;</a></h6>
<h6 id="getelem">注意因为插入操作和GetElem操作不同<a class="headerlink" href="#getelem" title="Permanent link">&para;</a></h6>
<h6 id="0-pl">要从 0 开始，p要从L开始<a class="headerlink" href="#0-pl" title="Permanent link">&para;</a></h6>
<h6 id="1-l-1">如果从 1 和L开始的话，无法再位置 1 插入元素<a class="headerlink" href="#1-l-1" title="Permanent link">&para;</a></h6>
<h4 id="_160">删除元素<a class="headerlink" href="#_160" title="Permanent link">&para;</a></h4>
<h6 id="_161">想要删除 ，则必须先知道 的地址<a class="headerlink" href="#_161" title="Permanent link">&para;</a></h6>
<h6 id="getelem_1">注意因为插入操作和GetElem操作不同<a class="headerlink" href="#getelem_1" title="Permanent link">&para;</a></h6>
<h6 id="0-pl_1">要从 0 开始，p要从L开始<a class="headerlink" href="#0-pl_1" title="Permanent link">&para;</a></h6>
<h6 id="1-l-1_1">如果从 1 和L开始的话，无法再位置 1 插入元素<a class="headerlink" href="#1-l-1_1" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-27-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-27-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-27-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-27-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-27-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-27-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-27-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-27-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-27-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-27-10">10</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-27-1" name="__codelineno-27-1"></a>Status LlInsert(LinkList L, int position, LlElemtype e) {
<a id="__codelineno-27-2" name="__codelineno-27-2"></a>LinkList p = L; //注意因为插入操作和GetElem操作不同
<a id="__codelineno-27-3" name="__codelineno-27-3"></a>int i = 0 ; // i要从 0 开始，p要从L开始
<a id="__codelineno-27-4" name="__codelineno-27-4"></a>//如果从 1 和L开始的话，无法再位置 1 插入元素
<a id="__codelineno-27-5" name="__codelineno-27-5"></a>while (p &amp;&amp; i &lt; position - 1 ) { //查找插入节点位置的前一个节点
<a id="__codelineno-27-6" name="__codelineno-27-6"></a>i++;
<a id="__codelineno-27-7" name="__codelineno-27-7"></a>p = p-&gt;next;
<a id="__codelineno-27-8" name="__codelineno-27-8"></a>}
<a id="__codelineno-27-9" name="__codelineno-27-9"></a>if (!p || i &gt; position - 1 )
<a id="__codelineno-27-10" name="__codelineno-27-10"></a>return ERROR;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-28-1">1</a></span>
<span class="normal"><a href="#__codelineno-28-2">2</a></span>
<span class="normal"><a href="#__codelineno-28-3">3</a></span>
<span class="normal"><a href="#__codelineno-28-4">4</a></span>
<span class="normal"><a href="#__codelineno-28-5">5</a></span>
<span class="normal"><a href="#__codelineno-28-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-28-1" name="__codelineno-28-1"></a>LinkList pnew = (LinkList)malloc(sizeof(LNode));
<a id="__codelineno-28-2" name="__codelineno-28-2"></a>pnew-&gt;data = e;
<a id="__codelineno-28-3" name="__codelineno-28-3"></a>pnew-&gt;next = p-&gt;next;
<a id="__codelineno-28-4" name="__codelineno-28-4"></a>p-&gt;next = pnew;
<a id="__codelineno-28-5" name="__codelineno-28-5"></a>return OK;
<a id="__codelineno-28-6" name="__codelineno-28-6"></a>}
</code></pre></div></td></tr></table></div></p>
<h4 id="_162">总结插入和删除操作算法的不同<a class="headerlink" href="#_162" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-29-1">1</a></span>
<span class="normal"><a href="#__codelineno-29-2">2</a></span>
<span class="normal"><a href="#__codelineno-29-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-29-1" name="__codelineno-29-1"></a>Status LlDelete(LinkList L, int position, LlElemtype *e) {
<a id="__codelineno-29-2" name="__codelineno-29-2"></a>LinkList p = L;
<a id="__codelineno-29-3" name="__codelineno-29-3"></a>int i = 0 ;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-30-1">1</a></span>
<span class="normal"><a href="#__codelineno-30-2">2</a></span>
<span class="normal"><a href="#__codelineno-30-3">3</a></span>
<span class="normal"><a href="#__codelineno-30-4">4</a></span>
<span class="normal"><a href="#__codelineno-30-5">5</a></span>
<span class="normal"><a href="#__codelineno-30-6">6</a></span>
<span class="normal"><a href="#__codelineno-30-7">7</a></span>
<span class="normal"><a href="#__codelineno-30-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-30-1" name="__codelineno-30-1"></a>while (p &amp;&amp; i &lt; position - 1 ) {
<a id="__codelineno-30-2" name="__codelineno-30-2"></a>//查找posision-1位置节点的地址
<a id="__codelineno-30-3" name="__codelineno-30-3"></a>i++;
<a id="__codelineno-30-4" name="__codelineno-30-4"></a>p = p-&gt;next;
<a id="__codelineno-30-5" name="__codelineno-30-5"></a>}
<a id="__codelineno-30-6" name="__codelineno-30-6"></a>if (i &gt; position - 1 || !p || !p-&gt;next)
<a id="__codelineno-30-7" name="__codelineno-30-7"></a>return ERROR;
<a id="__codelineno-30-8" name="__codelineno-30-8"></a>//注意是 多增加了判断条件!(p-&gt;next) 当节点数为n，删除的位置为n+1时会返回error
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-31-1">1</a></span>
<span class="normal"><a href="#__codelineno-31-2">2</a></span>
<span class="normal"><a href="#__codelineno-31-3">3</a></span>
<span class="normal"><a href="#__codelineno-31-4">4</a></span>
<span class="normal"><a href="#__codelineno-31-5">5</a></span>
<span class="normal"><a href="#__codelineno-31-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-31-1" name="__codelineno-31-1"></a>LinkList pfree = p-&gt;next;
<a id="__codelineno-31-2" name="__codelineno-31-2"></a>*e = pfree-&gt;data;
<a id="__codelineno-31-3" name="__codelineno-31-3"></a>p-&gt;next = pfree-&gt;next; //此处可改写成 p-&gt;next = p-&gt;next-&gt;next;
<a id="__codelineno-31-4" name="__codelineno-31-4"></a>free(pfree);
<a id="__codelineno-31-5" name="__codelineno-31-5"></a>return OK;
<a id="__codelineno-31-6" name="__codelineno-31-6"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-32-1">1</a></span>
<span class="normal"><a href="#__codelineno-32-2">2</a></span>
<span class="normal"><a href="#__codelineno-32-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-32-1" name="__codelineno-32-1"></a>while (p){
<a id="__codelineno-32-2" name="__codelineno-32-2"></a>p = p-&gt;next;
<a id="__codelineno-32-3" name="__codelineno-32-3"></a>}//最终p的值为NULL
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-33-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-33-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-33-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-33-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-33-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-33-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-33-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-33-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-33-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-33-10">10</a></span>
<span class="normal"><a href="#__codelineno-33-11">11</a></span>
<span class="normal"><a href="#__codelineno-33-12">12</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-33-1" name="__codelineno-33-1"></a>while(p-&gt;next){
<a id="__codelineno-33-2" name="__codelineno-33-2"></a>p = p-&gt;next;
<a id="__codelineno-33-3" name="__codelineno-33-3"></a>}//最终p的值为最后一个节点的地址
<a id="__codelineno-33-4" name="__codelineno-33-4"></a>//---------------------插入----------------------
<a id="__codelineno-33-5" name="__codelineno-33-5"></a>//如果插入操作的position不合法，即position &gt; n+1(n为链表长度)，那么p一定会指向NULL，此时按照
<a id="__codelineno-33-6" name="__codelineno-33-6"></a>退出条件!p可以返回ERROR
<a id="__codelineno-33-7" name="__codelineno-33-7"></a>if (!p || i&gt;position- 1 ) return ERROR;
<a id="__codelineno-33-8" name="__codelineno-33-8"></a>//但是如果采用:
<a id="__codelineno-33-9" name="__codelineno-33-9"></a>while(p-&gt;next)
<a id="__codelineno-33-10" name="__codelineno-33-10"></a>//则最终会指向链表最后一个节点，即使position不合法，那么也会在最后一个节点后方插入新节点
<a id="__codelineno-33-11" name="__codelineno-33-11"></a>//所以使用:
<a id="__codelineno-33-12" name="__codelineno-33-12"></a>while(p)
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-34-1">1</a></span>
<span class="normal"><a href="#__codelineno-34-2">2</a></span>
<span class="normal"><a href="#__codelineno-34-3">3</a></span>
<span class="normal"><a href="#__codelineno-34-4">4</a></span>
<span class="normal"><a href="#__codelineno-34-5">5</a></span>
<span class="normal"><a href="#__codelineno-34-6">6</a></span>
<span class="normal"><a href="#__codelineno-34-7">7</a></span>
<span class="normal"><a href="#__codelineno-34-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-34-1" name="__codelineno-34-1"></a>////---------------------删除----------------------
<a id="__codelineno-34-2" name="__codelineno-34-2"></a>//如果删除操作的positoin不合法，即position&gt;链表长度，p会指向，最后一个节点的地址(position ==
<a id="__codelineno-34-3" name="__codelineno-34-3"></a>n+1时)或是NULL(position &gt; n+1)，那么下面的代码会出错
<a id="__codelineno-34-4" name="__codelineno-34-4"></a>LinkList pfree = p-&gt;next;
<a id="__codelineno-34-5" name="__codelineno-34-5"></a>//如果p指向最后一个节点，此时pfree指向NULL。如果p指向NULL，此时pfree指向非法空间(不受主程序控
<a id="__codelineno-34-6" name="__codelineno-34-6"></a>制)，从而导致下面代码报错
<a id="__codelineno-34-7" name="__codelineno-34-7"></a>*e = pfree-&gt;data;
<a id="__codelineno-34-8" name="__codelineno-34-8"></a>//所以需要增加一个判断条件
</code></pre></div></td></tr></table></div></p>
<h4 id="_163">销毁链表<a class="headerlink" href="#_163" title="Permanent link">&para;</a></h4>
<h4 id="_164">单链表头文件<a class="headerlink" href="#_164" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-35-1">1</a></span>
<span class="normal"><a href="#__codelineno-35-2">2</a></span>
<span class="normal"><a href="#__codelineno-35-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-35-1" name="__codelineno-35-1"></a>if (i&gt;position- 1 || !p || !p-&gt;next) return ERROR;
<a id="__codelineno-35-2" name="__codelineno-35-2"></a>//必须保证 !p 要在 !p-&gt;next的左边，即position &gt; n+1 的情况
<a id="__codelineno-35-3" name="__codelineno-35-3"></a>//这是因为如果 !p-&gt;next 在 !p 的左边，如果p指向NULL，那么NULL-&gt;next会报错
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-36-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-36-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-36-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-36-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-36-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-36-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-36-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-36-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-36-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-36-10">10</a></span>
<span class="normal"><a href="#__codelineno-36-11">11</a></span>
<span class="normal"><a href="#__codelineno-36-12">12</a></span>
<span class="normal"><a href="#__codelineno-36-13">13</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-36-1" name="__codelineno-36-1"></a>Status LlDestroy(LinkList *L) {
<a id="__codelineno-36-2" name="__codelineno-36-2"></a>if (!(*L))
<a id="__codelineno-36-3" name="__codelineno-36-3"></a>return ERROR;
<a id="__codelineno-36-4" name="__codelineno-36-4"></a>LinkList p = *L;
<a id="__codelineno-36-5" name="__codelineno-36-5"></a>while (p) {
<a id="__codelineno-36-6" name="__codelineno-36-6"></a>LinkList pfree = p; // pfree保存要释放的节点地址
<a id="__codelineno-36-7" name="__codelineno-36-7"></a>p = p-&gt;next; //此行和下行的顺序不能反
<a id="__codelineno-36-8" name="__codelineno-36-8"></a>free(pfree);
<a id="__codelineno-36-9" name="__codelineno-36-9"></a>pfree = NULL;
<a id="__codelineno-36-10" name="__codelineno-36-10"></a>}
<a id="__codelineno-36-11" name="__codelineno-36-11"></a>*L = NULL;
<a id="__codelineno-36-12" name="__codelineno-36-12"></a>return OK;
<a id="__codelineno-36-13" name="__codelineno-36-13"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-37-1">1</a></span>
<span class="normal"><a href="#__codelineno-37-2">2</a></span>
<span class="normal"><a href="#__codelineno-37-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-37-1" name="__codelineno-37-1"></a>#include &quot;define.h&quot;
<a id="__codelineno-37-2" name="__codelineno-37-2"></a>#include &lt;stdio.h&gt;
<a id="__codelineno-37-3" name="__codelineno-37-3"></a>#include &lt;stdlib.h&gt;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-38-1">1</a></span>
<span class="normal"><a href="#__codelineno-38-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-38-1" name="__codelineno-38-1"></a>#ifndef __LINKLIST_H
<a id="__codelineno-38-2" name="__codelineno-38-2"></a>#define __LINKLIST_H
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-39-1">1</a></span>
<span class="normal"><a href="#__codelineno-39-2">2</a></span>
<span class="normal"><a href="#__codelineno-39-3">3</a></span>
<span class="normal"><a href="#__codelineno-39-4">4</a></span>
<span class="normal"><a href="#__codelineno-39-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-39-1" name="__codelineno-39-1"></a>typedef int LlElemtype;
<a id="__codelineno-39-2" name="__codelineno-39-2"></a>typedef struct __LNode {
<a id="__codelineno-39-3" name="__codelineno-39-3"></a>LlElemtype data; //存放单个节点的数据
<a id="__codelineno-39-4" name="__codelineno-39-4"></a>__LNode *next; //存放下个节点的地址
<a id="__codelineno-39-5" name="__codelineno-39-5"></a>} LNode, *LinkList;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-40-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-40-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-40-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-40-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-40-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-40-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-40-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-40-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-40-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-40-10">10</a></span>
<span class="normal"><a href="#__codelineno-40-11">11</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-40-1" name="__codelineno-40-1"></a>Status InitLL(LinkList *L);
<a id="__codelineno-40-2" name="__codelineno-40-2"></a>void CreatLL_H(LinkList L, int n);
<a id="__codelineno-40-3" name="__codelineno-40-3"></a>void CreatLL_R(LinkList L, int n);
<a id="__codelineno-40-4" name="__codelineno-40-4"></a>Status GetElem(LinkList L, int position, LlElemtype *e);
<a id="__codelineno-40-5" name="__codelineno-40-5"></a>LinkList LocateElem(LinkList L, LlElemtype e);
<a id="__codelineno-40-6" name="__codelineno-40-6"></a>Status LlInsert(LinkList L, int position, LlElemtype e);
<a id="__codelineno-40-7" name="__codelineno-40-7"></a>Status LlDelete(LinkList L, int position, LlElemtype *e);
<a id="__codelineno-40-8" name="__codelineno-40-8"></a>void Traverse(LinkList L);
<a id="__codelineno-40-9" name="__codelineno-40-9"></a>Status LlDestroy(LinkList *L);
<a id="__codelineno-40-10" name="__codelineno-40-10"></a>void Merge_LinkedList(LinkList *La, LinkList *Lb, LinkList *Lc);
<a id="__codelineno-40-11" name="__codelineno-40-11"></a>#endif
</code></pre></div></td></tr></table></div></p>
<h3 id="circular-linked-list_1">循环链表(Circular Linked List)<a class="headerlink" href="#circular-linked-list_1" title="Permanent link">&para;</a></h3>
<h6 id="_165">循环链表的特点：<a class="headerlink" href="#_165" title="Permanent link">&para;</a></h6>
<h6 id="_166">最后一个节点的指针域指向头节点，整个表链形成一个环<a class="headerlink" href="#_166" title="Permanent link">&para;</a></h6>
<h6 id="_167">由此，从表中任意节点出发，可以找到其他节点<a class="headerlink" href="#_167" title="Permanent link">&para;</a></h6>
<h6 id="next_1">和单链表很像，区别就是最后一个节点的next域指向头节点<a class="headerlink" href="#next_1" title="Permanent link">&para;</a></h6>
<h3 id="double-linked-list_1">双向链表(Double Linked List)<a class="headerlink" href="#double-linked-list_1" title="Permanent link">&para;</a></h3>
<h6 id="_168">有两个指针域，一个指向直接前驱，另一个指向直接后继<a class="headerlink" href="#_168" title="Permanent link">&para;</a></h6>
<h6 id="_169">数据类型<a class="headerlink" href="#_169" title="Permanent link">&para;</a></h6>
<h4 id="_170">初始化<a class="headerlink" href="#_170" title="Permanent link">&para;</a></h4>
<h4 id="_171">创建双向链表<a class="headerlink" href="#_171" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-41-1">1</a></span>
<span class="normal"><a href="#__codelineno-41-2">2</a></span>
<span class="normal"><a href="#__codelineno-41-3">3</a></span>
<span class="normal"><a href="#__codelineno-41-4">4</a></span>
<span class="normal"><a href="#__codelineno-41-5">5</a></span>
<span class="normal"><a href="#__codelineno-41-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-41-1" name="__codelineno-41-1"></a>typedef int DouLElemtype;
<a id="__codelineno-41-2" name="__codelineno-41-2"></a>typedef struct __DouLinkNode {
<a id="__codelineno-41-3" name="__codelineno-41-3"></a>DouLElemtype data;
<a id="__codelineno-41-4" name="__codelineno-41-4"></a>__DouLinkNode *prior;
<a id="__codelineno-41-5" name="__codelineno-41-5"></a>__DouLinkNode *next;
<a id="__codelineno-41-6" name="__codelineno-41-6"></a>} DouLinkNode, *DouLinkList;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-42-1">1</a></span>
<span class="normal"><a href="#__codelineno-42-2">2</a></span>
<span class="normal"><a href="#__codelineno-42-3">3</a></span>
<span class="normal"><a href="#__codelineno-42-4">4</a></span>
<span class="normal"><a href="#__codelineno-42-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-42-1" name="__codelineno-42-1"></a>void InitDL(DouLinkList *L) {
<a id="__codelineno-42-2" name="__codelineno-42-2"></a>*L = (DouLinkList)malloc(sizeof(DouLinkNode));
<a id="__codelineno-42-3" name="__codelineno-42-3"></a>(*L)-&gt;next = NULL;
<a id="__codelineno-42-4" name="__codelineno-42-4"></a>(*L)-&gt;prior = NULL;
<a id="__codelineno-42-5" name="__codelineno-42-5"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-43-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-43-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-43-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-43-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-43-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-43-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-43-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-43-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-43-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-43-10">10</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-43-1" name="__codelineno-43-1"></a>void CreatDL_H(DouLinkList L, int length) {
<a id="__codelineno-43-2" name="__codelineno-43-2"></a>for (int i = 0 ; i &lt; length; i++) {
<a id="__codelineno-43-3" name="__codelineno-43-3"></a>DouLinkList pnew = (DouLinkList)malloc(sizeof(DouLinkNode));
<a id="__codelineno-43-4" name="__codelineno-43-4"></a>int data;
<a id="__codelineno-43-5" name="__codelineno-43-5"></a>printf(&quot;(for %d)Please input the data:&quot;, i + 1 );
<a id="__codelineno-43-6" name="__codelineno-43-6"></a>scanf(&quot;%d&quot;, &amp;data);
<a id="__codelineno-43-7" name="__codelineno-43-7"></a>pnew-&gt;data = data;
<a id="__codelineno-43-8" name="__codelineno-43-8"></a>pnew-&gt;next = L-&gt;next;
<a id="__codelineno-43-9" name="__codelineno-43-9"></a>pnew-&gt;prior = L;
<a id="__codelineno-43-10" name="__codelineno-43-10"></a>L-&gt;next = pnew;
</code></pre></div></td></tr></table></div></p>
<h4 id="_172">插入和删除<a class="headerlink" href="#_172" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-44-1">1</a></span>
<span class="normal"><a href="#__codelineno-44-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-44-1" name="__codelineno-44-1"></a>}
<a id="__codelineno-44-2" name="__codelineno-44-2"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-45-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-45-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-45-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-45-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-45-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-45-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-45-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-45-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-45-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-45-10">10</a></span>
<span class="normal"><a href="#__codelineno-45-11">11</a></span>
<span class="normal"><a href="#__codelineno-45-12">12</a></span>
<span class="normal"><a href="#__codelineno-45-13">13</a></span>
<span class="normal"><a href="#__codelineno-45-14">14</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-45-1" name="__codelineno-45-1"></a>void CreatDL_R(DouLinkList L, int length) {
<a id="__codelineno-45-2" name="__codelineno-45-2"></a>DouLinkList ptail = L;
<a id="__codelineno-45-3" name="__codelineno-45-3"></a>for (int i = 0 ; i &lt; length; i++) {
<a id="__codelineno-45-4" name="__codelineno-45-4"></a>DouLinkList pnew = (DouLinkList)malloc(sizeof(DouLinkNode));
<a id="__codelineno-45-5" name="__codelineno-45-5"></a>int data;
<a id="__codelineno-45-6" name="__codelineno-45-6"></a>printf(&quot;(for %d)Please input the data:&quot;, i + 1 );
<a id="__codelineno-45-7" name="__codelineno-45-7"></a>scanf(&quot;%d&quot;, &amp;data);
<a id="__codelineno-45-8" name="__codelineno-45-8"></a>pnew-&gt;data = data;
<a id="__codelineno-45-9" name="__codelineno-45-9"></a>pnew-&gt;next = NULL;
<a id="__codelineno-45-10" name="__codelineno-45-10"></a>pnew-&gt;prior = ptail;
<a id="__codelineno-45-11" name="__codelineno-45-11"></a>ptail-&gt;next = pnew;
<a id="__codelineno-45-12" name="__codelineno-45-12"></a>ptail = pnew;
<a id="__codelineno-45-13" name="__codelineno-45-13"></a>}
<a id="__codelineno-45-14" name="__codelineno-45-14"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-46-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-46-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-46-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-46-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-46-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-46-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-46-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-46-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-46-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-46-10">10</a></span>
<span class="normal"><a href="#__codelineno-46-11">11</a></span>
<span class="normal"><a href="#__codelineno-46-12">12</a></span>
<span class="normal"><a href="#__codelineno-46-13">13</a></span>
<span class="normal"><a href="#__codelineno-46-14">14</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-46-1" name="__codelineno-46-1"></a>void DlInsert(DouLinkList L, int position, DouLElemtype e) {
<a id="__codelineno-46-2" name="__codelineno-46-2"></a>int i = 0 ;
<a id="__codelineno-46-3" name="__codelineno-46-3"></a>DouLinkList p = L;
<a id="__codelineno-46-4" name="__codelineno-46-4"></a>while (p-&gt;next &amp;&amp; i &lt; position - 1 ) {
<a id="__codelineno-46-5" name="__codelineno-46-5"></a>i++;
<a id="__codelineno-46-6" name="__codelineno-46-6"></a>p = p-&gt;next;
<a id="__codelineno-46-7" name="__codelineno-46-7"></a>}
<a id="__codelineno-46-8" name="__codelineno-46-8"></a>DouLinkList pnew = (DouLinkList)malloc(sizeof(DouLinkNode));
<a id="__codelineno-46-9" name="__codelineno-46-9"></a>pnew-&gt;data = e;
<a id="__codelineno-46-10" name="__codelineno-46-10"></a>pnew-&gt;next = p-&gt;next;
<a id="__codelineno-46-11" name="__codelineno-46-11"></a>pnew-&gt;prior = p;
<a id="__codelineno-46-12" name="__codelineno-46-12"></a>p-&gt;next = pnew;
<a id="__codelineno-46-13" name="__codelineno-46-13"></a>p-&gt;next-&gt;prior = pnew;
<a id="__codelineno-46-14" name="__codelineno-46-14"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-47-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-47-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-47-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-47-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-47-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-47-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-47-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-47-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-47-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-47-10">10</a></span>
<span class="normal"><a href="#__codelineno-47-11">11</a></span>
<span class="normal"><a href="#__codelineno-47-12">12</a></span>
<span class="normal"><a href="#__codelineno-47-13">13</a></span>
<span class="normal"><a href="#__codelineno-47-14">14</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-47-1" name="__codelineno-47-1"></a>void DlDelete(DouLinkList L, int position, DouLElemtype *e) {
<a id="__codelineno-47-2" name="__codelineno-47-2"></a>DouLinkList p = L;
<a id="__codelineno-47-3" name="__codelineno-47-3"></a>int i = 0 ;
<a id="__codelineno-47-4" name="__codelineno-47-4"></a>while (p-&gt;next &amp;&amp; i &lt; position - 1 ) {
<a id="__codelineno-47-5" name="__codelineno-47-5"></a>p = p-&gt;next;
<a id="__codelineno-47-6" name="__codelineno-47-6"></a>i++;
<a id="__codelineno-47-7" name="__codelineno-47-7"></a>}
<a id="__codelineno-47-8" name="__codelineno-47-8"></a>DouLinkList pfree = p-&gt;next;
<a id="__codelineno-47-9" name="__codelineno-47-9"></a>*e = pfree-&gt;data;
<a id="__codelineno-47-10" name="__codelineno-47-10"></a>p-&gt;next = p-&gt;next-&gt;next;
<a id="__codelineno-47-11" name="__codelineno-47-11"></a>p-&gt;next-&gt;next-&gt;prior = p;
<a id="__codelineno-47-12" name="__codelineno-47-12"></a>free(pfree);
<a id="__codelineno-47-13" name="__codelineno-47-13"></a>pfree = NULL;
<a id="__codelineno-47-14" name="__codelineno-47-14"></a>}
</code></pre></div></td></tr></table></div></p>
<h3 id="_173">线性表玩具<a class="headerlink" href="#_173" title="Permanent link">&para;</a></h3>
<h4 id="_174">线性表合并<a class="headerlink" href="#_174" title="Permanent link">&para;</a></h4>
<h6 id="_175">已知两个集合<a class="headerlink" href="#_175" title="Permanent link">&para;</a></h6>
<h6 id="_176">求出合并后集合<a class="headerlink" href="#_176" title="Permanent link">&para;</a></h6>
<h4 id="_177">有序表合并(并归排序的基础)<a class="headerlink" href="#_177" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-48-1">1</a></span>
<span class="normal"><a href="#__codelineno-48-2">2</a></span>
<span class="normal"><a href="#__codelineno-48-3">3</a></span>
<span class="normal"><a href="#__codelineno-48-4">4</a></span>
<span class="normal"><a href="#__codelineno-48-5">5</a></span>
<span class="normal"><a href="#__codelineno-48-6">6</a></span>
<span class="normal"><a href="#__codelineno-48-7">7</a></span>
<span class="normal"><a href="#__codelineno-48-8">8</a></span>
<span class="normal"><a href="#__codelineno-48-9">9</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-48-1" name="__codelineno-48-1"></a>void MergeList(Sqlist *La, Sqlist *Lb) {
<a id="__codelineno-48-2" name="__codelineno-48-2"></a>for (int i = 1 ; i &lt; Lb-&gt;length + 1 ; i++) {
<a id="__codelineno-48-3" name="__codelineno-48-3"></a>SqlElemType e;
<a id="__codelineno-48-4" name="__codelineno-48-4"></a>GetElem(Lb, i, &amp;e);
<a id="__codelineno-48-5" name="__codelineno-48-5"></a>if (!LocateElem(La, e)) {
<a id="__codelineno-48-6" name="__codelineno-48-6"></a>La-&gt;base[La-&gt;length++] = e;
<a id="__codelineno-48-7" name="__codelineno-48-7"></a>}
<a id="__codelineno-48-8" name="__codelineno-48-8"></a>}
<a id="__codelineno-48-9" name="__codelineno-48-9"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-49-1">1</a></span>
<span class="normal"><a href="#__codelineno-49-2">2</a></span>
<span class="normal"><a href="#__codelineno-49-3">3</a></span>
<span class="normal"><a href="#__codelineno-49-4">4</a></span>
<span class="normal"><a href="#__codelineno-49-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-49-1" name="__codelineno-49-1"></a>void Traverse(Sqlist *L) {
<a id="__codelineno-49-2" name="__codelineno-49-2"></a>for (int i = 0 ; i &lt; L-&gt;length; i++) {
<a id="__codelineno-49-3" name="__codelineno-49-3"></a>printf(&quot;%d &quot;, L-&gt;base[i]);
<a id="__codelineno-49-4" name="__codelineno-49-4"></a>}
<a id="__codelineno-49-5" name="__codelineno-49-5"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-50-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-50-1" name="__codelineno-50-1"></a>#include &lt;SequenceList.h&gt;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-51-1">1</a></span>
<span class="normal"><a href="#__codelineno-51-2">2</a></span>
<span class="normal"><a href="#__codelineno-51-3">3</a></span>
<span class="normal"><a href="#__codelineno-51-4">4</a></span>
<span class="normal"><a href="#__codelineno-51-5">5</a></span>
<span class="normal"><a href="#__codelineno-51-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-51-1" name="__codelineno-51-1"></a>int main(void) {
<a id="__codelineno-51-2" name="__codelineno-51-2"></a>Sqlist La, Lb;
<a id="__codelineno-51-3" name="__codelineno-51-3"></a>Sqlist *pa = &amp;La;
<a id="__codelineno-51-4" name="__codelineno-51-4"></a>Sqlist *pb = &amp;Lb;
<a id="__codelineno-51-5" name="__codelineno-51-5"></a>InitSL(pa, 4 );
<a id="__codelineno-51-6" name="__codelineno-51-6"></a>InitSL(pb, 3 );
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-52-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-52-1" name="__codelineno-52-1"></a>MergeList(pa, pb);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-53-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-53-1" name="__codelineno-53-1"></a>Traverse(pa);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-54-1">1</a></span>
<span class="normal"><a href="#__codelineno-54-2">2</a></span>
<span class="normal"><a href="#__codelineno-54-3">3</a></span>
<span class="normal"><a href="#__codelineno-54-4">4</a></span>
<span class="normal"><a href="#__codelineno-54-5">5</a></span>
<span class="normal"><a href="#__codelineno-54-6">6</a></span>
<span class="normal"><a href="#__codelineno-54-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-54-1" name="__codelineno-54-1"></a>system(&quot;pause&quot;);
<a id="__codelineno-54-2" name="__codelineno-54-2"></a>return 0 ;
<a id="__codelineno-54-3" name="__codelineno-54-3"></a>}
<a id="__codelineno-54-4" name="__codelineno-54-4"></a>/*
<a id="__codelineno-54-5" name="__codelineno-54-5"></a>7 5 3 11
<a id="__codelineno-54-6" name="__codelineno-54-6"></a>2 6 3
<a id="__codelineno-54-7" name="__codelineno-54-7"></a>*/
</code></pre></div></td></tr></table></div></p>
<h6 id="_178">合并成新集合<a class="headerlink" href="#_178" title="Permanent link">&para;</a></h6>
<h4 id="_179">有序链表合并<a class="headerlink" href="#_179" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-55-1">1</a></span>
<span class="normal"><a href="#__codelineno-55-2">2</a></span>
<span class="normal"><a href="#__codelineno-55-3">3</a></span>
<span class="normal"><a href="#__codelineno-55-4">4</a></span>
<span class="normal"><a href="#__codelineno-55-5">5</a></span>
<span class="normal"><a href="#__codelineno-55-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-55-1" name="__codelineno-55-1"></a>void MergeList_Seq(Sqlist *La, Sqlist *Lb, Sqlist *Lc) {
<a id="__codelineno-55-2" name="__codelineno-55-2"></a>Lc-&gt;length = La-&gt;length + Lb-&gt;length;
<a id="__codelineno-55-3" name="__codelineno-55-3"></a>SqlElemType *pa = La-&gt;base, *pa_last = pa + La-&gt;length - 1 ;
<a id="__codelineno-55-4" name="__codelineno-55-4"></a>// pa指向La-&gt;base的首地址，pa_last指向base中最后一个元素的地址，下面同理
<a id="__codelineno-55-5" name="__codelineno-55-5"></a>SqlElemType *pb = Lb-&gt;base, *pb_last = pb + Lb-&gt;length - 1 ;
<a id="__codelineno-55-6" name="__codelineno-55-6"></a>SqlElemType *pc = Lc-&gt;base;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-56-1">1</a></span>
<span class="normal"><a href="#__codelineno-56-2">2</a></span>
<span class="normal"><a href="#__codelineno-56-3">3</a></span>
<span class="normal"><a href="#__codelineno-56-4">4</a></span>
<span class="normal"><a href="#__codelineno-56-5">5</a></span>
<span class="normal"><a href="#__codelineno-56-6">6</a></span>
<span class="normal"><a href="#__codelineno-56-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-56-1" name="__codelineno-56-1"></a>while (pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last) {
<a id="__codelineno-56-2" name="__codelineno-56-2"></a>//当pa&gt;pa_last时说明，有集合中的元素已经全部加入到Lc中
<a id="__codelineno-56-3" name="__codelineno-56-3"></a>if (*pa &lt; *pb)
<a id="__codelineno-56-4" name="__codelineno-56-4"></a>*(pc++) = *(pa++);
<a id="__codelineno-56-5" name="__codelineno-56-5"></a>else
<a id="__codelineno-56-6" name="__codelineno-56-6"></a>*(pc++) = *(pb++);
<a id="__codelineno-56-7" name="__codelineno-56-7"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-57-1">1</a></span>
<span class="normal"><a href="#__codelineno-57-2">2</a></span>
<span class="normal"><a href="#__codelineno-57-3">3</a></span>
<span class="normal"><a href="#__codelineno-57-4">4</a></span>
<span class="normal"><a href="#__codelineno-57-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-57-1" name="__codelineno-57-1"></a>while (pa &lt;= pa_last)
<a id="__codelineno-57-2" name="__codelineno-57-2"></a>*(pc++) = *(pa++); //判断La的元素是否全部加入Lc中，下面同理
<a id="__codelineno-57-3" name="__codelineno-57-3"></a>while (pb &lt;= pb_last)
<a id="__codelineno-57-4" name="__codelineno-57-4"></a>*(pc++) = *(pb++);
<a id="__codelineno-57-5" name="__codelineno-57-5"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-58-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-58-1" name="__codelineno-58-1"></a>#include &lt;SequenceList.h&gt;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-59-1">1</a></span>
<span class="normal"><a href="#__codelineno-59-2">2</a></span>
<span class="normal"><a href="#__codelineno-59-3">3</a></span>
<span class="normal"><a href="#__codelineno-59-4">4</a></span>
<span class="normal"><a href="#__codelineno-59-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-59-1" name="__codelineno-59-1"></a>int main(void) {
<a id="__codelineno-59-2" name="__codelineno-59-2"></a>Sqlist La, Lb, Lc;
<a id="__codelineno-59-3" name="__codelineno-59-3"></a>InitSL(&amp;La, 4 );
<a id="__codelineno-59-4" name="__codelineno-59-4"></a>InitSL(&amp;Lb, 7 );
<a id="__codelineno-59-5" name="__codelineno-59-5"></a>InitSL(&amp;Lc, 0 );
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-60-1">1</a></span>
<span class="normal"><a href="#__codelineno-60-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-60-1" name="__codelineno-60-1"></a>MergeList_Seq(&amp;La, &amp;Lb, &amp;Lc);
<a id="__codelineno-60-2" name="__codelineno-60-2"></a>Traverse(&amp;Lc);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-61-1">1</a></span>
<span class="normal"><a href="#__codelineno-61-2">2</a></span>
<span class="normal"><a href="#__codelineno-61-3">3</a></span>
<span class="normal"><a href="#__codelineno-61-4">4</a></span>
<span class="normal"><a href="#__codelineno-61-5">5</a></span>
<span class="normal"><a href="#__codelineno-61-6">6</a></span>
<span class="normal"><a href="#__codelineno-61-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-61-1" name="__codelineno-61-1"></a>system(&quot;pause&quot;);
<a id="__codelineno-61-2" name="__codelineno-61-2"></a>return 0 ;
<a id="__codelineno-61-3" name="__codelineno-61-3"></a>}
<a id="__codelineno-61-4" name="__codelineno-61-4"></a>/*
<a id="__codelineno-61-5" name="__codelineno-61-5"></a>3 5 8 11
<a id="__codelineno-61-6" name="__codelineno-61-6"></a>2 6 8 9 11 15 20
<a id="__codelineno-61-7" name="__codelineno-61-7"></a>*/
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-62-1">1</a></span>
<span class="normal"><a href="#__codelineno-62-2">2</a></span>
<span class="normal"><a href="#__codelineno-62-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-62-1" name="__codelineno-62-1"></a>void Merge_LinkedList(LinkList *La, LinkList *Lb, LinkList *Lc) {
<a id="__codelineno-62-2" name="__codelineno-62-2"></a>*Lc = *La; //让Lc使用La的头节点进行合并
<a id="__codelineno-62-3" name="__codelineno-62-3"></a>LinkList pa = (*La)-&gt;next, pb = (*Lb)-&gt;next; // pa, pb分别表示合并时所指节点
</code></pre></div></td></tr></table></div></p>
<h4 id="and_1">多项式创建 and 多项式相加<a class="headerlink" href="#and_1" title="Permanent link">&para;</a></h4>
<h6 id="_180">创建一个多项式，并按照指数的高低排序<a class="headerlink" href="#_180" title="Permanent link">&para;</a></h6>
<h6 id="_181">多项式结构体<a class="headerlink" href="#_181" title="Permanent link">&para;</a></h6>
<h6 id="_182">多项式创建<a class="headerlink" href="#_182" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-63-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-63-1" name="__codelineno-63-1"></a>LinkList pc = *Lc; // pc表示Lc的尾节点
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-64-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-64-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-64-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-64-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-64-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-64-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-64-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-64-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-64-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-64-10">10</a></span>
<span class="normal"><a href="#__codelineno-64-11">11</a></span>
<span class="normal"><a href="#__codelineno-64-12">12</a></span>
<span class="normal"><a href="#__codelineno-64-13">13</a></span>
<span class="normal"><a href="#__codelineno-64-14">14</a></span>
<span class="normal"><a href="#__codelineno-64-15">15</a></span>
<span class="normal"><a href="#__codelineno-64-16">16</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-64-1" name="__codelineno-64-1"></a>while (pa &amp;&amp; pb) {
<a id="__codelineno-64-2" name="__codelineno-64-2"></a>if (pa-&gt;data &lt; pb-&gt;data) {
<a id="__codelineno-64-3" name="__codelineno-64-3"></a>pc-&gt;next = pa;
<a id="__codelineno-64-4" name="__codelineno-64-4"></a>pc = pa;
<a id="__codelineno-64-5" name="__codelineno-64-5"></a>pa = pa-&gt;next;
<a id="__codelineno-64-6" name="__codelineno-64-6"></a>} else {
<a id="__codelineno-64-7" name="__codelineno-64-7"></a>pc-&gt;next = pb;
<a id="__codelineno-64-8" name="__codelineno-64-8"></a>pc = pb;
<a id="__codelineno-64-9" name="__codelineno-64-9"></a>pb = pb-&gt;next;
<a id="__codelineno-64-10" name="__codelineno-64-10"></a>}
<a id="__codelineno-64-11" name="__codelineno-64-11"></a>}
<a id="__codelineno-64-12" name="__codelineno-64-12"></a>pc-&gt;next = pa? pa : pb;
<a id="__codelineno-64-13" name="__codelineno-64-13"></a>// pc-&gt;next不需要NULL,因为合并时一定会剩下一串节点，只需指向该剩下的节点就OK
<a id="__codelineno-64-14" name="__codelineno-64-14"></a>free(*Lb);
<a id="__codelineno-64-15" name="__codelineno-64-15"></a>*La = *Lb = NULL;
<a id="__codelineno-64-16" name="__codelineno-64-16"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-65-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-65-1" name="__codelineno-65-1"></a>#include &quot;LinkList.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-66-1">1</a></span>
<span class="normal"><a href="#__codelineno-66-2">2</a></span>
<span class="normal"><a href="#__codelineno-66-3">3</a></span>
<span class="normal"><a href="#__codelineno-66-4">4</a></span>
<span class="normal"><a href="#__codelineno-66-5">5</a></span>
<span class="normal"><a href="#__codelineno-66-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-66-1" name="__codelineno-66-1"></a>int main(void) {
<a id="__codelineno-66-2" name="__codelineno-66-2"></a>LinkList La, Lb, Lc;
<a id="__codelineno-66-3" name="__codelineno-66-3"></a>InitLL(&amp;La), InitLL(&amp;Lb), InitLL(&amp;Lc);
<a id="__codelineno-66-4" name="__codelineno-66-4"></a>CreatLL_R(La, 4 );
<a id="__codelineno-66-5" name="__codelineno-66-5"></a>CreatLL_R(Lb, 7 );
<a id="__codelineno-66-6" name="__codelineno-66-6"></a>Merge_LinkedList(&amp;La, &amp;Lb, &amp;Lc);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-67-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-67-1" name="__codelineno-67-1"></a>Traverse(Lc);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-68-1">1</a></span>
<span class="normal"><a href="#__codelineno-68-2">2</a></span>
<span class="normal"><a href="#__codelineno-68-3">3</a></span>
<span class="normal"><a href="#__codelineno-68-4">4</a></span>
<span class="normal"><a href="#__codelineno-68-5">5</a></span>
<span class="normal"><a href="#__codelineno-68-6">6</a></span>
<span class="normal"><a href="#__codelineno-68-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-68-1" name="__codelineno-68-1"></a>system(&quot;pause&quot;);
<a id="__codelineno-68-2" name="__codelineno-68-2"></a>return 0 ;
<a id="__codelineno-68-3" name="__codelineno-68-3"></a>}
<a id="__codelineno-68-4" name="__codelineno-68-4"></a>/*
<a id="__codelineno-68-5" name="__codelineno-68-5"></a>3 5 8 11
<a id="__codelineno-68-6" name="__codelineno-68-6"></a>2 6 8 9 11 15 20
<a id="__codelineno-68-7" name="__codelineno-68-7"></a>*/
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-69-1">1</a></span>
<span class="normal"><a href="#__codelineno-69-2">2</a></span>
<span class="normal"><a href="#__codelineno-69-3">3</a></span>
<span class="normal"><a href="#__codelineno-69-4">4</a></span>
<span class="normal"><a href="#__codelineno-69-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-69-1" name="__codelineno-69-1"></a>typedef struct __PolyNode {
<a id="__codelineno-69-2" name="__codelineno-69-2"></a>double coeffcient;
<a id="__codelineno-69-3" name="__codelineno-69-3"></a>int exponent;
<a id="__codelineno-69-4" name="__codelineno-69-4"></a>__PolyNode *next;
<a id="__codelineno-69-5" name="__codelineno-69-5"></a>} PolyNode, *Polynomial;
</code></pre></div></td></tr></table></div></p>
<h6 id="polynomial-q-polynimial-pre">核心变量为 Polynomial q; Polynimial pre;<a class="headerlink" href="#polynomial-q-polynimial-pre" title="Permanent link">&para;</a></h6>
<h6 id="whileq-q-exponent-pnew-exponent">核心语句为 while(q &amp;&amp; q-&gt;exponent &lt; pnew-&gt;exponent)<a class="headerlink" href="#whileq-q-exponent-pnew-exponent" title="Permanent link">&para;</a></h6>
<h6 id="_183">主程序<a class="headerlink" href="#_183" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-70-1">1</a></span>
<span class="normal"><a href="#__codelineno-70-2">2</a></span>
<span class="normal"><a href="#__codelineno-70-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-70-1" name="__codelineno-70-1"></a>void InitPolynomial(Polynomial *p, int length) {
<a id="__codelineno-70-2" name="__codelineno-70-2"></a>*p = (Polynomial)malloc(sizeof(PolyNode)); //先初始化头节点
<a id="__codelineno-70-3" name="__codelineno-70-3"></a>(*p)-&gt;next = NULL;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-71-1">1</a></span>
<span class="normal"><a href="#__codelineno-71-2">2</a></span>
<span class="normal"><a href="#__codelineno-71-3">3</a></span>
<span class="normal"><a href="#__codelineno-71-4">4</a></span>
<span class="normal"><a href="#__codelineno-71-5">5</a></span>
<span class="normal"><a href="#__codelineno-71-6">6</a></span>
<span class="normal"><a href="#__codelineno-71-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-71-1" name="__codelineno-71-1"></a>printf(&quot;Please input the coefficient and exponent:&quot;);
<a id="__codelineno-71-2" name="__codelineno-71-2"></a>for (int i = 0 ; i &lt; length; i++) {
<a id="__codelineno-71-3" name="__codelineno-71-3"></a>Polynomial pnew = (Polynomial)malloc(sizeof(PolyNode));
<a id="__codelineno-71-4" name="__codelineno-71-4"></a>scanf(&quot; %lf&quot;, &amp;(pnew-&gt;coeffcient));
<a id="__codelineno-71-5" name="__codelineno-71-5"></a>scanf(&quot; %d&quot;, &amp;(pnew-&gt;exponent));
<a id="__codelineno-71-6" name="__codelineno-71-6"></a>Polynomial q = (*p)-&gt;next; // q为指向比pew-&gt;exponent大的节点
<a id="__codelineno-71-7" name="__codelineno-71-7"></a>Polynomial pre = (*p); // pre指向q的直接前驱节点
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-72-1">1</a></span>
<span class="normal"><a href="#__codelineno-72-2">2</a></span>
<span class="normal"><a href="#__codelineno-72-3">3</a></span>
<span class="normal"><a href="#__codelineno-72-4">4</a></span>
<span class="normal"><a href="#__codelineno-72-5">5</a></span>
<span class="normal"><a href="#__codelineno-72-6">6</a></span>
<span class="normal"><a href="#__codelineno-72-7">7</a></span>
<span class="normal"><a href="#__codelineno-72-8">8</a></span>
<span class="normal"><a href="#__codelineno-72-9">9</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-72-1" name="__codelineno-72-1"></a>while (q &amp;&amp; q-&gt;exponent &lt; pnew-&gt;exponent) { //第 1 次的for循环不会执行
<a id="__codelineno-72-2" name="__codelineno-72-2"></a>//直到找到一个节点的exponent大于pnew-&gt;exponent,如果没找到q指向NULL
<a id="__codelineno-72-3" name="__codelineno-72-3"></a>pre = q;
<a id="__codelineno-72-4" name="__codelineno-72-4"></a>q = q-&gt;next;
<a id="__codelineno-72-5" name="__codelineno-72-5"></a>}
<a id="__codelineno-72-6" name="__codelineno-72-6"></a>pnew-&gt;next = q; //因为q-&gt;exponent &gt; pnew-&gt;exponent
<a id="__codelineno-72-7" name="__codelineno-72-7"></a>pre-&gt;next = pnew;
<a id="__codelineno-72-8" name="__codelineno-72-8"></a>}
<a id="__codelineno-72-9" name="__codelineno-72-9"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-73-1">1</a></span>
<span class="normal"><a href="#__codelineno-73-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-73-1" name="__codelineno-73-1"></a>#include &lt;stdio.h&gt;
<a id="__codelineno-73-2" name="__codelineno-73-2"></a>#include &lt;stdlib.h&gt;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-74-1">1</a></span>
<span class="normal"><a href="#__codelineno-74-2">2</a></span>
<span class="normal"><a href="#__codelineno-74-3">3</a></span>
<span class="normal"><a href="#__codelineno-74-4">4</a></span>
<span class="normal"><a href="#__codelineno-74-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-74-1" name="__codelineno-74-1"></a>typedef struct __PolyNode {
<a id="__codelineno-74-2" name="__codelineno-74-2"></a>double coeffcient;
<a id="__codelineno-74-3" name="__codelineno-74-3"></a>int exponent;
<a id="__codelineno-74-4" name="__codelineno-74-4"></a>__PolyNode *next;
<a id="__codelineno-74-5" name="__codelineno-74-5"></a>} PolyNode, *Polynomial;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-75-1">1</a></span>
<span class="normal"><a href="#__codelineno-75-2">2</a></span>
<span class="normal"><a href="#__codelineno-75-3">3</a></span>
<span class="normal"><a href="#__codelineno-75-4">4</a></span>
<span class="normal"><a href="#__codelineno-75-5">5</a></span>
<span class="normal"><a href="#__codelineno-75-6">6</a></span>
<span class="normal"><a href="#__codelineno-75-7">7</a></span>
<span class="normal"><a href="#__codelineno-75-8">8</a></span>
<span class="normal"><a href="#__codelineno-75-9">9</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-75-1" name="__codelineno-75-1"></a>void InitPolynomial(Polynomial *p, int length);
<a id="__codelineno-75-2" name="__codelineno-75-2"></a>void Traverse(Polynomial P);
<a id="__codelineno-75-3" name="__codelineno-75-3"></a>Polynomial AddPolynomial(Polynomial pa, Polynomial pb);
<a id="__codelineno-75-4" name="__codelineno-75-4"></a>int main(void) {
<a id="__codelineno-75-5" name="__codelineno-75-5"></a>Polynomial p1, p2, p3;
<a id="__codelineno-75-6" name="__codelineno-75-6"></a>InitPolynomial(&amp;p1, 3 );
<a id="__codelineno-75-7" name="__codelineno-75-7"></a>InitPolynomial(&amp;p2, 4 );
<a id="__codelineno-75-8" name="__codelineno-75-8"></a>p3 = AddPolynomial(p1, p2);
<a id="__codelineno-75-9" name="__codelineno-75-9"></a>Traverse(p1);
</code></pre></div></td></tr></table></div></p>
<h2 id="2-stack-and-queue_1">2. 栈和队列(Stack and Queue)<a class="headerlink" href="#2-stack-and-queue_1" title="Permanent link">&para;</a></h2>
<h3 id="sequence-stack_1">顺序栈(Sequence Stack)<a class="headerlink" href="#sequence-stack_1" title="Permanent link">&para;</a></h3>
<h6 id="topbottom">栈是限定仅在表尾进行插入或删除操作的线性表，表末端为栈顶(Top)，表头称为栈顶(Bottom),不含元<a class="headerlink" href="#topbottom" title="Permanent link">&para;</a></h6>
<h6 id="_184">素称为空战<a class="headerlink" href="#_184" title="Permanent link">&para;</a></h6>
<h6 id="_185">(用顺序表存储的栈更常见)<a class="headerlink" href="#_185" title="Permanent link">&para;</a></h6>
<h6 id="last-in-first-out-lifo">因此栈又称为后进先出(Last in First out, LIFO)的线性表，如下图<a class="headerlink" href="#last-in-first-out-lifo" title="Permanent link">&para;</a></h6>
<h4 id="_186">栈的类型定义<a class="headerlink" href="#_186" title="Permanent link">&para;</a></h4>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-76-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-76-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-76-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-76-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-76-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-76-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-76-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-76-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-76-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-76-10">10</a></span>
<span class="normal"><a href="#__codelineno-76-11">11</a></span>
<span class="normal"><a href="#__codelineno-76-12">12</a></span>
<span class="normal"><a href="#__codelineno-76-13">13</a></span>
<span class="normal"><a href="#__codelineno-76-14">14</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-76-1" name="__codelineno-76-1"></a>system(&quot;pause&quot;);
<a id="__codelineno-76-2" name="__codelineno-76-2"></a>return 0 ;
<a id="__codelineno-76-3" name="__codelineno-76-3"></a>}
<a id="__codelineno-76-4" name="__codelineno-76-4"></a>/*
<a id="__codelineno-76-5" name="__codelineno-76-5"></a>x^6+2x^2+3x^
<a id="__codelineno-76-6" name="__codelineno-76-6"></a>-2x^2+3x^5+2x^6+x^
<a id="__codelineno-76-7" name="__codelineno-76-7"></a>---------------------------
<a id="__codelineno-76-8" name="__codelineno-76-8"></a>intput:
<a id="__codelineno-76-9" name="__codelineno-76-9"></a>1 6 2 2 3 5
<a id="__codelineno-76-10" name="__codelineno-76-10"></a>-2 2 3 5 2 6 1 3
<a id="__codelineno-76-11" name="__codelineno-76-11"></a>----------------------------
<a id="__codelineno-76-12" name="__codelineno-76-12"></a>output:
<a id="__codelineno-76-13" name="__codelineno-76-13"></a>(1.0x^3)+(6.0x^5)+(3.0x^6)
<a id="__codelineno-76-14" name="__codelineno-76-14"></a>*/
</code></pre></div></td></tr></table></div>
<h4 id="_187">栈的初始化<a class="headerlink" href="#_187" title="Permanent link">&para;</a></h4>
<h6 id="top">观察上图，发现top指向内存空间不存放元素<a class="headerlink" href="#top" title="Permanent link">&para;</a></h6>
<h4 id="push_2">入栈(Push)<a class="headerlink" href="#push_2" title="Permanent link">&para;</a></h4>
<h6 id="topbasetop">因为top指向的内存不存放空间，当为base分配的空间存满元素时，top = 分配空间的最后一个元素的<a class="headerlink" href="#topbasetop" title="Permanent link">&para;</a></h6>
<h6 id="1top-base-stacksize">地址+1，此时表示栈满，即top-base = stacksize<a class="headerlink" href="#1top-base-stacksize" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-77-1">1</a></span>
<span class="normal"><a href="#__codelineno-77-2">2</a></span>
<span class="normal"><a href="#__codelineno-77-3">3</a></span>
<span class="normal"><a href="#__codelineno-77-4">4</a></span>
<span class="normal"><a href="#__codelineno-77-5">5</a></span>
<span class="normal"><a href="#__codelineno-77-6">6</a></span>
<span class="normal"><a href="#__codelineno-77-7">7</a></span>
<span class="normal"><a href="#__codelineno-77-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-77-1" name="__codelineno-77-1"></a>#define MAXSTACK 100
<a id="__codelineno-77-2" name="__codelineno-77-2"></a>typedef char StackElemType; //栈数据类型
<a id="__codelineno-77-3" name="__codelineno-77-3"></a>typedef struct __SqStack //顺序栈，最常用
<a id="__codelineno-77-4" name="__codelineno-77-4"></a>{
<a id="__codelineno-77-5" name="__codelineno-77-5"></a>StackElemType *base;
<a id="__codelineno-77-6" name="__codelineno-77-6"></a>StackElemType *top;
<a id="__codelineno-77-7" name="__codelineno-77-7"></a>int stacksize;
<a id="__codelineno-77-8" name="__codelineno-77-8"></a>} SqStack;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-78-1">1</a></span>
<span class="normal"><a href="#__codelineno-78-2">2</a></span>
<span class="normal"><a href="#__codelineno-78-3">3</a></span>
<span class="normal"><a href="#__codelineno-78-4">4</a></span>
<span class="normal"><a href="#__codelineno-78-5">5</a></span>
<span class="normal"><a href="#__codelineno-78-6">6</a></span>
<span class="normal"><a href="#__codelineno-78-7">7</a></span>
<span class="normal"><a href="#__codelineno-78-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-78-1" name="__codelineno-78-1"></a>Status InitStack(SqStack *S) {
<a id="__codelineno-78-2" name="__codelineno-78-2"></a>S-&gt;base = (StackElemType *)malloc(sizeof(StackElemType) * MAXSTACK);
<a id="__codelineno-78-3" name="__codelineno-78-3"></a>if (!S-&gt;base)
<a id="__codelineno-78-4" name="__codelineno-78-4"></a>exit(OVERFLOW);
<a id="__codelineno-78-5" name="__codelineno-78-5"></a>S-&gt;top = S-&gt;base; //栈顶和指向栈底
<a id="__codelineno-78-6" name="__codelineno-78-6"></a>S-&gt;stacksize = MAXSTACK; //栈的容量
<a id="__codelineno-78-7" name="__codelineno-78-7"></a>return OK;
<a id="__codelineno-78-8" name="__codelineno-78-8"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-79-1">1</a></span>
<span class="normal"><a href="#__codelineno-79-2">2</a></span>
<span class="normal"><a href="#__codelineno-79-3">3</a></span>
<span class="normal"><a href="#__codelineno-79-4">4</a></span>
<span class="normal"><a href="#__codelineno-79-5">5</a></span>
<span class="normal"><a href="#__codelineno-79-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-79-1" name="__codelineno-79-1"></a>Status Push(SqStack *S, StackElemType e) {
<a id="__codelineno-79-2" name="__codelineno-79-2"></a>if (S-&gt;top - S-&gt;base == S-&gt;stacksize)
<a id="__codelineno-79-3" name="__codelineno-79-3"></a>return ERROR; //表示此时栈满
<a id="__codelineno-79-4" name="__codelineno-79-4"></a>*(S-&gt;top++) = e; // top指向内存单元存放e，且top指向下一个内存单元
<a id="__codelineno-79-5" name="__codelineno-79-5"></a>return OK;
<a id="__codelineno-79-6" name="__codelineno-79-6"></a>}
</code></pre></div></td></tr></table></div></p>
<h4 id="pop_2">出栈(Pop)<a class="headerlink" href="#pop_2" title="Permanent link">&para;</a></h4>
<h6 id="base-top">当 base == top 时，表示栈空<a class="headerlink" href="#base-top" title="Permanent link">&para;</a></h6>
<h4 id="_188">栈的其他操作<a class="headerlink" href="#_188" title="Permanent link">&para;</a></h4>
<h4 id="_189">测试代码<a class="headerlink" href="#_189" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-80-1">1</a></span>
<span class="normal"><a href="#__codelineno-80-2">2</a></span>
<span class="normal"><a href="#__codelineno-80-3">3</a></span>
<span class="normal"><a href="#__codelineno-80-4">4</a></span>
<span class="normal"><a href="#__codelineno-80-5">5</a></span>
<span class="normal"><a href="#__codelineno-80-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-80-1" name="__codelineno-80-1"></a>Status Pop(SqStack *S, StackElemType *e) {
<a id="__codelineno-80-2" name="__codelineno-80-2"></a>if (S-&gt;base == S-&gt;top)
<a id="__codelineno-80-3" name="__codelineno-80-3"></a>return ERROR; //栈空
<a id="__codelineno-80-4" name="__codelineno-80-4"></a>*e = *(--(S-&gt;top));
<a id="__codelineno-80-5" name="__codelineno-80-5"></a>return OK;
<a id="__codelineno-80-6" name="__codelineno-80-6"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-81-1">1</a></span>
<span class="normal"><a href="#__codelineno-81-2">2</a></span>
<span class="normal"><a href="#__codelineno-81-3">3</a></span>
<span class="normal"><a href="#__codelineno-81-4">4</a></span>
<span class="normal"><a href="#__codelineno-81-5">5</a></span>
<span class="normal"><a href="#__codelineno-81-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-81-1" name="__codelineno-81-1"></a>Status IsEmpty(SqStack *S) {
<a id="__codelineno-81-2" name="__codelineno-81-2"></a>if (S-&gt;base == S-&gt;top)
<a id="__codelineno-81-3" name="__codelineno-81-3"></a>return TRUE;
<a id="__codelineno-81-4" name="__codelineno-81-4"></a>else
<a id="__codelineno-81-5" name="__codelineno-81-5"></a>return FALSE;
<a id="__codelineno-81-6" name="__codelineno-81-6"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-82-1">1</a></span>
<span class="normal"><a href="#__codelineno-82-2">2</a></span>
<span class="normal"><a href="#__codelineno-82-3">3</a></span>
<span class="normal"><a href="#__codelineno-82-4">4</a></span>
<span class="normal"><a href="#__codelineno-82-5">5</a></span>
<span class="normal"><a href="#__codelineno-82-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-82-1" name="__codelineno-82-1"></a>Status IsFull(SqStack *S) {
<a id="__codelineno-82-2" name="__codelineno-82-2"></a>if (S-&gt;top - S-&gt;base == S-&gt;stacksize)
<a id="__codelineno-82-3" name="__codelineno-82-3"></a>return TRUE;
<a id="__codelineno-82-4" name="__codelineno-82-4"></a>else
<a id="__codelineno-82-5" name="__codelineno-82-5"></a>return ERROR;
<a id="__codelineno-82-6" name="__codelineno-82-6"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-83-1">1</a></span>
<span class="normal"><a href="#__codelineno-83-2">2</a></span>
<span class="normal"><a href="#__codelineno-83-3">3</a></span>
<span class="normal"><a href="#__codelineno-83-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-83-1" name="__codelineno-83-1"></a>StackElemType GetTop(SqStack *S) {
<a id="__codelineno-83-2" name="__codelineno-83-2"></a>if (!IsEmpty(S))
<a id="__codelineno-83-3" name="__codelineno-83-3"></a>return *(S-&gt;top - 1 );
<a id="__codelineno-83-4" name="__codelineno-83-4"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-84-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-84-1" name="__codelineno-84-1"></a>#include &lt;Stack.h&gt;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-85-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-85-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-85-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-85-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-85-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-85-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-85-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-85-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-85-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-85-10">10</a></span>
<span class="normal"><a href="#__codelineno-85-11">11</a></span>
<span class="normal"><a href="#__codelineno-85-12">12</a></span>
<span class="normal"><a href="#__codelineno-85-13">13</a></span>
<span class="normal"><a href="#__codelineno-85-14">14</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-85-1" name="__codelineno-85-1"></a>int main(void)
<a id="__codelineno-85-2" name="__codelineno-85-2"></a>{
<a id="__codelineno-85-3" name="__codelineno-85-3"></a>SqStack S;
<a id="__codelineno-85-4" name="__codelineno-85-4"></a>InitStack(&amp;S);
<a id="__codelineno-85-5" name="__codelineno-85-5"></a>Push(&amp;S, &#39;A&#39;);
<a id="__codelineno-85-6" name="__codelineno-85-6"></a>Push(&amp;S, &#39;B&#39;);
<a id="__codelineno-85-7" name="__codelineno-85-7"></a>Push(&amp;S, &#39;C&#39;);
<a id="__codelineno-85-8" name="__codelineno-85-8"></a>Push(&amp;S, &#39;C&#39;);
<a id="__codelineno-85-9" name="__codelineno-85-9"></a>while (!IsEmpty(&amp;S))
<a id="__codelineno-85-10" name="__codelineno-85-10"></a>{
<a id="__codelineno-85-11" name="__codelineno-85-11"></a>StackElemType e;
<a id="__codelineno-85-12" name="__codelineno-85-12"></a>Pop(&amp;S, &amp;e);
<a id="__codelineno-85-13" name="__codelineno-85-13"></a>printf(&quot;%c &quot;, e);
<a id="__codelineno-85-14" name="__codelineno-85-14"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-86-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-86-1" name="__codelineno-86-1"></a>system(&quot;pause&quot;);
</code></pre></div></td></tr></table></div></p>
<h3 id="linked-stack_1">链栈(Linked Stack)<a class="headerlink" href="#linked-stack_1" title="Permanent link">&para;</a></h3>
<h6 id="pushpoptop">由于栈的主要操作是对栈顶进行Push和Pop，所以选用top作为链表的头节点<a class="headerlink" href="#pushpoptop" title="Permanent link">&para;</a></h6>
<h4 id="_190">链栈的类型定义<a class="headerlink" href="#_190" title="Permanent link">&para;</a></h4>
<h4 id="_191">链栈初始化<a class="headerlink" href="#_191" title="Permanent link">&para;</a></h4>
<h4 id="push_3">链栈Push<a class="headerlink" href="#push_3" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-87-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-87-1" name="__codelineno-87-1"></a>在第一次Push时，第一个节点的next指向NULL
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-88-1">1</a></span>
<span class="normal"><a href="#__codelineno-88-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-88-1" name="__codelineno-88-1"></a>return 0 ;
<a id="__codelineno-88-2" name="__codelineno-88-2"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-89-1">1</a></span>
<span class="normal"><a href="#__codelineno-89-2">2</a></span>
<span class="normal"><a href="#__codelineno-89-3">3</a></span>
<span class="normal"><a href="#__codelineno-89-4">4</a></span>
<span class="normal"><a href="#__codelineno-89-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-89-1" name="__codelineno-89-1"></a>typedef struct __StackNode //链栈
<a id="__codelineno-89-2" name="__codelineno-89-2"></a>{
<a id="__codelineno-89-3" name="__codelineno-89-3"></a>StackElemType data;
<a id="__codelineno-89-4" name="__codelineno-89-4"></a>__StackNode *next;
<a id="__codelineno-89-5" name="__codelineno-89-5"></a>} StackNode, *LinkStack;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-90-1">1</a></span>
<span class="normal"><a href="#__codelineno-90-2">2</a></span>
<span class="normal"><a href="#__codelineno-90-3">3</a></span>
<span class="normal"><a href="#__codelineno-90-4">4</a></span>
<span class="normal"><a href="#__codelineno-90-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-90-1" name="__codelineno-90-1"></a>Status InitStack(LinkStack *S) {
<a id="__codelineno-90-2" name="__codelineno-90-2"></a>*S = NULL;
<a id="__codelineno-90-3" name="__codelineno-90-3"></a>//(*S)-&gt;next = NULL; 不需要此行代码
<a id="__codelineno-90-4" name="__codelineno-90-4"></a>return OK;
<a id="__codelineno-90-5" name="__codelineno-90-5"></a>}
</code></pre></div></td></tr></table></div></p>
<h4 id="pop_3">链栈Pop<a class="headerlink" href="#pop_3" title="Permanent link">&para;</a></h4>
<h4 id="_192">链栈的其他操作<a class="headerlink" href="#_192" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-91-1">1</a></span>
<span class="normal"><a href="#__codelineno-91-2">2</a></span>
<span class="normal"><a href="#__codelineno-91-3">3</a></span>
<span class="normal"><a href="#__codelineno-91-4">4</a></span>
<span class="normal"><a href="#__codelineno-91-5">5</a></span>
<span class="normal"><a href="#__codelineno-91-6">6</a></span>
<span class="normal"><a href="#__codelineno-91-7">7</a></span>
<span class="normal"><a href="#__codelineno-91-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-91-1" name="__codelineno-91-1"></a>Status Push(LinkStack *S, StackElemType e) {
<a id="__codelineno-91-2" name="__codelineno-91-2"></a>LinkStack pnew = (LinkStack)malloc(sizeof(StackNode));
<a id="__codelineno-91-3" name="__codelineno-91-3"></a>pnew-&gt;data = e;
<a id="__codelineno-91-4" name="__codelineno-91-4"></a>pnew-&gt;next =
<a id="__codelineno-91-5" name="__codelineno-91-5"></a>*S; //在第一次Push时，第一个节点的next指向NULL，因为初始化了*S=NULL;
<a id="__codelineno-91-6" name="__codelineno-91-6"></a>*S = pnew;
<a id="__codelineno-91-7" name="__codelineno-91-7"></a>return OK;
<a id="__codelineno-91-8" name="__codelineno-91-8"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-92-1">1</a></span>
<span class="normal"><a href="#__codelineno-92-2">2</a></span>
<span class="normal"><a href="#__codelineno-92-3">3</a></span>
<span class="normal"><a href="#__codelineno-92-4">4</a></span>
<span class="normal"><a href="#__codelineno-92-5">5</a></span>
<span class="normal"><a href="#__codelineno-92-6">6</a></span>
<span class="normal"><a href="#__codelineno-92-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-92-1" name="__codelineno-92-1"></a>Status Pop(LinkStack *S, StackElemType *e) {
<a id="__codelineno-92-2" name="__codelineno-92-2"></a>LinkStack pfree = *S; //临时保存栈顶节点S
<a id="__codelineno-92-3" name="__codelineno-92-3"></a>*e = (*S)-&gt;data;
<a id="__codelineno-92-4" name="__codelineno-92-4"></a>*S = (*S)-&gt;next;
<a id="__codelineno-92-5" name="__codelineno-92-5"></a>free(pfree); //出栈后释放
<a id="__codelineno-92-6" name="__codelineno-92-6"></a>return OK;
<a id="__codelineno-92-7" name="__codelineno-92-7"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-93-1">1</a></span>
<span class="normal"><a href="#__codelineno-93-2">2</a></span>
<span class="normal"><a href="#__codelineno-93-3">3</a></span>
<span class="normal"><a href="#__codelineno-93-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-93-1" name="__codelineno-93-1"></a>StackElemType GetTop(LinkStack *S) {
<a id="__codelineno-93-2" name="__codelineno-93-2"></a>if (*S)
<a id="__codelineno-93-3" name="__codelineno-93-3"></a>return (*S)-&gt;data;
<a id="__codelineno-93-4" name="__codelineno-93-4"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-94-1">1</a></span>
<span class="normal"><a href="#__codelineno-94-2">2</a></span>
<span class="normal"><a href="#__codelineno-94-3">3</a></span>
<span class="normal"><a href="#__codelineno-94-4">4</a></span>
<span class="normal"><a href="#__codelineno-94-5">5</a></span>
<span class="normal"><a href="#__codelineno-94-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-94-1" name="__codelineno-94-1"></a>Status IsEmpty(LinkStack *S) {
<a id="__codelineno-94-2" name="__codelineno-94-2"></a>if (!(*S))
<a id="__codelineno-94-3" name="__codelineno-94-3"></a>return TRUE;
<a id="__codelineno-94-4" name="__codelineno-94-4"></a>else
<a id="__codelineno-94-5" name="__codelineno-94-5"></a>return FALSE;
<a id="__codelineno-94-6" name="__codelineno-94-6"></a>}
</code></pre></div></td></tr></table></div></p>
<h4 id="_193">测试代码<a class="headerlink" href="#_193" title="Permanent link">&para;</a></h4>
<h4 id="stackh_1">Stack.h<a class="headerlink" href="#stackh_1" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-95-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-95-1" name="__codelineno-95-1"></a>#include &quot;Stack.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-96-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-96-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-96-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-96-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-96-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-96-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-96-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-96-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-96-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-96-10">10</a></span>
<span class="normal"><a href="#__codelineno-96-11">11</a></span>
<span class="normal"><a href="#__codelineno-96-12">12</a></span>
<span class="normal"><a href="#__codelineno-96-13">13</a></span>
<span class="normal"><a href="#__codelineno-96-14">14</a></span>
<span class="normal"><a href="#__codelineno-96-15">15</a></span>
<span class="normal"><a href="#__codelineno-96-16">16</a></span>
<span class="normal"><a href="#__codelineno-96-17">17</a></span>
<span class="normal"><a href="#__codelineno-96-18">18</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-96-1" name="__codelineno-96-1"></a>int main(void)
<a id="__codelineno-96-2" name="__codelineno-96-2"></a>{
<a id="__codelineno-96-3" name="__codelineno-96-3"></a>LinkStack S;
<a id="__codelineno-96-4" name="__codelineno-96-4"></a>InitStack(&amp;S);
<a id="__codelineno-96-5" name="__codelineno-96-5"></a>Push(&amp;S, &#39;E&#39;);
<a id="__codelineno-96-6" name="__codelineno-96-6"></a>Push(&amp;S, &#39;A&#39;);
<a id="__codelineno-96-7" name="__codelineno-96-7"></a>Push(&amp;S, &#39;C&#39;);
<a id="__codelineno-96-8" name="__codelineno-96-8"></a>Push(&amp;S, &#39;H&#39;);
<a id="__codelineno-96-9" name="__codelineno-96-9"></a>Push(&amp;S, &#39;R&#39;);
<a id="__codelineno-96-10" name="__codelineno-96-10"></a>while (!IsEmpty(&amp;S))
<a id="__codelineno-96-11" name="__codelineno-96-11"></a>{
<a id="__codelineno-96-12" name="__codelineno-96-12"></a>StackElemType e;
<a id="__codelineno-96-13" name="__codelineno-96-13"></a>Pop(&amp;S, &amp;e);
<a id="__codelineno-96-14" name="__codelineno-96-14"></a>printf(&quot;%c &quot;, e);
<a id="__codelineno-96-15" name="__codelineno-96-15"></a>}
<a id="__codelineno-96-16" name="__codelineno-96-16"></a>system(&quot;pause&quot;);
<a id="__codelineno-96-17" name="__codelineno-96-17"></a>return 0 ;
<a id="__codelineno-96-18" name="__codelineno-96-18"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-97-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-97-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-97-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-97-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-97-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-97-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-97-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-97-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-97-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-97-10">10</a></span>
<span class="normal"><a href="#__codelineno-97-11">11</a></span>
<span class="normal"><a href="#__codelineno-97-12">12</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-97-1" name="__codelineno-97-1"></a>#include &quot;define.h&quot;
<a id="__codelineno-97-2" name="__codelineno-97-2"></a>#ifndef _STACK_H
<a id="__codelineno-97-3" name="__codelineno-97-3"></a>#define _STACK_H
<a id="__codelineno-97-4" name="__codelineno-97-4"></a>//-----------------------------------------------------
<a id="__codelineno-97-5" name="__codelineno-97-5"></a>#define MAXSTACK 100
<a id="__codelineno-97-6" name="__codelineno-97-6"></a>typedef char StackElemType; //栈数据类型
<a id="__codelineno-97-7" name="__codelineno-97-7"></a>typedef struct __SqStack //顺序栈，最常用
<a id="__codelineno-97-8" name="__codelineno-97-8"></a>{
<a id="__codelineno-97-9" name="__codelineno-97-9"></a>StackElemType *base;
<a id="__codelineno-97-10" name="__codelineno-97-10"></a>StackElemType *top;
<a id="__codelineno-97-11" name="__codelineno-97-11"></a>int stacksize;
<a id="__codelineno-97-12" name="__codelineno-97-12"></a>} SqStack;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-98-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-98-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-98-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-98-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-98-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-98-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-98-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-98-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-98-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-98-10">10</a></span>
<span class="normal"><a href="#__codelineno-98-11">11</a></span>
<span class="normal"><a href="#__codelineno-98-12">12</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-98-1" name="__codelineno-98-1"></a>Status InitStack(SqStack *S);
<a id="__codelineno-98-2" name="__codelineno-98-2"></a>Status Push(SqStack *S, StackElemType e);
<a id="__codelineno-98-3" name="__codelineno-98-3"></a>Status Pop(SqStack *S, StackElemType *e);
<a id="__codelineno-98-4" name="__codelineno-98-4"></a>Status IsEmpty(SqStack *S);
<a id="__codelineno-98-5" name="__codelineno-98-5"></a>Status IsFull(SqStack *S);
<a id="__codelineno-98-6" name="__codelineno-98-6"></a>StackElemType GetTop(SqStack *S);
<a id="__codelineno-98-7" name="__codelineno-98-7"></a>//---------------------------------------------------------
<a id="__codelineno-98-8" name="__codelineno-98-8"></a>typedef struct __StackNode //链栈
<a id="__codelineno-98-9" name="__codelineno-98-9"></a>{
<a id="__codelineno-98-10" name="__codelineno-98-10"></a>StackElemType data;
<a id="__codelineno-98-11" name="__codelineno-98-11"></a>__StackNode *next;
<a id="__codelineno-98-12" name="__codelineno-98-12"></a>} StackNode, *LinkStack;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-99-1">1</a></span>
<span class="normal"><a href="#__codelineno-99-2">2</a></span>
<span class="normal"><a href="#__codelineno-99-3">3</a></span>
<span class="normal"><a href="#__codelineno-99-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-99-1" name="__codelineno-99-1"></a>Status InitStack(LinkStack *S);
<a id="__codelineno-99-2" name="__codelineno-99-2"></a>Status Push(LinkStack *S, StackElemType e);
<a id="__codelineno-99-3" name="__codelineno-99-3"></a>Status Pop(LinkStack *S, StackElemType *e);
<a id="__codelineno-99-4" name="__codelineno-99-4"></a>StackElemType GetTop(LinkStack *S);
</code></pre></div></td></tr></table></div></p>
<h3 id="_194">栈与递归<a class="headerlink" href="#_194" title="Permanent link">&para;</a></h3>
<h4 id="_195">函数的调用过程<a class="headerlink" href="#_195" title="Permanent link">&para;</a></h4>
<h6 id="_196">调用前系统完成：<a class="headerlink" href="#_196" title="Permanent link">&para;</a></h6>
<h6 id="1_3">1. 将实参，返回地址(下行代码地址)等传递给被调用函数<a class="headerlink" href="#1_3" title="Permanent link">&para;</a></h6>
<h6 id="2_1">2. 为被调用函数的局部变量分配空间<a class="headerlink" href="#2_1" title="Permanent link">&para;</a></h6>
<h6 id="3_2">3. 将控制转移到被调用函数的入口<a class="headerlink" href="#3_2" title="Permanent link">&para;</a></h6>
<h6 id="_197">调用后，系统完成：<a class="headerlink" href="#_197" title="Permanent link">&para;</a></h6>
<h6 id="1_4">1. 保存被调用函数的计算结果(返回值)<a class="headerlink" href="#1_4" title="Permanent link">&para;</a></h6>
<h6 id="2_2">2. 释放被调用函数的数据区<a class="headerlink" href="#2_2" title="Permanent link">&para;</a></h6>
<h6 id="3_3">3. 依照被调用函数保存的返回地址，将控制转移到调用函数<a class="headerlink" href="#3_3" title="Permanent link">&para;</a></h6>
<h6 id="_198">递归调用函数时，如下图<a class="headerlink" href="#_198" title="Permanent link">&para;</a></h6>
<h6 id="_199">按照调用顺序依此把各个函数入栈<a class="headerlink" href="#_199" title="Permanent link">&para;</a></h6>
<h6 id="returnfislo">当栈顶函数满足return条件时，依此出栈(按照FISLO原则)，并且返回值从上向下传递<a class="headerlink" href="#returnfislo" title="Permanent link">&para;</a></h6>
<h6 id="fact4">直到主程序调用的fact(4)出栈后，递归完成<a class="headerlink" href="#fact4" title="Permanent link">&para;</a></h6>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-100-1">1</a></span>
<span class="normal"><a href="#__codelineno-100-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-100-1" name="__codelineno-100-1"></a>Status IsEmpty(LinkStack *S);
<a id="__codelineno-100-2" name="__codelineno-100-2"></a>#endif
</code></pre></div></td></tr></table></div>
<h3 id="_200">循环队列<a class="headerlink" href="#_200" title="Permanent link">&para;</a></h3>
<h6 id="_201">定义：只能在表的一端进行插入运算，在表的另一端进行删除运算的 线性表<a class="headerlink" href="#_201" title="Permanent link">&para;</a></h6>
<h6 id="first-in-firs-out">先进先出(First in Firs out)原则<a class="headerlink" href="#first-in-firs-out" title="Permanent link">&para;</a></h6>
<h6 id="_202">数据类型定义<a class="headerlink" href="#_202" title="Permanent link">&para;</a></h6>
<h6 id="drear">如上图，(d)虽然数组中的空间没有满，但是rear却不能继续增加，假溢出<a class="headerlink" href="#drear" title="Permanent link">&para;</a></h6>
<h6 id="base">解决方法：把base数组想象成一个环形的循环队列如下图<a class="headerlink" href="#base" title="Permanent link">&para;</a></h6>
<h6 id="front-rere-front-rere1-qmaxsize">此时如果 front == rere表示 队空 ，而 front == (rere+1) % QMAXSIZE时表示 队满<a class="headerlink" href="#front-rere-front-rere1-qmaxsize" title="Permanent link">&para;</a></h6>
<h4 id="_203">顺换队列初始化<a class="headerlink" href="#_203" title="Permanent link">&para;</a></h4>
<h6 id="front-rere-0">把 front 和 rere 初始化为 0<a class="headerlink" href="#front-rere-0" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-101-1">1</a></span>
<span class="normal"><a href="#__codelineno-101-2">2</a></span>
<span class="normal"><a href="#__codelineno-101-3">3</a></span>
<span class="normal"><a href="#__codelineno-101-4">4</a></span>
<span class="normal"><a href="#__codelineno-101-5">5</a></span>
<span class="normal"><a href="#__codelineno-101-6">6</a></span>
<span class="normal"><a href="#__codelineno-101-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-101-1" name="__codelineno-101-1"></a>#define QMAXSIZE 100
<a id="__codelineno-101-2" name="__codelineno-101-2"></a>typedef char QElemType;
<a id="__codelineno-101-3" name="__codelineno-101-3"></a>typedef struct __SqQueue {
<a id="__codelineno-101-4" name="__codelineno-101-4"></a>QElemType *base;
<a id="__codelineno-101-5" name="__codelineno-101-5"></a>int front, rere; //front为队头下标，rere为队尾下标(rere下标的位置不存放元素)
<a id="__codelineno-101-6" name="__codelineno-101-6"></a>} SqQueue;
<a id="__codelineno-101-7" name="__codelineno-101-7"></a>//入队rere+1,出队front+1,但是此种情况存在问题，如下图
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-102-1">1</a></span>
<span class="normal"><a href="#__codelineno-102-2">2</a></span>
<span class="normal"><a href="#__codelineno-102-3">3</a></span>
<span class="normal"><a href="#__codelineno-102-4">4</a></span>
<span class="normal"><a href="#__codelineno-102-5">5</a></span>
<span class="normal"><a href="#__codelineno-102-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-102-1" name="__codelineno-102-1"></a>Status InitQueue(SqQueue *Q) {
<a id="__codelineno-102-2" name="__codelineno-102-2"></a>if (!(Q-&gt;base = (QElemType *)malloc(sizeof(QElemType) * QMAXSIZE)))
<a id="__codelineno-102-3" name="__codelineno-102-3"></a>exit(OVERFLOW);
<a id="__codelineno-102-4" name="__codelineno-102-4"></a>Q-&gt;front = Q-&gt;rere = 0 ;
<a id="__codelineno-102-5" name="__codelineno-102-5"></a>return OK;
<a id="__codelineno-102-6" name="__codelineno-102-6"></a>}
</code></pre></div></td></tr></table></div></p>
<h4 id="_204">顺换队列入队<a class="headerlink" href="#_204" title="Permanent link">&para;</a></h4>
<h4 id="_205">循环队列出队<a class="headerlink" href="#_205" title="Permanent link">&para;</a></h4>
<h4 id="_206">循环队列其他操作<a class="headerlink" href="#_206" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-103-1">1</a></span>
<span class="normal"><a href="#__codelineno-103-2">2</a></span>
<span class="normal"><a href="#__codelineno-103-3">3</a></span>
<span class="normal"><a href="#__codelineno-103-4">4</a></span>
<span class="normal"><a href="#__codelineno-103-5">5</a></span>
<span class="normal"><a href="#__codelineno-103-6">6</a></span>
<span class="normal"><a href="#__codelineno-103-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-103-1" name="__codelineno-103-1"></a>Status EntryQ(SqQueue *Q, QElemType e) {
<a id="__codelineno-103-2" name="__codelineno-103-2"></a>if ((Q-&gt;rere + 1 ) % QMAXSIZE == Q-&gt;front) //判断是否队满
<a id="__codelineno-103-3" name="__codelineno-103-3"></a>return ERROR;
<a id="__codelineno-103-4" name="__codelineno-103-4"></a>Q-&gt;base[Q-&gt;rere] = e;
<a id="__codelineno-103-5" name="__codelineno-103-5"></a>Q-&gt;rere = (Q-&gt;rere + 1 ) % QMAXSIZE; // Q-&gt;rere++ 错误写法
<a id="__codelineno-103-6" name="__codelineno-103-6"></a>return OK;
<a id="__codelineno-103-7" name="__codelineno-103-7"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-104-1">1</a></span>
<span class="normal"><a href="#__codelineno-104-2">2</a></span>
<span class="normal"><a href="#__codelineno-104-3">3</a></span>
<span class="normal"><a href="#__codelineno-104-4">4</a></span>
<span class="normal"><a href="#__codelineno-104-5">5</a></span>
<span class="normal"><a href="#__codelineno-104-6">6</a></span>
<span class="normal"><a href="#__codelineno-104-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-104-1" name="__codelineno-104-1"></a>Status OutQ(SqQueue *Q, QElemType *e) {
<a id="__codelineno-104-2" name="__codelineno-104-2"></a>if (Q-&gt;rere == Q-&gt;front) //判断是否队满
<a id="__codelineno-104-3" name="__codelineno-104-3"></a>return ERROR;
<a id="__codelineno-104-4" name="__codelineno-104-4"></a>*e = Q-&gt;base[Q-&gt;front];
<a id="__codelineno-104-5" name="__codelineno-104-5"></a>Q-&gt;front = (Q-&gt;front + 1 ) % QMAXSIZE; // Q-&gt;front++; 为错误写法
<a id="__codelineno-104-6" name="__codelineno-104-6"></a>return OK;
<a id="__codelineno-104-7" name="__codelineno-104-7"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-105-1">1</a></span>
<span class="normal"><a href="#__codelineno-105-2">2</a></span>
<span class="normal"><a href="#__codelineno-105-3">3</a></span>
<span class="normal"><a href="#__codelineno-105-4">4</a></span>
<span class="normal"><a href="#__codelineno-105-5">5</a></span>
<span class="normal"><a href="#__codelineno-105-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-105-1" name="__codelineno-105-1"></a>Status IsEmpty(SqQueue *Q) {
<a id="__codelineno-105-2" name="__codelineno-105-2"></a>if (Q-&gt;front == Q-&gt;rere)
<a id="__codelineno-105-3" name="__codelineno-105-3"></a>return TRUE;
<a id="__codelineno-105-4" name="__codelineno-105-4"></a>else
<a id="__codelineno-105-5" name="__codelineno-105-5"></a>return FALSE;
<a id="__codelineno-105-6" name="__codelineno-105-6"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-106-1">1</a></span>
<span class="normal"><a href="#__codelineno-106-2">2</a></span>
<span class="normal"><a href="#__codelineno-106-3">3</a></span>
<span class="normal"><a href="#__codelineno-106-4">4</a></span>
<span class="normal"><a href="#__codelineno-106-5">5</a></span>
<span class="normal"><a href="#__codelineno-106-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-106-1" name="__codelineno-106-1"></a>Status IsFull(SqQueue *Q) {
<a id="__codelineno-106-2" name="__codelineno-106-2"></a>if ((Q-&gt;rere + 1 ) % QMAXSIZE == Q-&gt;front)
<a id="__codelineno-106-3" name="__codelineno-106-3"></a>return TRUE;
<a id="__codelineno-106-4" name="__codelineno-106-4"></a>else
<a id="__codelineno-106-5" name="__codelineno-106-5"></a>return FALSE;
<a id="__codelineno-106-6" name="__codelineno-106-6"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-107-1">1</a></span>
<span class="normal"><a href="#__codelineno-107-2">2</a></span>
<span class="normal"><a href="#__codelineno-107-3">3</a></span>
<span class="normal"><a href="#__codelineno-107-4">4</a></span>
<span class="normal"><a href="#__codelineno-107-5">5</a></span>
<span class="normal"><a href="#__codelineno-107-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-107-1" name="__codelineno-107-1"></a>Status GetFront(SqQueue *Q, QElemType *e) {
<a id="__codelineno-107-2" name="__codelineno-107-2"></a>if (IsEmpty(Q))
<a id="__codelineno-107-3" name="__codelineno-107-3"></a>return ERROR;
<a id="__codelineno-107-4" name="__codelineno-107-4"></a>*e = Q-&gt;base[Q-&gt;front];
<a id="__codelineno-107-5" name="__codelineno-107-5"></a>return OK;
<a id="__codelineno-107-6" name="__codelineno-107-6"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-108-1">1</a></span>
<span class="normal"><a href="#__codelineno-108-2">2</a></span>
<span class="normal"><a href="#__codelineno-108-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-108-1" name="__codelineno-108-1"></a>int LengthQueue(SqQueue *Q) {
<a id="__codelineno-108-2" name="__codelineno-108-2"></a>return (Q-&gt;rere - Q-&gt;front + QMAXSIZE) % QMAXSIZE;
<a id="__codelineno-108-3" name="__codelineno-108-3"></a>}
</code></pre></div></td></tr></table></div></p>
<h4 id="_207">测试代码<a class="headerlink" href="#_207" title="Permanent link">&para;</a></h4>
<h3 id="_208">链队<a class="headerlink" href="#_208" title="Permanent link">&para;</a></h3>
<h6 id="front-rere">链队结构类似于链表，不同于链表的头指针，用两个指针域 front rere 来表示队列，如下图<a class="headerlink" href="#front-rere" title="Permanent link">&para;</a></h6>
<h6 id="_209">数据类型定义：<a class="headerlink" href="#_209" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-109-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-109-1" name="__codelineno-109-1"></a>#include &quot;Queue.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-110-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-110-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-110-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-110-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-110-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-110-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-110-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-110-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-110-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-110-10">10</a></span>
<span class="normal"><a href="#__codelineno-110-11">11</a></span>
<span class="normal"><a href="#__codelineno-110-12">12</a></span>
<span class="normal"><a href="#__codelineno-110-13">13</a></span>
<span class="normal"><a href="#__codelineno-110-14">14</a></span>
<span class="normal"><a href="#__codelineno-110-15">15</a></span>
<span class="normal"><a href="#__codelineno-110-16">16</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-110-1" name="__codelineno-110-1"></a>int main(void) {
<a id="__codelineno-110-2" name="__codelineno-110-2"></a>SqQueue Q;
<a id="__codelineno-110-3" name="__codelineno-110-3"></a>InitQueue(&amp;Q);
<a id="__codelineno-110-4" name="__codelineno-110-4"></a>EntryQ(&amp;Q, &#39;A&#39;);
<a id="__codelineno-110-5" name="__codelineno-110-5"></a>EntryQ(&amp;Q, &#39;B&#39;);
<a id="__codelineno-110-6" name="__codelineno-110-6"></a>EntryQ(&amp;Q, &#39;N&#39;);
<a id="__codelineno-110-7" name="__codelineno-110-7"></a>EntryQ(&amp;Q, &#39;M&#39;);
<a id="__codelineno-110-8" name="__codelineno-110-8"></a>printf(&quot;%d\n&quot;, LengthQueue(&amp;Q));
<a id="__codelineno-110-9" name="__codelineno-110-9"></a>QElemType e;
<a id="__codelineno-110-10" name="__codelineno-110-10"></a>while (!(IsEmpty(&amp;Q))) {
<a id="__codelineno-110-11" name="__codelineno-110-11"></a>OutQ(&amp;Q, &amp;e);
<a id="__codelineno-110-12" name="__codelineno-110-12"></a>printf(&quot;%c &quot;, e);
<a id="__codelineno-110-13" name="__codelineno-110-13"></a>}
<a id="__codelineno-110-14" name="__codelineno-110-14"></a>system(&quot;pause&quot;);
<a id="__codelineno-110-15" name="__codelineno-110-15"></a>return 0 ;
<a id="__codelineno-110-16" name="__codelineno-110-16"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-111-1">1</a></span>
<span class="normal"><a href="#__codelineno-111-2">2</a></span>
<span class="normal"><a href="#__codelineno-111-3">3</a></span>
<span class="normal"><a href="#__codelineno-111-4">4</a></span>
<span class="normal"><a href="#__codelineno-111-5">5</a></span>
<span class="normal"><a href="#__codelineno-111-6">6</a></span>
<span class="normal"><a href="#__codelineno-111-7">7</a></span>
<span class="normal"><a href="#__codelineno-111-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-111-1" name="__codelineno-111-1"></a>typedef struct __QueueNode {
<a id="__codelineno-111-2" name="__codelineno-111-2"></a>QElemType data;
<a id="__codelineno-111-3" name="__codelineno-111-3"></a>__QueueNode *next;
<a id="__codelineno-111-4" name="__codelineno-111-4"></a>} QueueNode;
<a id="__codelineno-111-5" name="__codelineno-111-5"></a>typedef struct __LinkedQueue {
<a id="__codelineno-111-6" name="__codelineno-111-6"></a>QueueNode *front;//front相当于链表的头指针
<a id="__codelineno-111-7" name="__codelineno-111-7"></a>QueueNode *rere;//rere指向整个链表的最后一个节点
<a id="__codelineno-111-8" name="__codelineno-111-8"></a>} LinkedQueue;
</code></pre></div></td></tr></table></div></p>
<h4 id="_210">链队初始化<a class="headerlink" href="#_210" title="Permanent link">&para;</a></h4>
<h4 id="_211">链队入队<a class="headerlink" href="#_211" title="Permanent link">&para;</a></h4>
<h4 id="_212">链队出队<a class="headerlink" href="#_212" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-112-1">1</a></span>
<span class="normal"><a href="#__codelineno-112-2">2</a></span>
<span class="normal"><a href="#__codelineno-112-3">3</a></span>
<span class="normal"><a href="#__codelineno-112-4">4</a></span>
<span class="normal"><a href="#__codelineno-112-5">5</a></span>
<span class="normal"><a href="#__codelineno-112-6">6</a></span>
<span class="normal"><a href="#__codelineno-112-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-112-1" name="__codelineno-112-1"></a>Status InitQueue(LinkedQueue *Q) {
<a id="__codelineno-112-2" name="__codelineno-112-2"></a>// front rere 指向同一节点
<a id="__codelineno-112-3" name="__codelineno-112-3"></a>if (!(Q-&gt;front = Q-&gt;rere = (QueueNode *)malloc(sizeof(QueueNode))))
<a id="__codelineno-112-4" name="__codelineno-112-4"></a>exit(OVERFLOW);
<a id="__codelineno-112-5" name="__codelineno-112-5"></a>Q-&gt;front-&gt;next = NULL; //使该节点next域为NULL
<a id="__codelineno-112-6" name="__codelineno-112-6"></a>return OK;
<a id="__codelineno-112-7" name="__codelineno-112-7"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-113-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-113-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-113-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-113-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-113-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-113-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-113-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-113-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-113-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-113-10">10</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-113-1" name="__codelineno-113-1"></a>Status EntryQ(LinkedQueue *Q, QElemType e) {
<a id="__codelineno-113-2" name="__codelineno-113-2"></a>QueueNode *pnew = (QueueNode *)malloc(sizeof(QueueNode));
<a id="__codelineno-113-3" name="__codelineno-113-3"></a>if (!pnew)
<a id="__codelineno-113-4" name="__codelineno-113-4"></a>exit(OVERFLOW);
<a id="__codelineno-113-5" name="__codelineno-113-5"></a>pnew-&gt;data = e;
<a id="__codelineno-113-6" name="__codelineno-113-6"></a>pnew-&gt;next = NULL;
<a id="__codelineno-113-7" name="__codelineno-113-7"></a>Q-&gt;rere-&gt;next = pnew;
<a id="__codelineno-113-8" name="__codelineno-113-8"></a>Q-&gt;rere = pnew;
<a id="__codelineno-113-9" name="__codelineno-113-9"></a>return OK;
<a id="__codelineno-113-10" name="__codelineno-113-10"></a>}
</code></pre></div></td></tr></table></div></p>
<h3 id="_213">栈和队列玩具<a class="headerlink" href="#_213" title="Permanent link">&para;</a></h3>
<h4 id="_214">进制转化<a class="headerlink" href="#_214" title="Permanent link">&para;</a></h4>
<h6 id="nn-8">一个进转换函数，有一个参数n(十进制)，要求输出n的 8 进制<a class="headerlink" href="#nn-8" title="Permanent link">&para;</a></h6>
<h4 id="_215">括号的匹配<a class="headerlink" href="#_215" title="Permanent link">&para;</a></h4>
<h6 id="_216">输入括号()[]，判断括号是否匹配成功，#字符表示输入结束<a class="headerlink" href="#_216" title="Permanent link">&para;</a></h6>
<h6 id="_217">例: ([()])成功 [(())]] 失败<a class="headerlink" href="#_217" title="Permanent link">&para;</a></h6>
<h6 id="1_5">写法 1 ：<a class="headerlink" href="#1_5" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-114-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-114-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-114-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-114-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-114-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-114-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-114-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-114-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-114-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-114-10">10</a></span>
<span class="normal"><a href="#__codelineno-114-11">11</a></span>
<span class="normal"><a href="#__codelineno-114-12">12</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-114-1" name="__codelineno-114-1"></a>Status OutQ(LinkedQueue *Q, QElemType *e) {
<a id="__codelineno-114-2" name="__codelineno-114-2"></a>if (Q-&gt;front == Q-&gt;rere)
<a id="__codelineno-114-3" name="__codelineno-114-3"></a>return ERROR;
<a id="__codelineno-114-4" name="__codelineno-114-4"></a>QueueNode *pfree = Q-&gt;front-&gt;next;
<a id="__codelineno-114-5" name="__codelineno-114-5"></a>*e = pfree-&gt;data;
<a id="__codelineno-114-6" name="__codelineno-114-6"></a>Q-&gt;front-&gt;next = pfree-&gt;next;
<a id="__codelineno-114-7" name="__codelineno-114-7"></a>//如果删除的节点为队尾，那么释放pfree之后，rere指向未知存储空间
<a id="__codelineno-114-8" name="__codelineno-114-8"></a>if (Q-&gt;rere == pfree)
<a id="__codelineno-114-9" name="__codelineno-114-9"></a>Q-&gt;rere = Q-&gt;front;
<a id="__codelineno-114-10" name="__codelineno-114-10"></a>free(pfree);
<a id="__codelineno-114-11" name="__codelineno-114-11"></a>return OK;
<a id="__codelineno-114-12" name="__codelineno-114-12"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-115-1">1</a></span>
<span class="normal"><a href="#__codelineno-115-2">2</a></span>
<span class="normal"><a href="#__codelineno-115-3">3</a></span>
<span class="normal"><a href="#__codelineno-115-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-115-1" name="__codelineno-115-1"></a>//需要提前修改 StackElemType的类型
<a id="__codelineno-115-2" name="__codelineno-115-2"></a>void Convert_8(int n) {
<a id="__codelineno-115-3" name="__codelineno-115-3"></a>SqStack S;
<a id="__codelineno-115-4" name="__codelineno-115-4"></a>InitStack(&amp;S);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-116-1">1</a></span>
<span class="normal"><a href="#__codelineno-116-2">2</a></span>
<span class="normal"><a href="#__codelineno-116-3">3</a></span>
<span class="normal"><a href="#__codelineno-116-4">4</a></span>
<span class="normal"><a href="#__codelineno-116-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-116-1" name="__codelineno-116-1"></a>int temp = n;
<a id="__codelineno-116-2" name="__codelineno-116-2"></a>while (temp) {
<a id="__codelineno-116-3" name="__codelineno-116-3"></a>Push(&amp;S, temp % 8 );
<a id="__codelineno-116-4" name="__codelineno-116-4"></a>temp = temp / 8 ;
<a id="__codelineno-116-5" name="__codelineno-116-5"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-117-1">1</a></span>
<span class="normal"><a href="#__codelineno-117-2">2</a></span>
<span class="normal"><a href="#__codelineno-117-3">3</a></span>
<span class="normal"><a href="#__codelineno-117-4">4</a></span>
<span class="normal"><a href="#__codelineno-117-5">5</a></span>
<span class="normal"><a href="#__codelineno-117-6">6</a></span>
<span class="normal"><a href="#__codelineno-117-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-117-1" name="__codelineno-117-1"></a>while (!IsEmpty(&amp;S)) {
<a id="__codelineno-117-2" name="__codelineno-117-2"></a>int i;
<a id="__codelineno-117-3" name="__codelineno-117-3"></a>Pop(&amp;S, &amp;i);
<a id="__codelineno-117-4" name="__codelineno-117-4"></a>printf(&quot;%d&quot;, i);
<a id="__codelineno-117-5" name="__codelineno-117-5"></a>}
<a id="__codelineno-117-6" name="__codelineno-117-6"></a>printf(&quot;\n&quot;);
<a id="__codelineno-117-7" name="__codelineno-117-7"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-118-1">1</a></span>
<span class="normal"><a href="#__codelineno-118-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-118-1" name="__codelineno-118-1"></a>Status Matching_Parentheses(void) {
<a id="__codelineno-118-2" name="__codelineno-118-2"></a>SqStack S;
</code></pre></div></td></tr></table></div></p>
<h6 id="2_3">写法 2 ：<a class="headerlink" href="#2_3" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-119-1">1</a></span>
<span class="normal"><a href="#__codelineno-119-2">2</a></span>
<span class="normal"><a href="#__codelineno-119-3">3</a></span>
<span class="normal"><a href="#__codelineno-119-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-119-1" name="__codelineno-119-1"></a>InitStack(&amp;S);
<a id="__codelineno-119-2" name="__codelineno-119-2"></a>char ch, pop;
<a id="__codelineno-119-3" name="__codelineno-119-3"></a>int flag = 1 ;
<a id="__codelineno-119-4" name="__codelineno-119-4"></a>scanf(&quot; %c&quot;, &amp;ch);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-120-1">1</a></span>
<span class="normal"><a href="#__codelineno-120-2">2</a></span>
<span class="normal"><a href="#__codelineno-120-3">3</a></span>
<span class="normal"><a href="#__codelineno-120-4">4</a></span>
<span class="normal"><a href="#__codelineno-120-5">5</a></span>
<span class="normal"><a href="#__codelineno-120-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-120-1" name="__codelineno-120-1"></a>while (flag &amp;&amp; ch != &#39;#&#39;) {
<a id="__codelineno-120-2" name="__codelineno-120-2"></a>switch (ch) {
<a id="__codelineno-120-3" name="__codelineno-120-3"></a>// 注意:不可以写成 case &#39;(&#39; || &#39;[&#39;: 如果这样写 ||运算符只会返回 1
<a id="__codelineno-120-4" name="__codelineno-120-4"></a>case &#39;(&#39;:
<a id="__codelineno-120-5" name="__codelineno-120-5"></a>Push(&amp;S, ch);
<a id="__codelineno-120-6" name="__codelineno-120-6"></a>break;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-121-1">1</a></span>
<span class="normal"><a href="#__codelineno-121-2">2</a></span>
<span class="normal"><a href="#__codelineno-121-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-121-1" name="__codelineno-121-1"></a>case &#39;[&#39;:
<a id="__codelineno-121-2" name="__codelineno-121-2"></a>Push(&amp;S, ch);
<a id="__codelineno-121-3" name="__codelineno-121-3"></a>break;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-122-1">1</a></span>
<span class="normal"><a href="#__codelineno-122-2">2</a></span>
<span class="normal"><a href="#__codelineno-122-3">3</a></span>
<span class="normal"><a href="#__codelineno-122-4">4</a></span>
<span class="normal"><a href="#__codelineno-122-5">5</a></span>
<span class="normal"><a href="#__codelineno-122-6">6</a></span>
<span class="normal"><a href="#__codelineno-122-7">7</a></span>
<span class="normal"><a href="#__codelineno-122-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-122-1" name="__codelineno-122-1"></a>case &#39;)&#39;:
<a id="__codelineno-122-2" name="__codelineno-122-2"></a>// 若栈为空，则说明有多余的右括号，则匹配失败
<a id="__codelineno-122-3" name="__codelineno-122-3"></a>if (!IsEmpty(&amp;S) &amp;&amp; GetTop(&amp;S) == &#39;(&#39;) {
<a id="__codelineno-122-4" name="__codelineno-122-4"></a>Pop(&amp;S, &amp;pop);
<a id="__codelineno-122-5" name="__codelineno-122-5"></a>} else {
<a id="__codelineno-122-6" name="__codelineno-122-6"></a>flag = 0 ;
<a id="__codelineno-122-7" name="__codelineno-122-7"></a>}
<a id="__codelineno-122-8" name="__codelineno-122-8"></a>break;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-123-1">1</a></span>
<span class="normal"><a href="#__codelineno-123-2">2</a></span>
<span class="normal"><a href="#__codelineno-123-3">3</a></span>
<span class="normal"><a href="#__codelineno-123-4">4</a></span>
<span class="normal"><a href="#__codelineno-123-5">5</a></span>
<span class="normal"><a href="#__codelineno-123-6">6</a></span>
<span class="normal"><a href="#__codelineno-123-7">7</a></span>
<span class="normal"><a href="#__codelineno-123-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-123-1" name="__codelineno-123-1"></a>case &#39;]&#39;:
<a id="__codelineno-123-2" name="__codelineno-123-2"></a>if (!IsEmpty(&amp;S) &amp;&amp; GetTop(&amp;S) == &#39;[&#39;) {
<a id="__codelineno-123-3" name="__codelineno-123-3"></a>Pop(&amp;S, &amp;pop);
<a id="__codelineno-123-4" name="__codelineno-123-4"></a>} else {
<a id="__codelineno-123-5" name="__codelineno-123-5"></a>flag = 0 ;
<a id="__codelineno-123-6" name="__codelineno-123-6"></a>}
<a id="__codelineno-123-7" name="__codelineno-123-7"></a>break;
<a id="__codelineno-123-8" name="__codelineno-123-8"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-124-1">1</a></span>
<span class="normal"><a href="#__codelineno-124-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-124-1" name="__codelineno-124-1"></a>scanf(&quot; %c&quot;, &amp;ch);
<a id="__codelineno-124-2" name="__codelineno-124-2"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-125-1">1</a></span>
<span class="normal"><a href="#__codelineno-125-2">2</a></span>
<span class="normal"><a href="#__codelineno-125-3">3</a></span>
<span class="normal"><a href="#__codelineno-125-4">4</a></span>
<span class="normal"><a href="#__codelineno-125-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-125-1" name="__codelineno-125-1"></a>if (flag &amp;&amp; IsEmpty(&amp;S))
<a id="__codelineno-125-2" name="__codelineno-125-2"></a>return TRUE;
<a id="__codelineno-125-3" name="__codelineno-125-3"></a>else
<a id="__codelineno-125-4" name="__codelineno-125-4"></a>return FALSE;
<a id="__codelineno-125-5" name="__codelineno-125-5"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-126-1">1</a></span>
<span class="normal"><a href="#__codelineno-126-2">2</a></span>
<span class="normal"><a href="#__codelineno-126-3">3</a></span>
<span class="normal"><a href="#__codelineno-126-4">4</a></span>
<span class="normal"><a href="#__codelineno-126-5">5</a></span>
<span class="normal"><a href="#__codelineno-126-6">6</a></span>
<span class="normal"><a href="#__codelineno-126-7">7</a></span>
<span class="normal"><a href="#__codelineno-126-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-126-1" name="__codelineno-126-1"></a>bool Matching_Parenthese(void) {
<a id="__codelineno-126-2" name="__codelineno-126-2"></a>SqStack S;
<a id="__codelineno-126-3" name="__codelineno-126-3"></a>InitStack(&amp;S);
<a id="__codelineno-126-4" name="__codelineno-126-4"></a>char x;
<a id="__codelineno-126-5" name="__codelineno-126-5"></a>char buffer[ 1024 ];
<a id="__codelineno-126-6" name="__codelineno-126-6"></a>scanf(&quot;%s&quot;, &amp;buffer);
<a id="__codelineno-126-7" name="__codelineno-126-7"></a>char *ptr = buffer;
<a id="__codelineno-126-8" name="__codelineno-126-8"></a>bool flag = true;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-127-1">1</a></span>
<span class="normal"><a href="#__codelineno-127-2">2</a></span>
<span class="normal"><a href="#__codelineno-127-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-127-1" name="__codelineno-127-1"></a>while (*ptr != &#39;\0&#39; &amp;&amp; flag) {
<a id="__codelineno-127-2" name="__codelineno-127-2"></a>if (*ptr == &#39;(&#39; || *ptr == &#39;[&#39;) {
<a id="__codelineno-127-3" name="__codelineno-127-3"></a>Push(&amp;S, *(ptr++));
</code></pre></div></td></tr></table></div></p>
<h4 id="10_1">10 以内的计算器<a class="headerlink" href="#10_1" title="Permanent link">&para;</a></h4>
<h6 id="10_2">写出一个只有加减乘除的计算器，要求每一步计算结果小于 10<a class="headerlink" href="#10_2" title="Permanent link">&para;</a></h6>
<h6 id="_218">运算符顺序要求如下(#代表结束标志，且#运算级最小)<a class="headerlink" href="#_218" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-128-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-128-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-128-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-128-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-128-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-128-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-128-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-128-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-128-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-128-10">10</a></span>
<span class="normal"><a href="#__codelineno-128-11">11</a></span>
<span class="normal"><a href="#__codelineno-128-12">12</a></span>
<span class="normal"><a href="#__codelineno-128-13">13</a></span>
<span class="normal"><a href="#__codelineno-128-14">14</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-128-1" name="__codelineno-128-1"></a>} else if (*ptr == &#39;)&#39;) {
<a id="__codelineno-128-2" name="__codelineno-128-2"></a>if (!IsEmpty(&amp;S) &amp;&amp; GetTop(&amp;S) == &#39;(&#39;) {
<a id="__codelineno-128-3" name="__codelineno-128-3"></a>Pop(&amp;S, &amp;x);
<a id="__codelineno-128-4" name="__codelineno-128-4"></a>ptr++;
<a id="__codelineno-128-5" name="__codelineno-128-5"></a>} else
<a id="__codelineno-128-6" name="__codelineno-128-6"></a>flag = false;
<a id="__codelineno-128-7" name="__codelineno-128-7"></a>} else if (*ptr == &#39;]&#39;) {
<a id="__codelineno-128-8" name="__codelineno-128-8"></a>if (!IsEmpty(&amp;S) &amp;&amp; GetTop(&amp;S) == &#39;[&#39;) {
<a id="__codelineno-128-9" name="__codelineno-128-9"></a>Pop(&amp;S, &amp;x);
<a id="__codelineno-128-10" name="__codelineno-128-10"></a>ptr++;
<a id="__codelineno-128-11" name="__codelineno-128-11"></a>} else
<a id="__codelineno-128-12" name="__codelineno-128-12"></a>flag = false;
<a id="__codelineno-128-13" name="__codelineno-128-13"></a>}
<a id="__codelineno-128-14" name="__codelineno-128-14"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-129-1">1</a></span>
<span class="normal"><a href="#__codelineno-129-2">2</a></span>
<span class="normal"><a href="#__codelineno-129-3">3</a></span>
<span class="normal"><a href="#__codelineno-129-4">4</a></span>
<span class="normal"><a href="#__codelineno-129-5">5</a></span>
<span class="normal"><a href="#__codelineno-129-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-129-1" name="__codelineno-129-1"></a>if (flag &amp;&amp; IsEmpty(&amp;S)) {
<a id="__codelineno-129-2" name="__codelineno-129-2"></a>return true;
<a id="__codelineno-129-3" name="__codelineno-129-3"></a>} else {
<a id="__codelineno-129-4" name="__codelineno-129-4"></a>return false;
<a id="__codelineno-129-5" name="__codelineno-129-5"></a>}
<a id="__codelineno-129-6" name="__codelineno-129-6"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-130-1">1</a></span>
<span class="normal"><a href="#__codelineno-130-2">2</a></span>
<span class="normal"><a href="#__codelineno-130-3">3</a></span>
<span class="normal"><a href="#__codelineno-130-4">4</a></span>
<span class="normal"><a href="#__codelineno-130-5">5</a></span>
<span class="normal"><a href="#__codelineno-130-6">6</a></span>
<span class="normal"><a href="#__codelineno-130-7">7</a></span>
<span class="normal"><a href="#__codelineno-130-8">8</a></span>
<span class="normal"><a href="#__codelineno-130-9">9</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-130-1" name="__codelineno-130-1"></a>char Evaluate() {
<a id="__codelineno-130-2" name="__codelineno-130-2"></a>SqStack opnd; //运算数栈
<a id="__codelineno-130-3" name="__codelineno-130-3"></a>SqStack optr; //运算符栈
<a id="__codelineno-130-4" name="__codelineno-130-4"></a>InitStack(&amp;opnd);
<a id="__codelineno-130-5" name="__codelineno-130-5"></a>InitStack(&amp;optr);
<a id="__codelineno-130-6" name="__codelineno-130-6"></a>Push(&amp;optr, &#39;#&#39;); //先把#结束表示压入运算符栈
<a id="__codelineno-130-7" name="__codelineno-130-7"></a>char ch, theta;
<a id="__codelineno-130-8" name="__codelineno-130-8"></a>char a, b;
<a id="__codelineno-130-9" name="__codelineno-130-9"></a>scanf(&quot; %c&quot;, &amp;ch);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-131-1">1</a></span>
<span class="normal"><a href="#__codelineno-131-2">2</a></span>
<span class="normal"><a href="#__codelineno-131-3">3</a></span>
<span class="normal"><a href="#__codelineno-131-4">4</a></span>
<span class="normal"><a href="#__codelineno-131-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-131-1" name="__codelineno-131-1"></a>while (&#39;#&#39; != ch || GetTop(&amp;optr) != &#39;#&#39;) {
<a id="__codelineno-131-2" name="__codelineno-131-2"></a>//先判断是否为运算符
<a id="__codelineno-131-3" name="__codelineno-131-3"></a>if (!IsOperator(ch)) {
<a id="__codelineno-131-4" name="__codelineno-131-4"></a>Push(&amp;opnd, ch);
<a id="__codelineno-131-5" name="__codelineno-131-5"></a>scanf(&quot; %c&quot;, &amp;ch);
</code></pre></div></td></tr></table></div></p>
<h6 id="_219">测试代码:<a class="headerlink" href="#_219" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-132-1">1</a></span>
<span class="normal"><a href="#__codelineno-132-2">2</a></span>
<span class="normal"><a href="#__codelineno-132-3">3</a></span>
<span class="normal"><a href="#__codelineno-132-4">4</a></span>
<span class="normal"><a href="#__codelineno-132-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-132-1" name="__codelineno-132-1"></a>} else {
<a id="__codelineno-132-2" name="__codelineno-132-2"></a>//比较栈顶运算符和输入运算符比较
<a id="__codelineno-132-3" name="__codelineno-132-3"></a>switch (Precede(GetTop(&amp;optr), ch)) {
<a id="__codelineno-132-4" name="__codelineno-132-4"></a>//输入运算符大于栈顶运算符，则入栈
<a id="__codelineno-132-5" name="__codelineno-132-5"></a>case &#39;&lt;&#39;:
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-133-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-133-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-133-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-133-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-133-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-133-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-133-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-133-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-133-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-133-10">10</a></span>
<span class="normal"><a href="#__codelineno-133-11">11</a></span>
<span class="normal"><a href="#__codelineno-133-12">12</a></span>
<span class="normal"><a href="#__codelineno-133-13">13</a></span>
<span class="normal"><a href="#__codelineno-133-14">14</a></span>
<span class="normal"><a href="#__codelineno-133-15">15</a></span>
<span class="normal"><a href="#__codelineno-133-16">16</a></span>
<span class="normal"><a href="#__codelineno-133-17">17</a></span>
<span class="normal"><a href="#__codelineno-133-18">18</a></span>
<span class="normal"><a href="#__codelineno-133-19">19</a></span>
<span class="normal"><a href="#__codelineno-133-20">20</a></span>
<span class="normal"><a href="#__codelineno-133-21">21</a></span>
<span class="normal"><a href="#__codelineno-133-22">22</a></span>
<span class="normal"><a href="#__codelineno-133-23">23</a></span>
<span class="normal"><a href="#__codelineno-133-24">24</a></span>
<span class="normal"><a href="#__codelineno-133-25">25</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-133-1" name="__codelineno-133-1"></a>Push(&amp;optr, ch);
<a id="__codelineno-133-2" name="__codelineno-133-2"></a>//开始读取下一个运算符
<a id="__codelineno-133-3" name="__codelineno-133-3"></a>scanf(&quot; %c&quot;, &amp;ch);
<a id="__codelineno-133-4" name="__codelineno-133-4"></a>break;
<a id="__codelineno-133-5" name="__codelineno-133-5"></a>//如果输入运算符小于栈顶运算符，弹出optr栈顶运算符，并弹出opnd的两个运算数，进行运算
<a id="__codelineno-133-6" name="__codelineno-133-6"></a>case &#39;&gt;&#39;:
<a id="__codelineno-133-7" name="__codelineno-133-7"></a>Pop(&amp;optr, &amp;theta);
<a id="__codelineno-133-8" name="__codelineno-133-8"></a>Pop(&amp;opnd, &amp;a);
<a id="__codelineno-133-9" name="__codelineno-133-9"></a>Pop(&amp;opnd, &amp;b);
<a id="__codelineno-133-10" name="__codelineno-133-10"></a>//把运算结果入栈
<a id="__codelineno-133-11" name="__codelineno-133-11"></a>Push(&amp;opnd, operate(a, theta, b)); //
<a id="__codelineno-133-12" name="__codelineno-133-12"></a>//注意此时并没有对输入运算符ch进行任何操作，所以不用往后读取字符，
<a id="__codelineno-133-13" name="__codelineno-133-13"></a>//即不需要scanf(&quot;%c&quot;, &amp;ch);
<a id="__codelineno-133-14" name="__codelineno-133-14"></a>break;
<a id="__codelineno-133-15" name="__codelineno-133-15"></a>//如果相等则说明括号匹配结束
<a id="__codelineno-133-16" name="__codelineno-133-16"></a>case &#39;=&#39;:
<a id="__codelineno-133-17" name="__codelineno-133-17"></a>Pop(&amp;optr, &amp;theta);
<a id="__codelineno-133-18" name="__codelineno-133-18"></a>scanf(&quot; %c&quot;, &amp;ch);
<a id="__codelineno-133-19" name="__codelineno-133-19"></a>break;
<a id="__codelineno-133-20" name="__codelineno-133-20"></a>}
<a id="__codelineno-133-21" name="__codelineno-133-21"></a>}
<a id="__codelineno-133-22" name="__codelineno-133-22"></a>}
<a id="__codelineno-133-23" name="__codelineno-133-23"></a>//返回opnd栈顶，表达式的最终结果
<a id="__codelineno-133-24" name="__codelineno-133-24"></a>return GetTop(&amp;opnd);
<a id="__codelineno-133-25" name="__codelineno-133-25"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-134-1">1</a></span>
<span class="normal"><a href="#__codelineno-134-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-134-1" name="__codelineno-134-1"></a>#include &quot;Stack.h&quot;
<a id="__codelineno-134-2" name="__codelineno-134-2"></a>#define OPERATORMAX 7
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-135-1">1</a></span>
<span class="normal"><a href="#__codelineno-135-2">2</a></span>
<span class="normal"><a href="#__codelineno-135-3">3</a></span>
<span class="normal"><a href="#__codelineno-135-4">4</a></span>
<span class="normal"><a href="#__codelineno-135-5">5</a></span>
<span class="normal"><a href="#__codelineno-135-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-135-1" name="__codelineno-135-1"></a>char operators[OPERATORMAX] = {&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;, &#39;(&#39;, &#39;)&#39;, &#39;#&#39;};
<a id="__codelineno-135-2" name="__codelineno-135-2"></a>int LocateChar(char *array, char theta);
<a id="__codelineno-135-3" name="__codelineno-135-3"></a>char operate(char a, char theta, char b);
<a id="__codelineno-135-4" name="__codelineno-135-4"></a>char Precede(char theta1, char theta2);
<a id="__codelineno-135-5" name="__codelineno-135-5"></a>char Evaluate(void);
<a id="__codelineno-135-6" name="__codelineno-135-6"></a>int main(void) {
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-136-1">1</a></span>
<span class="normal"><a href="#__codelineno-136-2">2</a></span>
<span class="normal"><a href="#__codelineno-136-3">3</a></span>
<span class="normal"><a href="#__codelineno-136-4">4</a></span>
<span class="normal"><a href="#__codelineno-136-5">5</a></span>
<span class="normal"><a href="#__codelineno-136-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-136-1" name="__codelineno-136-1"></a>printf(&quot;%c &quot;, Evaluate());
<a id="__codelineno-136-2" name="__codelineno-136-2"></a>// printf(&quot;%c&quot;, Precede(&#39;(&#39;, &#39;/&#39;));
<a id="__codelineno-136-3" name="__codelineno-136-3"></a>// printf(&quot;%c&quot;, operate(&#39;2&#39;, &#39;*&#39;, &#39;4&#39;));
<a id="__codelineno-136-4" name="__codelineno-136-4"></a>system(&quot;pause&quot;);
<a id="__codelineno-136-5" name="__codelineno-136-5"></a>return 0 ;
<a id="__codelineno-136-6" name="__codelineno-136-6"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-137-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-137-1" name="__codelineno-137-1"></a>char Precede(char theta1, char theta2) {
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-138-1">1</a></span>
<span class="normal"><a href="#__codelineno-138-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-138-1" name="__codelineno-138-1"></a>int index1 = LocateChar(operators, theta1);
<a id="__codelineno-138-2" name="__codelineno-138-2"></a>int index2 = LocateChar(operators, theta2);
</code></pre></div></td></tr></table></div></p>
<h2 id="3_4">3. 字符串，数组，广义表<a class="headerlink" href="#3_4" title="Permanent link">&para;</a></h2>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-139-1">1</a></span>
<span class="normal"><a href="#__codelineno-139-2">2</a></span>
<span class="normal"><a href="#__codelineno-139-3">3</a></span>
<span class="normal"><a href="#__codelineno-139-4">4</a></span>
<span class="normal"><a href="#__codelineno-139-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-139-1" name="__codelineno-139-1"></a>char precedences[OPERATORMAX][OPERATORMAX] = {
<a id="__codelineno-139-2" name="__codelineno-139-2"></a>{&#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;}, {&#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;},
<a id="__codelineno-139-3" name="__codelineno-139-3"></a>{&#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;}, {&#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;},
<a id="__codelineno-139-4" name="__codelineno-139-4"></a>{&#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;=&#39;, 0 }, {&#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, 0 , &#39;&gt;&#39;, &#39;&gt;&#39;},
<a id="__codelineno-139-5" name="__codelineno-139-5"></a>{&#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, 0 , &#39;=&#39;}};
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-140-1">1</a></span>
<span class="normal"><a href="#__codelineno-140-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-140-1" name="__codelineno-140-1"></a>return precedences[index1][index2];
<a id="__codelineno-140-2" name="__codelineno-140-2"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-141-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-141-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-141-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-141-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-141-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-141-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-141-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-141-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-141-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-141-10">10</a></span>
<span class="normal"><a href="#__codelineno-141-11">11</a></span>
<span class="normal"><a href="#__codelineno-141-12">12</a></span>
<span class="normal"><a href="#__codelineno-141-13">13</a></span>
<span class="normal"><a href="#__codelineno-141-14">14</a></span>
<span class="normal"><a href="#__codelineno-141-15">15</a></span>
<span class="normal"><a href="#__codelineno-141-16">16</a></span>
<span class="normal"><a href="#__codelineno-141-17">17</a></span>
<span class="normal"><a href="#__codelineno-141-18">18</a></span>
<span class="normal"><a href="#__codelineno-141-19">19</a></span>
<span class="normal"><a href="#__codelineno-141-20">20</a></span>
<span class="normal"><a href="#__codelineno-141-21">21</a></span>
<span class="normal"><a href="#__codelineno-141-22">22</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-141-1" name="__codelineno-141-1"></a>char operate(char a, char theta, char b) {
<a id="__codelineno-141-2" name="__codelineno-141-2"></a>int val_a = atoi(&amp;a);
<a id="__codelineno-141-3" name="__codelineno-141-3"></a>int val_b = atoi(&amp;b);
<a id="__codelineno-141-4" name="__codelineno-141-4"></a>int result;
<a id="__codelineno-141-5" name="__codelineno-141-5"></a>switch (theta) {
<a id="__codelineno-141-6" name="__codelineno-141-6"></a>case &#39;+&#39;:
<a id="__codelineno-141-7" name="__codelineno-141-7"></a>result = val_a + val_b;
<a id="__codelineno-141-8" name="__codelineno-141-8"></a>break;
<a id="__codelineno-141-9" name="__codelineno-141-9"></a>case &#39;-&#39;:
<a id="__codelineno-141-10" name="__codelineno-141-10"></a>result = val_a - val_b;
<a id="__codelineno-141-11" name="__codelineno-141-11"></a>break;
<a id="__codelineno-141-12" name="__codelineno-141-12"></a>case &#39;*&#39;:
<a id="__codelineno-141-13" name="__codelineno-141-13"></a>result = val_a * val_b;
<a id="__codelineno-141-14" name="__codelineno-141-14"></a>break;
<a id="__codelineno-141-15" name="__codelineno-141-15"></a>case &#39;/&#39;:
<a id="__codelineno-141-16" name="__codelineno-141-16"></a>result = val_a / val_b;
<a id="__codelineno-141-17" name="__codelineno-141-17"></a>break;
<a id="__codelineno-141-18" name="__codelineno-141-18"></a>}
<a id="__codelineno-141-19" name="__codelineno-141-19"></a>char val[ 24 ];
<a id="__codelineno-141-20" name="__codelineno-141-20"></a>itoa(result, val, 10 );
<a id="__codelineno-141-21" name="__codelineno-141-21"></a>return val[ 0 ];
<a id="__codelineno-141-22" name="__codelineno-141-22"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-142-1">1</a></span>
<span class="normal"><a href="#__codelineno-142-2">2</a></span>
<span class="normal"><a href="#__codelineno-142-3">3</a></span>
<span class="normal"><a href="#__codelineno-142-4">4</a></span>
<span class="normal"><a href="#__codelineno-142-5">5</a></span>
<span class="normal"><a href="#__codelineno-142-6">6</a></span>
<span class="normal"><a href="#__codelineno-142-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-142-1" name="__codelineno-142-1"></a>int LocateChar(char *array, char theta) {
<a id="__codelineno-142-2" name="__codelineno-142-2"></a>for (int i = 0 ; i &lt; OPERATORMAX; i++) {
<a id="__codelineno-142-3" name="__codelineno-142-3"></a>if (array[i] == theta)
<a id="__codelineno-142-4" name="__codelineno-142-4"></a>return i;
<a id="__codelineno-142-5" name="__codelineno-142-5"></a>}
<a id="__codelineno-142-6" name="__codelineno-142-6"></a>return - 1 ;
<a id="__codelineno-142-7" name="__codelineno-142-7"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-143-1">1</a></span>
<span class="normal"><a href="#__codelineno-143-2">2</a></span>
<span class="normal"><a href="#__codelineno-143-3">3</a></span>
<span class="normal"><a href="#__codelineno-143-4">4</a></span>
<span class="normal"><a href="#__codelineno-143-5">5</a></span>
<span class="normal"><a href="#__codelineno-143-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-143-1" name="__codelineno-143-1"></a>bool IsOperator(char a) {
<a id="__codelineno-143-2" name="__codelineno-143-2"></a>if (- 1 == LocateChar(operators, a)) {
<a id="__codelineno-143-3" name="__codelineno-143-3"></a>return false;
<a id="__codelineno-143-4" name="__codelineno-143-4"></a>} else
<a id="__codelineno-143-5" name="__codelineno-143-5"></a>return true;
<a id="__codelineno-143-6" name="__codelineno-143-6"></a>}
</code></pre></div></td></tr></table></div></p>
<h4 id="_220">字符串匹配<a class="headerlink" href="#_220" title="Permanent link">&para;</a></h4>
<h6 id="_221">字符串的存储结构可以分为两类：<a class="headerlink" href="#_221" title="Permanent link">&para;</a></h6>
<h6 id="_222">顺序存储结构：<a class="headerlink" href="#_222" title="Permanent link">&para;</a></h6>
<h6 id="_223">链式存储结构：<a class="headerlink" href="#_223" title="Permanent link">&para;</a></h6>
<h6 id="_224">本笔记只记录顺序存储结构的字符串<a class="headerlink" href="#_224" title="Permanent link">&para;</a></h6>
<h6 id="_225">输入字符串函数和初始化<a class="headerlink" href="#_225" title="Permanent link">&para;</a></h6>
<h6 id="bfbrute-force_1">BF算法(Brute Force)<a class="headerlink" href="#bfbrute-force_1" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-144-1">1</a></span>
<span class="normal"><a href="#__codelineno-144-2">2</a></span>
<span class="normal"><a href="#__codelineno-144-3">3</a></span>
<span class="normal"><a href="#__codelineno-144-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-144-1" name="__codelineno-144-1"></a>typedef struct __SString {
<a id="__codelineno-144-2" name="__codelineno-144-2"></a>char ch[MAXLEN + 1 ]; //为了代码理解方便，不使用数组 0 号位置
<a id="__codelineno-144-3" name="__codelineno-144-3"></a>int length;
<a id="__codelineno-144-4" name="__codelineno-144-4"></a>} SString;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-145-1">1</a></span>
<span class="normal"><a href="#__codelineno-145-2">2</a></span>
<span class="normal"><a href="#__codelineno-145-3">3</a></span>
<span class="normal"><a href="#__codelineno-145-4">4</a></span>
<span class="normal"><a href="#__codelineno-145-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-145-1" name="__codelineno-145-1"></a>#define CHUNKSIZE 80 //每一节点的最大长度
<a id="__codelineno-145-2" name="__codelineno-145-2"></a>typedef struct __Chunk {
<a id="__codelineno-145-3" name="__codelineno-145-3"></a>char ch[CHUNKSIZE + 1 ];
<a id="__codelineno-145-4" name="__codelineno-145-4"></a>__Chunk *next;
<a id="__codelineno-145-5" name="__codelineno-145-5"></a>} Chunk;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-146-1">1</a></span>
<span class="normal"><a href="#__codelineno-146-2">2</a></span>
<span class="normal"><a href="#__codelineno-146-3">3</a></span>
<span class="normal"><a href="#__codelineno-146-4">4</a></span>
<span class="normal"><a href="#__codelineno-146-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-146-1" name="__codelineno-146-1"></a>typedef struct __LString {
<a id="__codelineno-146-2" name="__codelineno-146-2"></a>Chunk *head, *tail;
<a id="__codelineno-146-3" name="__codelineno-146-3"></a>int curlen; //当前字符串长度
<a id="__codelineno-146-4" name="__codelineno-146-4"></a>} LString;
<a id="__codelineno-146-5" name="__codelineno-146-5"></a>#endif
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-147-1">1</a></span>
<span class="normal"><a href="#__codelineno-147-2">2</a></span>
<span class="normal"><a href="#__codelineno-147-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-147-1" name="__codelineno-147-1"></a>int GetLength(SString *S) {
<a id="__codelineno-147-2" name="__codelineno-147-2"></a>int cnt = 0 ;
<a id="__codelineno-147-3" name="__codelineno-147-3"></a>int i = 1 ; //因为不使用 0 号位置，从 1 开始
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-148-1">1</a></span>
<span class="normal"><a href="#__codelineno-148-2">2</a></span>
<span class="normal"><a href="#__codelineno-148-3">3</a></span>
<span class="normal"><a href="#__codelineno-148-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-148-1" name="__codelineno-148-1"></a>while (S-&gt;ch[i] != &#39;\0&#39;) {
<a id="__codelineno-148-2" name="__codelineno-148-2"></a>i++;
<a id="__codelineno-148-3" name="__codelineno-148-3"></a>cnt++;
<a id="__codelineno-148-4" name="__codelineno-148-4"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-149-1">1</a></span>
<span class="normal"><a href="#__codelineno-149-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-149-1" name="__codelineno-149-1"></a>return cnt;
<a id="__codelineno-149-2" name="__codelineno-149-2"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-150-1">1</a></span>
<span class="normal"><a href="#__codelineno-150-2">2</a></span>
<span class="normal"><a href="#__codelineno-150-3">3</a></span>
<span class="normal"><a href="#__codelineno-150-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-150-1" name="__codelineno-150-1"></a>void InputString(SString *S) {
<a id="__codelineno-150-2" name="__codelineno-150-2"></a>scanf(&quot; %s&quot;, &amp;S-&gt;ch[ 1 ]);
<a id="__codelineno-150-3" name="__codelineno-150-3"></a>S-&gt;length = GetLength(S);
<a id="__codelineno-150-4" name="__codelineno-150-4"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-151-1">1</a></span>
<span class="normal"><a href="#__codelineno-151-2">2</a></span>
<span class="normal"><a href="#__codelineno-151-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-151-1" name="__codelineno-151-1"></a>int BF_Match(SString S, SString T, int position) {
<a id="__codelineno-151-2" name="__codelineno-151-2"></a>int i = position;
<a id="__codelineno-151-3" name="__codelineno-151-3"></a>int j = 1 ;
</code></pre></div></td></tr></table></div></p>
<h6 id="bf">BF算法效率分析<a class="headerlink" href="#bf" title="Permanent link">&para;</a></h6>
<h6 id="_226">令主串长度为 子串长度为 ，若从主串的第个位置开始与模式串匹配成功<a class="headerlink" href="#_226" title="Permanent link">&para;</a></h6>
<h6 id="_227">则在前 趟匹配中字符总共比较了 次<a class="headerlink" href="#_227" title="Permanent link">&para;</a></h6>
<h6 id="_228">若第趟匹配成功，则比较次数为 ，总比较次数为<a class="headerlink" href="#_228" title="Permanent link">&para;</a></h6>
<h6 id="_229">即<a class="headerlink" href="#_229" title="Permanent link">&para;</a></h6>
<h6 id="_230">最坏情况<a class="headerlink" href="#_230" title="Permanent link">&para;</a></h6>
<h6 id="_231">假设从主串对的第个位置开始与模式串匹配成功，则在前 趟中总共比较了 次<a class="headerlink" href="#_231" title="Permanent link">&para;</a></h6>
<h6 id="_232">若第趟匹配成功，则第趟需要 次匹配，总比较次数为<a class="headerlink" href="#_232" title="Permanent link">&para;</a></h6>
<h6 id="kmp_1">KMP算法<a class="headerlink" href="#kmp_1" title="Permanent link">&para;</a></h6>
<h6 id="_233">令字符串 ，和模式串<a class="headerlink" href="#_233" title="Permanent link">&para;</a></h6>
<h6 id="_234">匹配到 和 时失匹 则<a class="headerlink" href="#_234" title="Permanent link">&para;</a></h6>
<h6 id="_235">下标由来： 为失匹之前成功匹配的子串长度<a class="headerlink" href="#_235" title="Permanent link">&para;</a></h6>
<h6 id="_236">指向 中失配字符，则有<a class="headerlink" href="#_236" title="Permanent link">&para;</a></h6>
<h6 id="_237">下标由来：<a class="headerlink" href="#_237" title="Permanent link">&para;</a></h6>
<h6 id="_238">由 可知，<a class="headerlink" href="#_238" title="Permanent link">&para;</a></h6>
<h6 id="_239">由 可知，如果 和 失匹，无需从 开始和 比较，只需要把 滑动到 的位置比较即可<a class="headerlink" href="#_239" title="Permanent link">&para;</a></h6>
<h6 id="_240">令 表示在匹配中 失匹时，让 与 比较<a class="headerlink" href="#_240" title="Permanent link">&para;</a></h6>
<h6 id="_241">可得<a class="headerlink" href="#_241" title="Permanent link">&para;</a></h6>
<h6 id="_242">，因为当 失匹时字符串来到 位置空串，有 空串<a class="headerlink" href="#_242" title="Permanent link">&para;</a></h6>
<h6 id="_243">且<a class="headerlink" href="#_243" title="Permanent link">&para;</a></h6>
<h6 id="_244">需要从 开始重新比较<a class="headerlink" href="#_244" title="Permanent link">&para;</a></h6>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-152-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-152-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-152-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-152-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-152-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-152-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-152-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-152-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-152-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-152-10">10</a></span>
<span class="normal"><a href="#__codelineno-152-11">11</a></span>
<span class="normal"><a href="#__codelineno-152-12">12</a></span>
<span class="normal"><a href="#__codelineno-152-13">13</a></span>
<span class="normal"><a href="#__codelineno-152-14">14</a></span>
<span class="normal"><a href="#__codelineno-152-15">15</a></span>
<span class="normal"><a href="#__codelineno-152-16">16</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-152-1" name="__codelineno-152-1"></a>while (i &lt;= S.length &amp;&amp; j &lt;= T.length) {
<a id="__codelineno-152-2" name="__codelineno-152-2"></a>if (S.ch[i] == T.ch[j]) {
<a id="__codelineno-152-3" name="__codelineno-152-3"></a>i++;
<a id="__codelineno-152-4" name="__codelineno-152-4"></a>j++;
<a id="__codelineno-152-5" name="__codelineno-152-5"></a>} else {
<a id="__codelineno-152-6" name="__codelineno-152-6"></a>// i-j+1 是回溯到初始匹配位置
<a id="__codelineno-152-7" name="__codelineno-152-7"></a>i = i - j + 1 + 1 ;
<a id="__codelineno-152-8" name="__codelineno-152-8"></a>j = 1 ;
<a id="__codelineno-152-9" name="__codelineno-152-9"></a>}
<a id="__codelineno-152-10" name="__codelineno-152-10"></a>}
<a id="__codelineno-152-11" name="__codelineno-152-11"></a>//如果匹配成功，那么此时i和j都会自增+1，此时j&gt;T.length
<a id="__codelineno-152-12" name="__codelineno-152-12"></a>if (j &gt; T.length)
<a id="__codelineno-152-13" name="__codelineno-152-13"></a>return i - T.length;
<a id="__codelineno-152-14" name="__codelineno-152-14"></a>else
<a id="__codelineno-152-15" name="__codelineno-152-15"></a>return 0 ;
<a id="__codelineno-152-16" name="__codelineno-152-16"></a>}
</code></pre></div></td></tr></table></div>
<h6 id="next_2">求next数组<a class="headerlink" href="#next_2" title="Permanent link">&para;</a></h6>
<h6 id="_245">求 数组的过程实际上是 的过程，即如果存在，那么 必然存在<a class="headerlink" href="#_245" title="Permanent link">&para;</a></h6>
<h6 id="_246">也是模式串的字串匹配模式串的过程<a class="headerlink" href="#_246" title="Permanent link">&para;</a></h6>
<h6 id="_247">设 即有<a class="headerlink" href="#_247" title="Permanent link">&para;</a></h6>
<h6 id="_248">第一种情况<a class="headerlink" href="#_248" title="Permanent link">&para;</a></h6>
<h6 id="_249">此时则有<a class="headerlink" href="#_249" title="Permanent link">&para;</a></h6>
<h6 id="_250">那么则有<a class="headerlink" href="#_250" title="Permanent link">&para;</a></h6>
<h6 id="_251">第二种情况<a class="headerlink" href="#_251" title="Permanent link">&para;</a></h6>
<h6 id="_252">说明在 处失匹，则回溯到<a class="headerlink" href="#_252" title="Permanent link">&para;</a></h6>
<h6 id="_253">如果 如下图<a class="headerlink" href="#_253" title="Permanent link">&para;</a></h6>
<h6 id="_254">那么<a class="headerlink" href="#_254" title="Permanent link">&para;</a></h6>
<h6 id="_255">如果<a class="headerlink" href="#_255" title="Permanent link">&para;</a></h6>
<h6 id="_256">那么一直回溯 若出现 则同上，若未出现<a class="headerlink" href="#_256" title="Permanent link">&para;</a></h6>
<h6 id="next_3">未优化前，求next数组<a class="headerlink" href="#next_3" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-153-1">1</a></span>
<span class="normal"><a href="#__codelineno-153-2">2</a></span>
<span class="normal"><a href="#__codelineno-153-3">3</a></span>
<span class="normal"><a href="#__codelineno-153-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-153-1" name="__codelineno-153-1"></a>void GetNext(SString T, int *next) {
<a id="__codelineno-153-2" name="__codelineno-153-2"></a>next[ 1 ] = 0 ;
<a id="__codelineno-153-3" name="__codelineno-153-3"></a>int j = 0 ;
<a id="__codelineno-153-4" name="__codelineno-153-4"></a>int i = 1 ;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-154-1">1</a></span>
<span class="normal"><a href="#__codelineno-154-2">2</a></span>
<span class="normal"><a href="#__codelineno-154-3">3</a></span>
<span class="normal"><a href="#__codelineno-154-4">4</a></span>
<span class="normal"><a href="#__codelineno-154-5">5</a></span>
<span class="normal"><a href="#__codelineno-154-6">6</a></span>
<span class="normal"><a href="#__codelineno-154-7">7</a></span>
<span class="normal"><a href="#__codelineno-154-8">8</a></span>
<span class="normal"><a href="#__codelineno-154-9">9</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-154-1" name="__codelineno-154-1"></a>while (i &lt; T.length) {
<a id="__codelineno-154-2" name="__codelineno-154-2"></a>if ( 0 == j || T.ch[i] == T.ch[j]) {
<a id="__codelineno-154-3" name="__codelineno-154-3"></a>i++, j++;
<a id="__codelineno-154-4" name="__codelineno-154-4"></a>next[i] = j;
<a id="__codelineno-154-5" name="__codelineno-154-5"></a>} else {
<a id="__codelineno-154-6" name="__codelineno-154-6"></a>j = next[j];
<a id="__codelineno-154-7" name="__codelineno-154-7"></a>}
<a id="__codelineno-154-8" name="__codelineno-154-8"></a>}
<a id="__codelineno-154-9" name="__codelineno-154-9"></a>}
</code></pre></div></td></tr></table></div></p>
<h6 id="_257">考虑如下问题，如果回溯的 也等于 会出现什么问题<a class="headerlink" href="#_257" title="Permanent link">&para;</a></h6>
<h6 id="_258">会出现无意义比较，解决办法让 也进行回溯<a class="headerlink" href="#_258" title="Permanent link">&para;</a></h6>
<h6 id="_259">优化后<a class="headerlink" href="#_259" title="Permanent link">&para;</a></h6>
<h6 id="kmp_2">KMP算法<a class="headerlink" href="#kmp_2" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-155-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-155-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-155-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-155-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-155-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-155-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-155-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-155-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-155-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-155-10">10</a></span>
<span class="normal"><a href="#__codelineno-155-11">11</a></span>
<span class="normal"><a href="#__codelineno-155-12">12</a></span>
<span class="normal"><a href="#__codelineno-155-13">13</a></span>
<span class="normal"><a href="#__codelineno-155-14">14</a></span>
<span class="normal"><a href="#__codelineno-155-15">15</a></span>
<span class="normal"><a href="#__codelineno-155-16">16</a></span>
<span class="normal"><a href="#__codelineno-155-17">17</a></span>
<span class="normal"><a href="#__codelineno-155-18">18</a></span>
<span class="normal"><a href="#__codelineno-155-19">19</a></span>
<span class="normal"><a href="#__codelineno-155-20">20</a></span>
<span class="normal"><a href="#__codelineno-155-21">21</a></span>
<span class="normal"><a href="#__codelineno-155-22">22</a></span>
<span class="normal"><a href="#__codelineno-155-23">23</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-155-1" name="__codelineno-155-1"></a>void GetNext(SString T, int *next) {
<a id="__codelineno-155-2" name="__codelineno-155-2"></a>next[ 1 ] = 0 ;
<a id="__codelineno-155-3" name="__codelineno-155-3"></a>int j = 0 ;
<a id="__codelineno-155-4" name="__codelineno-155-4"></a>int i = 1 ;
<a id="__codelineno-155-5" name="__codelineno-155-5"></a>//! 注意:while里面 不能写i&lt;=T.length，因为如果这么写，那么i经过++后,i=T.length+1
<a id="__codelineno-155-6" name="__codelineno-155-6"></a>//! 因为操作的内存是动态的，这样会导致内存泄漏
<a id="__codelineno-155-7" name="__codelineno-155-7"></a>//! 所以必须是i&lt;T.length，这样最后i才会指向T.length
<a id="__codelineno-155-8" name="__codelineno-155-8"></a>while (i &lt; T.length) {
<a id="__codelineno-155-9" name="__codelineno-155-9"></a>if ( 0 == j || T.ch[i] == T.ch[j]) {
<a id="__codelineno-155-10" name="__codelineno-155-10"></a>i++, j++;
<a id="__codelineno-155-11" name="__codelineno-155-11"></a>//在未优化之前，如果ch[i]匹配失败，那么会回溯到ch[j]上
<a id="__codelineno-155-12" name="__codelineno-155-12"></a>//如果ch[j] == ch[i]那么说明匹配仍然会失败，因为ch[i]匹配失败
<a id="__codelineno-155-13" name="__codelineno-155-13"></a>if (T.ch[i] == T.ch[j]) {
<a id="__codelineno-155-14" name="__codelineno-155-14"></a>//在i++,j++之后提前判断是否相等
<a id="__codelineno-155-15" name="__codelineno-155-15"></a>next[i] = next[j];
<a id="__codelineno-155-16" name="__codelineno-155-16"></a>} else {
<a id="__codelineno-155-17" name="__codelineno-155-17"></a>next[i] = j;
<a id="__codelineno-155-18" name="__codelineno-155-18"></a>}
<a id="__codelineno-155-19" name="__codelineno-155-19"></a>} else {
<a id="__codelineno-155-20" name="__codelineno-155-20"></a>j = next[j];
<a id="__codelineno-155-21" name="__codelineno-155-21"></a>}
<a id="__codelineno-155-22" name="__codelineno-155-22"></a>}
<a id="__codelineno-155-23" name="__codelineno-155-23"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-156-1">1</a></span>
<span class="normal"><a href="#__codelineno-156-2">2</a></span>
<span class="normal"><a href="#__codelineno-156-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-156-1" name="__codelineno-156-1"></a>int KMP_Match(SString S, SString T, int position) {
<a id="__codelineno-156-2" name="__codelineno-156-2"></a>int *next = (int *)malloc(sizeof(int) * (T.length + 1 ));
<a id="__codelineno-156-3" name="__codelineno-156-3"></a>GetNext(T, next);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-157-1">1</a></span>
<span class="normal"><a href="#__codelineno-157-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-157-1" name="__codelineno-157-1"></a>int i = position;
<a id="__codelineno-157-2" name="__codelineno-157-2"></a>int j = 1 ;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-158-1">1</a></span>
<span class="normal"><a href="#__codelineno-158-2">2</a></span>
<span class="normal"><a href="#__codelineno-158-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-158-1" name="__codelineno-158-1"></a>while (i &lt;= S.length &amp;&amp; j &lt;= T.length) {
<a id="__codelineno-158-2" name="__codelineno-158-2"></a>if (j == 0 || S.ch[i] == T.ch[j]) {
<a id="__codelineno-158-3" name="__codelineno-158-3"></a>i++, j++;
</code></pre></div></td></tr></table></div></p>
<h6 id="_260">测试代码<a class="headerlink" href="#_260" title="Permanent link">&para;</a></h6>
<h6 id="_261">字符串匹配玩具<a class="headerlink" href="#_261" title="Permanent link">&para;</a></h6>
<h6 id="_262">输入一个病毒序列长度为 ，从文件中读取病人样本，确认病人是否被感染<a class="headerlink" href="#_262" title="Permanent link">&para;</a></h6>
<h6 id="_263">注意 病毒序列是环状的<a class="headerlink" href="#_263" title="Permanent link">&para;</a></h6>
<h6 id="_264">比如病毒序列为 那么 都属于病毒<a class="headerlink" href="#_264" title="Permanent link">&para;</a></h6>
<h6 id="_265">思路 利用一个数组存储病毒序列，并把该序列扩大到 长度，依此比较<a class="headerlink" href="#_265" title="Permanent link">&para;</a></h6>
<h6 id="_266">实现代码<a class="headerlink" href="#_266" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-159-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-159-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-159-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-159-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-159-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-159-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-159-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-159-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-159-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-159-10">10</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-159-1" name="__codelineno-159-1"></a>} else {
<a id="__codelineno-159-2" name="__codelineno-159-2"></a>j = next[j];
<a id="__codelineno-159-3" name="__codelineno-159-3"></a>}
<a id="__codelineno-159-4" name="__codelineno-159-4"></a>}
<a id="__codelineno-159-5" name="__codelineno-159-5"></a>free(next);
<a id="__codelineno-159-6" name="__codelineno-159-6"></a>if (j &gt; T.length)
<a id="__codelineno-159-7" name="__codelineno-159-7"></a>return i - j;
<a id="__codelineno-159-8" name="__codelineno-159-8"></a>else
<a id="__codelineno-159-9" name="__codelineno-159-9"></a>return 0 ;
<a id="__codelineno-159-10" name="__codelineno-159-10"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-160-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-160-1" name="__codelineno-160-1"></a>#include &quot;SString.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-161-1">1</a></span>
<span class="normal"><a href="#__codelineno-161-2">2</a></span>
<span class="normal"><a href="#__codelineno-161-3">3</a></span>
<span class="normal"><a href="#__codelineno-161-4">4</a></span>
<span class="normal"><a href="#__codelineno-161-5">5</a></span>
<span class="normal"><a href="#__codelineno-161-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-161-1" name="__codelineno-161-1"></a>int main(void) {
<a id="__codelineno-161-2" name="__codelineno-161-2"></a>SString S, T;
<a id="__codelineno-161-3" name="__codelineno-161-3"></a>InputString(&amp;S);
<a id="__codelineno-161-4" name="__codelineno-161-4"></a>InputString(&amp;T);
<a id="__codelineno-161-5" name="__codelineno-161-5"></a>int i = KMP_Match(S, T, 1 ); //把KMP改成BF就是BF算法
<a id="__codelineno-161-6" name="__codelineno-161-6"></a>printf(&quot;%d&quot;, i);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-162-1">1</a></span>
<span class="normal"><a href="#__codelineno-162-2">2</a></span>
<span class="normal"><a href="#__codelineno-162-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-162-1" name="__codelineno-162-1"></a>system(&quot;pause&quot;);
<a id="__codelineno-162-2" name="__codelineno-162-2"></a>return 0 ;
<a id="__codelineno-162-3" name="__codelineno-162-3"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-163-1">1</a></span>
<span class="normal"><a href="#__codelineno-163-2">2</a></span>
<span class="normal"><a href="#__codelineno-163-3">3</a></span>
<span class="normal"><a href="#__codelineno-163-4">4</a></span>
<span class="normal"><a href="#__codelineno-163-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-163-1" name="__codelineno-163-1"></a>#include &quot;SString.h&quot;
<a id="__codelineno-163-2" name="__codelineno-163-2"></a>#include &lt;fstream&gt;
<a id="__codelineno-163-3" name="__codelineno-163-3"></a>#define FILENAME &quot;Virus.txt&quot;
<a id="__codelineno-163-4" name="__codelineno-163-4"></a>//获取文件中样本个数
<a id="__codelineno-163-5" name="__codelineno-163-5"></a>int File_GetNumber();
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-164-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-164-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-164-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-164-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-164-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-164-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-164-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-164-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-164-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-164-10">10</a></span>
<span class="normal"><a href="#__codelineno-164-11">11</a></span>
<span class="normal"><a href="#__codelineno-164-12">12</a></span>
<span class="normal"><a href="#__codelineno-164-13">13</a></span>
<span class="normal"><a href="#__codelineno-164-14">14</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-164-1" name="__codelineno-164-1"></a>int main(void) {
<a id="__codelineno-164-2" name="__codelineno-164-2"></a>//创建结构体Virus存储病毒信息
<a id="__codelineno-164-3" name="__codelineno-164-3"></a>SString Virus;
<a id="__codelineno-164-4" name="__codelineno-164-4"></a>//输入病毒序列
<a id="__codelineno-164-5" name="__codelineno-164-5"></a>InputString(&amp;Virus);
<a id="__codelineno-164-6" name="__codelineno-164-6"></a>//获取文件中样本个数
<a id="__codelineno-164-7" name="__codelineno-164-7"></a>int number = File_GetNumber();
<a id="__codelineno-164-8" name="__codelineno-164-8"></a>// id用户标记文件中第几个样本
<a id="__codelineno-164-9" name="__codelineno-164-9"></a>int id = 1 ;
<a id="__codelineno-164-10" name="__codelineno-164-10"></a>//创建文件输入对象
<a id="__codelineno-164-11" name="__codelineno-164-11"></a>std::ifstream ifs(FILENAME);
<a id="__codelineno-164-12" name="__codelineno-164-12"></a>//判断文件是否打开成功
<a id="__codelineno-164-13" name="__codelineno-164-13"></a>if (!ifs.is_open()) {
<a id="__codelineno-164-14" name="__codelineno-164-14"></a>printf(&quot;Failed!\n&quot;);
</code></pre></div></td></tr></table></div></p>
<p>exit( 0 );
}
//如果打开成功,扩大病毒序列，如 xyz 扩大称 xyzxyz
for (int i = Virus.length, j = 1 ; j &lt;= Virus.length; j++) {
Virus.ch[i + j] = Virus.ch[j];
}
//因为病毒序列被扩大，所以要重新设置'\0'
Virus.ch[ 2 * Virus.length + 1 ] = '\0';</p>
<p>while (number--) {
//创建样本结构体
SString sample;
//设置检测是否被感染标记flag
int flag = false;
// ifs读文件，并输入到sample上面
ifs &gt;&gt; &amp;sample.ch[ 1 ];
//初始化sample的长度
sample.length = GetLength(&amp;sample);
//设置临时结构体temp，用于获取不同的病毒序列
SString temp;
temp.length = Virus.length;
//把不同的序列赋值给temp
for (int i = 0 ; i &lt; Virus.length; i++) {
for (int j = 1 ; j &lt;= Virus.length; j++) {
temp.ch[j] = Virus.ch[j + i];
}
//为temp设置结束标识符
temp.ch[Virus.length + 1 ] = '\0';
//此时已经获取了病毒序列储存在temp中，把病毒样本和病毒序列比对
flag = KMP_Match(sample, temp, 1 );
if (flag) { //如果flag!=0说明检测成功
printf("%d infected\n", id++);
break;
}
}
if ( 0 == flag)
printf("%d Not infected\n", id++);
}
system("pause");
return 0 ;
}</p>
<p>int File_GetNumber() {
std::ifstream ifs(FILENAME);
char buffer[ 1024 ];
int cnt = 0 ;
// ifs会一直读取字符输入到buff数组上，直到遇到空格等制表符停止
while (ifs &gt;&gt; buffer) {
cnt++;
}
return cnt;
}</p>
<h3 id="_267">数组<a class="headerlink" href="#_267" title="Permanent link">&para;</a></h3>
<h6 id="_268">声明格式 数据类型变量名称行数 列数<a class="headerlink" href="#_268" title="Permanent link">&para;</a></h6>
<h6 id="_269">如<a class="headerlink" href="#_269" title="Permanent link">&para;</a></h6>
<h6 id="_270">一个二维数组也可以被定义成一维数组<a class="headerlink" href="#_270" title="Permanent link">&para;</a></h6>
<h6 id="_271">例如:<a class="headerlink" href="#_271" title="Permanent link">&para;</a></h6>
<h6 id="_272">三维数组 每个元素都是二维数组，且二维数组中的每个元素又都是一维数组<a class="headerlink" href="#_272" title="Permanent link">&para;</a></h6>
<h6 id="_273">维数组 每个元素都是 维数组，且 维数组的每个元素都是 维数组<a class="headerlink" href="#_273" title="Permanent link">&para;</a></h6>
<h6 id="_274">维数组中的每个元素都是一维数组<a class="headerlink" href="#_274" title="Permanent link">&para;</a></h6>
<h6 id="_275">若有三维数组 各元素维<a class="headerlink" href="#_275" title="Permanent link">&para;</a></h6>
<h6 id="_276">则<a class="headerlink" href="#_276" title="Permanent link">&para;</a></h6>
<h6 id="_277">可以抽象成下图<a class="headerlink" href="#_277" title="Permanent link">&para;</a></h6>
<h6 id="_278">若有 维数组，各个维度的元素个数为<a class="headerlink" href="#_278" title="Permanent link">&para;</a></h6>
<h6 id="_279">则<a class="headerlink" href="#_279" title="Permanent link">&para;</a></h6>
<h3 id="generalized-list_1">广义表(Generalized List)<a class="headerlink" href="#generalized-list_1" title="Permanent link">&para;</a></h3>
<h6 id="_280">广义表通常记作<a class="headerlink" href="#_280" title="Permanent link">&para;</a></h6>
<h6 id="_281">为表名通常用大写字母表示<a class="headerlink" href="#_281" title="Permanent link">&para;</a></h6>
<h6 id="_282">为长度<a class="headerlink" href="#_282" title="Permanent link">&para;</a></h6>
<h6 id="_283">为表的元素<a class="headerlink" href="#_283" title="Permanent link">&para;</a></h6>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-165-1">1</a></span>
<span class="normal"><a href="#__codelineno-165-2">2</a></span>
<span class="normal"><a href="#__codelineno-165-3">3</a></span>
<span class="normal"><a href="#__codelineno-165-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-165-1" name="__codelineno-165-1"></a>typedef elemtype array2[m][n];
<a id="__codelineno-165-2" name="__codelineno-165-2"></a>等价于
<a id="__codelineno-165-3" name="__codelineno-165-3"></a>typedef elemtype array1[n];
<a id="__codelineno-165-4" name="__codelineno-165-4"></a>typedef array1 array2[m];
</code></pre></div></td></tr></table></div>
<h6 id="_284">表头 若 非空 ，则第一元素 就是表头<a class="headerlink" href="#_284" title="Permanent link">&para;</a></h6>
<h6 id="_285">表尾 除表头之外的其他元素组成的表<a class="headerlink" href="#_285" title="Permanent link">&para;</a></h6>
<h6 id="_286">注意 表尾不是一个元素，而是一个子表<a class="headerlink" href="#_286" title="Permanent link">&para;</a></h6>
<h6 id="_287">例<a class="headerlink" href="#_287" title="Permanent link">&para;</a></h6>
<h6 id="_288">空表，<a class="headerlink" href="#_288" title="Permanent link">&para;</a></h6>
<h6 id="_289">， 和 都是 但并不是同一<a class="headerlink" href="#_289" title="Permanent link">&para;</a></h6>
<h6 id="_290">广义表的性质:<a class="headerlink" href="#_290" title="Permanent link">&para;</a></h6>
<h6 id="_291">广义表中的元素有相对次序 一个直接前驱和一个直接后继<a class="headerlink" href="#_291" title="Permanent link">&para;</a></h6>
<h6 id="_292">广义表的长度定义为最外层所包含的元素个数 广义表的深度定义为该广义表展开后所含括号的层数<a class="headerlink" href="#_292" title="Permanent link">&para;</a></h6>
<h6 id="_293">如 深度 ， 深度 ， 深度<a class="headerlink" href="#_293" title="Permanent link">&para;</a></h6>
<h6 id="_294">注意 原子的深度为 ，空表的深度为<a class="headerlink" href="#_294" title="Permanent link">&para;</a></h6>
<h6 id="_295">在广义表中可以为其他广义表共享，如上述广义表 就共享<a class="headerlink" href="#_295" title="Permanent link">&para;</a></h6>
<h6 id="_296">广义表可以是一个递归的表，如上述 广义表<a class="headerlink" href="#_296" title="Permanent link">&para;</a></h6>
<h6 id="_297">注意 递归表的长度是有限的，但是深度是<a class="headerlink" href="#_297" title="Permanent link">&para;</a></h6>
<h6 id="_298">广义表的基本运算<a class="headerlink" href="#_298" title="Permanent link">&para;</a></h6>
<h2 id="4_1">4. 树、二叉树、森林<a class="headerlink" href="#4_1" title="Permanent link">&para;</a></h2>
<h3 id="_299">定义<a class="headerlink" href="#_299" title="Permanent link">&para;</a></h3>
<h6 id="_300">树是 个节点的有限集合<a class="headerlink" href="#_300" title="Permanent link">&para;</a></h6>
<h6 id="_301">当 时为空树<a class="headerlink" href="#_301" title="Permanent link">&para;</a></h6>
<h6 id="_302">有且仅有一个称之为根的节点<a class="headerlink" href="#_302" title="Permanent link">&para;</a></h6>
<h6 id="_303">令一颗树为<a class="headerlink" href="#_303" title="Permanent link">&para;</a></h6>
<h6 id="_304">除根节点外，可分为 个互不相交的有限集 ，其中一个集合又是一棵树<a class="headerlink" href="#_304" title="Permanent link">&para;</a></h6>
<h6 id="_305">称其为 的子树<a class="headerlink" href="#_305" title="Permanent link">&para;</a></h6>
<h6 id="_306">如下图<a class="headerlink" href="#_306" title="Permanent link">&para;</a></h6>
<h3 id="_307">树的基本术语<a class="headerlink" href="#_307" title="Permanent link">&para;</a></h3>
<h6 id="_308">节点的度<a class="headerlink" href="#_308" title="Permanent link">&para;</a></h6>
<h6 id="_309">节点拥有的子树个数成为节点的度<a class="headerlink" href="#_309" title="Permanent link">&para;</a></h6>
<h6 id="_310">如上图<a class="headerlink" href="#_310" title="Permanent link">&para;</a></h6>
<h6 id="_311">树的度<a class="headerlink" href="#_311" title="Permanent link">&para;</a></h6>
<h6 id="_312">树的度是树内各节点度的最大值<a class="headerlink" href="#_312" title="Permanent link">&para;</a></h6>
<h6 id="_313">上图的度为<a class="headerlink" href="#_313" title="Permanent link">&para;</a></h6>
<h6 id="_314">层次<a class="headerlink" href="#_314" title="Permanent link">&para;</a></h6>
<h6 id="_315">节点的层次从根开始定义，根为第一层，根的孩子为第二层<a class="headerlink" href="#_315" title="Permanent link">&para;</a></h6>
<h6 id="_316">树中任意节点的层次 它的双亲层次<a class="headerlink" href="#_316" title="Permanent link">&para;</a></h6>
<h6 id="_317">高度<a class="headerlink" href="#_317" title="Permanent link">&para;</a></h6>
<h6 id="_318">树中节点的最大层次成为树的高度<a class="headerlink" href="#_318" title="Permanent link">&para;</a></h6>
<h6 id="_319">如上图<a class="headerlink" href="#_319" title="Permanent link">&para;</a></h6>
<h6 id="_320">森林<a class="headerlink" href="#_320" title="Permanent link">&para;</a></h6>
<h6 id="_321">是 颗互不相交的树的集合<a class="headerlink" href="#_321" title="Permanent link">&para;</a></h6>
<h6 id="_322">对任意一棵树而言，其子树组成森林<a class="headerlink" href="#_322" title="Permanent link">&para;</a></h6>
<h3 id="_323">二叉树的定义<a class="headerlink" href="#_323" title="Permanent link">&para;</a></h3>
<h6 id="_324">是 个节点组成的集合， 时为空树<a class="headerlink" href="#_324" title="Permanent link">&para;</a></h6>
<h6 id="_325">对于非空树<a class="headerlink" href="#_325" title="Permanent link">&para;</a></h6>
<h6 id="_326">有且仅有一个根节点<a class="headerlink" href="#_326" title="Permanent link">&para;</a></h6>
<h6 id="_327">除根结点外，有互不相交的 两棵子树可以为空树，分别称其为 的左右子树<a class="headerlink" href="#_327" title="Permanent link">&para;</a></h6>
<h3 id="_328">二叉树的性质<a class="headerlink" href="#_328" title="Permanent link">&para;</a></h3>
<h6 id="_329">每个节点最多有两棵子树即<a class="headerlink" href="#_329" title="Permanent link">&para;</a></h6>
<h6 id="_330">子树有左右之分，不可颠倒<a class="headerlink" href="#_330" title="Permanent link">&para;</a></h6>
<h3 id="_331">二叉树定理<a class="headerlink" href="#_331" title="Permanent link">&para;</a></h3>
<h6 id="_332">定理<a class="headerlink" href="#_332" title="Permanent link">&para;</a></h6>
<h6 id="_333">在二叉树的第层上，最多有 个节点<a class="headerlink" href="#_333" title="Permanent link">&para;</a></h6>
<h6 id="_334">定理<a class="headerlink" href="#_334" title="Permanent link">&para;</a></h6>
<h6 id="_335">深度为 的二叉树，最多有 个节点<a class="headerlink" href="#_335" title="Permanent link">&para;</a></h6>
<h6 id="_336">定理<a class="headerlink" href="#_336" title="Permanent link">&para;</a></h6>
<h6 id="_337">令一颗二叉树 有 个节点，其中 分别为 的节点个数<a class="headerlink" href="#_337" title="Permanent link">&para;</a></h6>
<h6 id="_338">即有<a class="headerlink" href="#_338" title="Permanent link">&para;</a></h6>
<h6 id="_339">可知 的根无双亲节点，而其他的节点都有双亲 令这些节点的个数为<a class="headerlink" href="#_339" title="Permanent link">&para;</a></h6>
<h6 id="_340">即<a class="headerlink" href="#_340" title="Permanent link">&para;</a></h6>
<h6 id="_341">由 可知<a class="headerlink" href="#_341" title="Permanent link">&para;</a></h6>
<h6 id="_342">所以<a class="headerlink" href="#_342" title="Permanent link">&para;</a></h6>
<h3 id="_343">完全二叉树性质及定理<a class="headerlink" href="#_343" title="Permanent link">&para;</a></h3>
<h6 id="_344">定义<a class="headerlink" href="#_344" title="Permanent link">&para;</a></h6>
<h6 id="_345">深度为 的，由 个节点的二叉树<a class="headerlink" href="#_345" title="Permanent link">&para;</a></h6>
<h6 id="_346">当且仅当其每一个节点都与深度为 的满二叉树中编号从 到 的节点一一对应时<a class="headerlink" href="#_346" title="Permanent link">&para;</a></h6>
<h6 id="_347">称其为完全二叉树<a class="headerlink" href="#_347" title="Permanent link">&para;</a></h6>
<h6 id="_348">如下图<a class="headerlink" href="#_348" title="Permanent link">&para;</a></h6>
<h6 id="_349">特点<a class="headerlink" href="#_349" title="Permanent link">&para;</a></h6>
<h6 id="_350">对完全二叉树的任意节点<a class="headerlink" href="#_350" title="Permanent link">&para;</a></h6>
<h6 id="_351">若其右分支的子孙最大层次为 ，则其左分支的子孙最大层次为 或<a class="headerlink" href="#_351" title="Permanent link">&para;</a></h6>
<h6 id="_352">定理<a class="headerlink" href="#_352" title="Permanent link">&para;</a></h6>
<h6 id="_353">若一个完全二叉树有 个节点，深度为 ，则<a class="headerlink" href="#_353" title="Permanent link">&para;</a></h6>
<h6 id="_354">根据完全二叉树性质可知<a class="headerlink" href="#_354" title="Permanent link">&para;</a></h6>
<h6 id="_355">对其 化<a class="headerlink" href="#_355" title="Permanent link">&para;</a></h6>
<h6 id="_356">因为 所以<a class="headerlink" href="#_356" title="Permanent link">&para;</a></h6>
<h6 id="_357">定理<a class="headerlink" href="#_357" title="Permanent link">&para;</a></h6>
<h6 id="_358">一颗完全二叉树 ，有 个节点，若按照节点层次从左到右给其编号，则对于任意节点<a class="headerlink" href="#_358" title="Permanent link">&para;</a></h6>
<h6 id="_359">无双亲<a class="headerlink" href="#_359" title="Permanent link">&para;</a></h6>
<h6 id="_360">的双亲为<a class="headerlink" href="#_360" title="Permanent link">&para;</a></h6>
<h6 id="_361">则无左孩子<a class="headerlink" href="#_361" title="Permanent link">&para;</a></h6>
<h6 id="_362">为的左孩子<a class="headerlink" href="#_362" title="Permanent link">&para;</a></h6>
<h6 id="_363">则无右孩子<a class="headerlink" href="#_363" title="Permanent link">&para;</a></h6>
<h6 id="_364">则 为的右孩子<a class="headerlink" href="#_364" title="Permanent link">&para;</a></h6>
<h6 id="_365">如下图<a class="headerlink" href="#_365" title="Permanent link">&para;</a></h6>
<h3 id="_366">链式二叉树<a class="headerlink" href="#_366" title="Permanent link">&para;</a></h3>
<h4 id="_367">存储结构<a class="headerlink" href="#_367" title="Permanent link">&para;</a></h4>
<h4 id="_368">遍历方式(递归)<a class="headerlink" href="#_368" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-166-1">1</a></span>
<span class="normal"><a href="#__codelineno-166-2">2</a></span>
<span class="normal"><a href="#__codelineno-166-3">3</a></span>
<span class="normal"><a href="#__codelineno-166-4">4</a></span>
<span class="normal"><a href="#__codelineno-166-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-166-1" name="__codelineno-166-1"></a>typedef char BitreeElemType;
<a id="__codelineno-166-2" name="__codelineno-166-2"></a>typedef struct __BiNode {
<a id="__codelineno-166-3" name="__codelineno-166-3"></a>BitreeElemType data;
<a id="__codelineno-166-4" name="__codelineno-166-4"></a>__BiNode *lchild, *rchild;
<a id="__codelineno-166-5" name="__codelineno-166-5"></a>} BiNode, *BiTree;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-167-1">1</a></span>
<span class="normal"><a href="#__codelineno-167-2">2</a></span>
<span class="normal"><a href="#__codelineno-167-3">3</a></span>
<span class="normal"><a href="#__codelineno-167-4">4</a></span>
<span class="normal"><a href="#__codelineno-167-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-167-1" name="__codelineno-167-1"></a>void InOrder(BiTree T) {
<a id="__codelineno-167-2" name="__codelineno-167-2"></a>if (!T)
<a id="__codelineno-167-3" name="__codelineno-167-3"></a>return;
<a id="__codelineno-167-4" name="__codelineno-167-4"></a>InOrder(T-&gt;lchild);
<a id="__codelineno-167-5" name="__codelineno-167-5"></a>printf(&quot;%c &quot;, T-&gt;data);
</code></pre></div></td></tr></table></div></p>
<h4 id="_369">遍历方式(非递归)<a class="headerlink" href="#_369" title="Permanent link">&para;</a></h4>
<h4 id="_370">先序遍历创建二叉树<a class="headerlink" href="#_370" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-168-1">1</a></span>
<span class="normal"><a href="#__codelineno-168-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-168-1" name="__codelineno-168-1"></a>InOrder(T-&gt;rchild);
<a id="__codelineno-168-2" name="__codelineno-168-2"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-169-1">1</a></span>
<span class="normal"><a href="#__codelineno-169-2">2</a></span>
<span class="normal"><a href="#__codelineno-169-3">3</a></span>
<span class="normal"><a href="#__codelineno-169-4">4</a></span>
<span class="normal"><a href="#__codelineno-169-5">5</a></span>
<span class="normal"><a href="#__codelineno-169-6">6</a></span>
<span class="normal"><a href="#__codelineno-169-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-169-1" name="__codelineno-169-1"></a>void PreOrder(BiTree T) {
<a id="__codelineno-169-2" name="__codelineno-169-2"></a>if (!T)
<a id="__codelineno-169-3" name="__codelineno-169-3"></a>return;
<a id="__codelineno-169-4" name="__codelineno-169-4"></a>printf(&quot;%c &quot;, T-&gt;data);
<a id="__codelineno-169-5" name="__codelineno-169-5"></a>PreOrder(T-&gt;lchild);
<a id="__codelineno-169-6" name="__codelineno-169-6"></a>PreOrder(T-&gt;rchild);
<a id="__codelineno-169-7" name="__codelineno-169-7"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-170-1">1</a></span>
<span class="normal"><a href="#__codelineno-170-2">2</a></span>
<span class="normal"><a href="#__codelineno-170-3">3</a></span>
<span class="normal"><a href="#__codelineno-170-4">4</a></span>
<span class="normal"><a href="#__codelineno-170-5">5</a></span>
<span class="normal"><a href="#__codelineno-170-6">6</a></span>
<span class="normal"><a href="#__codelineno-170-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-170-1" name="__codelineno-170-1"></a>void PostOrder(BiTree T) {
<a id="__codelineno-170-2" name="__codelineno-170-2"></a>if (!T)
<a id="__codelineno-170-3" name="__codelineno-170-3"></a>return;
<a id="__codelineno-170-4" name="__codelineno-170-4"></a>PostOrder(T-&gt;lchild);
<a id="__codelineno-170-5" name="__codelineno-170-5"></a>PostOrder(T-&gt;rchild);
<a id="__codelineno-170-6" name="__codelineno-170-6"></a>printf(&quot;%c &quot;, T-&gt;data);
<a id="__codelineno-170-7" name="__codelineno-170-7"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-171-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-171-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-171-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-171-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-171-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-171-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-171-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-171-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-171-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-171-10">10</a></span>
<span class="normal"><a href="#__codelineno-171-11">11</a></span>
<span class="normal"><a href="#__codelineno-171-12">12</a></span>
<span class="normal"><a href="#__codelineno-171-13">13</a></span>
<span class="normal"><a href="#__codelineno-171-14">14</a></span>
<span class="normal"><a href="#__codelineno-171-15">15</a></span>
<span class="normal"><a href="#__codelineno-171-16">16</a></span>
<span class="normal"><a href="#__codelineno-171-17">17</a></span>
<span class="normal"><a href="#__codelineno-171-18">18</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-171-1" name="__codelineno-171-1"></a>void InOrder_unrec(BiTree T) {
<a id="__codelineno-171-2" name="__codelineno-171-2"></a>SqStack S;
<a id="__codelineno-171-3" name="__codelineno-171-3"></a>InitStack(&amp;S);
<a id="__codelineno-171-4" name="__codelineno-171-4"></a>BiTree p = T;
<a id="__codelineno-171-5" name="__codelineno-171-5"></a>// BiTree pop = NULL;
<a id="__codelineno-171-6" name="__codelineno-171-6"></a>while (p || !IsEmpty(&amp;S)) {
<a id="__codelineno-171-7" name="__codelineno-171-7"></a>if (p) {
<a id="__codelineno-171-8" name="__codelineno-171-8"></a>//栈顶元素始终是p的parent节点
<a id="__codelineno-171-9" name="__codelineno-171-9"></a>Push(&amp;S, p);
<a id="__codelineno-171-10" name="__codelineno-171-10"></a>p = p-&gt;lchild;
<a id="__codelineno-171-11" name="__codelineno-171-11"></a>} else {
<a id="__codelineno-171-12" name="__codelineno-171-12"></a>Pop(&amp;S, &amp;p); //把栈顶元素弹出给p，此时变成了原p的parent
<a id="__codelineno-171-13" name="__codelineno-171-13"></a>//此时p的左孩子为空，根据in-oder规则，输出根节点p，然后再以相同的方式遍历他的右孩子
<a id="__codelineno-171-14" name="__codelineno-171-14"></a>printf(&quot;%c&quot;, p-&gt;data);
<a id="__codelineno-171-15" name="__codelineno-171-15"></a>p = p-&gt;rchild; //输出根节点后，遍历其右子树
<a id="__codelineno-171-16" name="__codelineno-171-16"></a>}
<a id="__codelineno-171-17" name="__codelineno-171-17"></a>}
<a id="__codelineno-171-18" name="__codelineno-171-18"></a>}
</code></pre></div></td></tr></table></div></p>
<h4 id="_371">测试(创建，遍历)<a class="headerlink" href="#_371" title="Permanent link">&para;</a></h4>
<h6 id="_372">输入如下一棵树，按照中序遍历方式输出<a class="headerlink" href="#_372" title="Permanent link">&para;</a></h6>
<h4 id="_373">层次遍历算法<a class="headerlink" href="#_373" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-172-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-172-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-172-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-172-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-172-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-172-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-172-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-172-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-172-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-172-10">10</a></span>
<span class="normal"><a href="#__codelineno-172-11">11</a></span>
<span class="normal"><a href="#__codelineno-172-12">12</a></span>
<span class="normal"><a href="#__codelineno-172-13">13</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-172-1" name="__codelineno-172-1"></a>void Creat_BiTree_Pre(BiTree *T) {
<a id="__codelineno-172-2" name="__codelineno-172-2"></a>//根据输出字符识别虚空节点，&#39;#&#39; 代表虚空节点
<a id="__codelineno-172-3" name="__codelineno-172-3"></a>char e;
<a id="__codelineno-172-4" name="__codelineno-172-4"></a>scanf(&quot; %c&quot;, &amp;e); //输入字符
<a id="__codelineno-172-5" name="__codelineno-172-5"></a>if (&#39;#&#39; == e)
<a id="__codelineno-172-6" name="__codelineno-172-6"></a>*T = NULL; //设置虚空节点
<a id="__codelineno-172-7" name="__codelineno-172-7"></a>else {
<a id="__codelineno-172-8" name="__codelineno-172-8"></a>*T = (BiTree)malloc(sizeof(BiNode));
<a id="__codelineno-172-9" name="__codelineno-172-9"></a>(*T)-&gt;data = e;
<a id="__codelineno-172-10" name="__codelineno-172-10"></a>Creat_BiTree_Pre(&amp;(*T)-&gt;lchild);
<a id="__codelineno-172-11" name="__codelineno-172-11"></a>Creat_BiTree_Pre(&amp;(*T)-&gt;rchild);
<a id="__codelineno-172-12" name="__codelineno-172-12"></a>}
<a id="__codelineno-172-13" name="__codelineno-172-13"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-173-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-173-1" name="__codelineno-173-1"></a>#include &quot;BinaryTree.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-174-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-174-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-174-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-174-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-174-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-174-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-174-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-174-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-174-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-174-10">10</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-174-1" name="__codelineno-174-1"></a>int main(void) {
<a id="__codelineno-174-2" name="__codelineno-174-2"></a>BiTree T = NULL;
<a id="__codelineno-174-3" name="__codelineno-174-3"></a>Creat_BiTree_Pre(&amp;T);
<a id="__codelineno-174-4" name="__codelineno-174-4"></a>InOrder_unrec(T); //非递归
<a id="__codelineno-174-5" name="__codelineno-174-5"></a>// InOrder(T); 递归调用
<a id="__codelineno-174-6" name="__codelineno-174-6"></a>system(&quot;pause&quot;);
<a id="__codelineno-174-7" name="__codelineno-174-7"></a>return 0 ;
<a id="__codelineno-174-8" name="__codelineno-174-8"></a>}
<a id="__codelineno-174-9" name="__codelineno-174-9"></a>// 输入数据：CDNK##J##BZ###FL##M##
<a id="__codelineno-174-10" name="__codelineno-174-10"></a>// 输出: KNJDZBCLFM
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-175-1">1</a></span>
<span class="normal"><a href="#__codelineno-175-2">2</a></span>
<span class="normal"><a href="#__codelineno-175-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-175-1" name="__codelineno-175-1"></a>void LevelOrer(BiTree T) {
<a id="__codelineno-175-2" name="__codelineno-175-2"></a>BiTree temp = NULL;
<a id="__codelineno-175-3" name="__codelineno-175-3"></a>SqQueue Q;
</code></pre></div></td></tr></table></div></p>
<h4 id="_374">复制二叉树<a class="headerlink" href="#_374" title="Permanent link">&para;</a></h4>
<h4 id="_375">求深度和节点数<a class="headerlink" href="#_375" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-176-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-176-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-176-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-176-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-176-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-176-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-176-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-176-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-176-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-176-10">10</a></span>
<span class="normal"><a href="#__codelineno-176-11">11</a></span>
<span class="normal"><a href="#__codelineno-176-12">12</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-176-1" name="__codelineno-176-1"></a>InitQueue(&amp;Q);
<a id="__codelineno-176-2" name="__codelineno-176-2"></a>if (T) // 先入队根
<a id="__codelineno-176-3" name="__codelineno-176-3"></a>EntryQ(&amp;Q, T);
<a id="__codelineno-176-4" name="__codelineno-176-4"></a>while (!IsEmpty(&amp;Q)) {
<a id="__codelineno-176-5" name="__codelineno-176-5"></a>OutQ(&amp;Q, &amp;temp); // temp暂存弹出值
<a id="__codelineno-176-6" name="__codelineno-176-6"></a>printf(&quot;%c&quot;, temp-&gt;data); //输出
<a id="__codelineno-176-7" name="__codelineno-176-7"></a>if (temp-&gt;lchild) //在入队temp的左孩子和右孩子
<a id="__codelineno-176-8" name="__codelineno-176-8"></a>EntryQ(&amp;Q, temp-&gt;lchild);
<a id="__codelineno-176-9" name="__codelineno-176-9"></a>if (temp-&gt;rchild)
<a id="__codelineno-176-10" name="__codelineno-176-10"></a>EntryQ(&amp;Q, temp-&gt;rchild);
<a id="__codelineno-176-11" name="__codelineno-176-11"></a>}
<a id="__codelineno-176-12" name="__codelineno-176-12"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-177-1">1</a></span>
<span class="normal"><a href="#__codelineno-177-2">2</a></span>
<span class="normal"><a href="#__codelineno-177-3">3</a></span>
<span class="normal"><a href="#__codelineno-177-4">4</a></span>
<span class="normal"><a href="#__codelineno-177-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-177-1" name="__codelineno-177-1"></a>/*
<a id="__codelineno-177-2" name="__codelineno-177-2"></a>input: CDNK##J##BZ###FL##M##
<a id="__codelineno-177-3" name="__codelineno-177-3"></a>------------------------------------------
<a id="__codelineno-177-4" name="__codelineno-177-4"></a>output:CDFNBLMKJZ
<a id="__codelineno-177-5" name="__codelineno-177-5"></a>*/
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-178-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-178-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-178-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-178-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-178-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-178-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-178-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-178-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-178-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-178-10">10</a></span>
<span class="normal"><a href="#__codelineno-178-11">11</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-178-1" name="__codelineno-178-1"></a>void Copy(BiTree *Tnew, const BiTree T) {
<a id="__codelineno-178-2" name="__codelineno-178-2"></a>if (!T) {
<a id="__codelineno-178-3" name="__codelineno-178-3"></a>*Tnew = NULL;
<a id="__codelineno-178-4" name="__codelineno-178-4"></a>return;
<a id="__codelineno-178-5" name="__codelineno-178-5"></a>} else {
<a id="__codelineno-178-6" name="__codelineno-178-6"></a>*Tnew = (BiTree)malloc(sizeof(BiNode));
<a id="__codelineno-178-7" name="__codelineno-178-7"></a>(*Tnew)-&gt;data = T-&gt;data;
<a id="__codelineno-178-8" name="__codelineno-178-8"></a>Copy(&amp;(*Tnew)-&gt;lchild, T-&gt;lchild);
<a id="__codelineno-178-9" name="__codelineno-178-9"></a>Copy(&amp;(*Tnew)-&gt;rchild, T-&gt;rchild);
<a id="__codelineno-178-10" name="__codelineno-178-10"></a>}
<a id="__codelineno-178-11" name="__codelineno-178-11"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-179-1">1</a></span>
<span class="normal"><a href="#__codelineno-179-2">2</a></span>
<span class="normal"><a href="#__codelineno-179-3">3</a></span>
<span class="normal"><a href="#__codelineno-179-4">4</a></span>
<span class="normal"><a href="#__codelineno-179-5">5</a></span>
<span class="normal"><a href="#__codelineno-179-6">6</a></span>
<span class="normal"><a href="#__codelineno-179-7">7</a></span>
<span class="normal"><a href="#__codelineno-179-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-179-1" name="__codelineno-179-1"></a>int Depth(BiTree T) {
<a id="__codelineno-179-2" name="__codelineno-179-2"></a>if (!T)
<a id="__codelineno-179-3" name="__codelineno-179-3"></a>return 0 ;
<a id="__codelineno-179-4" name="__codelineno-179-4"></a>else {
<a id="__codelineno-179-5" name="__codelineno-179-5"></a>return Depth(T-&gt;lchild) &gt; Depth(T-&gt;rchild)? Depth(T-&gt;lchild) + 1
<a id="__codelineno-179-6" name="__codelineno-179-6"></a>: Depth(T-&gt;rchild) + 1 ;
<a id="__codelineno-179-7" name="__codelineno-179-7"></a>}
<a id="__codelineno-179-8" name="__codelineno-179-8"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-180-1">1</a></span>
<span class="normal"><a href="#__codelineno-180-2">2</a></span>
<span class="normal"><a href="#__codelineno-180-3">3</a></span>
<span class="normal"><a href="#__codelineno-180-4">4</a></span>
<span class="normal"><a href="#__codelineno-180-5">5</a></span>
<span class="normal"><a href="#__codelineno-180-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-180-1" name="__codelineno-180-1"></a>int Nodes(BiTree T) {
<a id="__codelineno-180-2" name="__codelineno-180-2"></a>if (!T)
<a id="__codelineno-180-3" name="__codelineno-180-3"></a>return 0 ;
<a id="__codelineno-180-4" name="__codelineno-180-4"></a>else
<a id="__codelineno-180-5" name="__codelineno-180-5"></a>return 1 + Nodes(T-&gt;lchild) + Nodes(T-&gt;rchild);
<a id="__codelineno-180-6" name="__codelineno-180-6"></a>}
</code></pre></div></td></tr></table></div></p>
<h4 id="_376">销毁二叉树(递归和非递归)<a class="headerlink" href="#_376" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-181-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-181-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-181-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-181-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-181-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-181-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-181-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-181-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-181-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-181-10">10</a></span>
<span class="normal"><a href="#__codelineno-181-11">11</a></span>
<span class="normal"><a href="#__codelineno-181-12">12</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-181-1" name="__codelineno-181-1"></a>//递归的方式
<a id="__codelineno-181-2" name="__codelineno-181-2"></a>void Destroy(BiTree *root) {
<a id="__codelineno-181-3" name="__codelineno-181-3"></a>//销毁操作必须按照后续遍历的顺序
<a id="__codelineno-181-4" name="__codelineno-181-4"></a>if (!(*root))
<a id="__codelineno-181-5" name="__codelineno-181-5"></a>return;
<a id="__codelineno-181-6" name="__codelineno-181-6"></a>else {
<a id="__codelineno-181-7" name="__codelineno-181-7"></a>Destroy(&amp;(*root)-&gt;lchild);
<a id="__codelineno-181-8" name="__codelineno-181-8"></a>Destroy(&amp;(*root)-&gt;rchild);
<a id="__codelineno-181-9" name="__codelineno-181-9"></a>free(*root);
<a id="__codelineno-181-10" name="__codelineno-181-10"></a>*root = NULL;
<a id="__codelineno-181-11" name="__codelineno-181-11"></a>}
<a id="__codelineno-181-12" name="__codelineno-181-12"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-182-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-182-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-182-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-182-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-182-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-182-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-182-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-182-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-182-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-182-10">10</a></span>
<span class="normal"><a href="#__codelineno-182-11">11</a></span>
<span class="normal"><a href="#__codelineno-182-12">12</a></span>
<span class="normal"><a href="#__codelineno-182-13">13</a></span>
<span class="normal"><a href="#__codelineno-182-14">14</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-182-1" name="__codelineno-182-1"></a>void Destroy_unrec(BiTree *root) {
<a id="__codelineno-182-2" name="__codelineno-182-2"></a>//此算法的思路是:创建一个链栈，分别依次入栈
<a id="__codelineno-182-3" name="__codelineno-182-3"></a>//&lt;根节点&gt;,&lt;根节点的左孩子&gt;,&lt;左孩子的左孩子&gt;,.....&lt;最后一个左孩子&gt;
<a id="__codelineno-182-4" name="__codelineno-182-4"></a>//利用lchild充当链栈的next.
<a id="__codelineno-182-5" name="__codelineno-182-5"></a>//当lchild发生变法时，树的结构必然发生变化，所以需要一个current指针来指向入栈节点
<a id="__codelineno-182-6" name="__codelineno-182-6"></a>//当所有根节点左子树的所有左孩子入栈完毕，使current指向栈顶top
<a id="__codelineno-182-7" name="__codelineno-182-7"></a>//判断栈顶节点是否有右孩子，如果有则current指向它的右孩子，并把current入栈
<a id="__codelineno-182-8" name="__codelineno-182-8"></a>//如果没有右孩子，则出栈，并释放栈顶
<a id="__codelineno-182-9" name="__codelineno-182-9"></a>//重复此步骤
<a id="__codelineno-182-10" name="__codelineno-182-10"></a>BiTree top = NULL; //初始化一个链栈
<a id="__codelineno-182-11" name="__codelineno-182-11"></a>BiTree temp; //暂存current
<a id="__codelineno-182-12" name="__codelineno-182-12"></a>BiTree current = (*root)-&gt;lchild; //因为要把root入栈，current指向root的左孩子
<a id="__codelineno-182-13" name="__codelineno-182-13"></a>(*root)-&gt;lchild = top; //因为lchild充当链栈的next，所以lchild指向top
<a id="__codelineno-182-14" name="__codelineno-182-14"></a>top = *root; //此时root变成栈顶
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-183-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-183-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-183-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-183-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-183-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-183-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-183-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-183-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-183-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-183-10">10</a></span>
<span class="normal"><a href="#__codelineno-183-11">11</a></span>
<span class="normal"><a href="#__codelineno-183-12">12</a></span>
<span class="normal"><a href="#__codelineno-183-13">13</a></span>
<span class="normal"><a href="#__codelineno-183-14">14</a></span>
<span class="normal"><a href="#__codelineno-183-15">15</a></span>
<span class="normal"><a href="#__codelineno-183-16">16</a></span>
<span class="normal"><a href="#__codelineno-183-17">17</a></span>
<span class="normal"><a href="#__codelineno-183-18">18</a></span>
<span class="normal"><a href="#__codelineno-183-19">19</a></span>
<span class="normal"><a href="#__codelineno-183-20">20</a></span>
<span class="normal"><a href="#__codelineno-183-21">21</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-183-1" name="__codelineno-183-1"></a>while (top) {
<a id="__codelineno-183-2" name="__codelineno-183-2"></a>while (current) { //如果current不为空，则入栈
<a id="__codelineno-183-3" name="__codelineno-183-3"></a>temp = current; //暂存current
<a id="__codelineno-183-4" name="__codelineno-183-4"></a>current = current-&gt;lchild;
<a id="__codelineno-183-5" name="__codelineno-183-5"></a>temp-&gt;lchild = top; //入栈
<a id="__codelineno-183-6" name="__codelineno-183-6"></a>top = temp;
<a id="__codelineno-183-7" name="__codelineno-183-7"></a>}
<a id="__codelineno-183-8" name="__codelineno-183-8"></a>//此时已经把root的左孩子，左孩子的左孩子.....入栈，栈顶为树的最左路径的最后一个节点
<a id="__codelineno-183-9" name="__codelineno-183-9"></a>current = top; // current 和 top 指向同一个节点
<a id="__codelineno-183-10" name="__codelineno-183-10"></a>if (current-&gt;rchild) { //如果栈顶有右孩子
<a id="__codelineno-183-11" name="__codelineno-183-11"></a>temp = current;
<a id="__codelineno-183-12" name="__codelineno-183-12"></a>// current指向它的右孩子，然后再次循环上面的步骤
<a id="__codelineno-183-13" name="__codelineno-183-13"></a>current = current-&gt;rchild;
<a id="__codelineno-183-14" name="__codelineno-183-14"></a>//因为栈顶的右孩子地址已经被current保存，所以可以把该指针指向NULL
<a id="__codelineno-183-15" name="__codelineno-183-15"></a>temp-&gt;rchild = NULL;
<a id="__codelineno-183-16" name="__codelineno-183-16"></a>} else { // 如果栈顶元素没有左孩子
<a id="__codelineno-183-17" name="__codelineno-183-17"></a>//此时top和current指向同一节点
<a id="__codelineno-183-18" name="__codelineno-183-18"></a>top = top-&gt;lchild;
<a id="__codelineno-183-19" name="__codelineno-183-19"></a>free(current);
<a id="__codelineno-183-20" name="__codelineno-183-20"></a>current = NULL;
<a id="__codelineno-183-21" name="__codelineno-183-21"></a>//回到上面的循环时，因为current为空，所以不会有元素入栈，并且current会指向栈顶
</code></pre></div></td></tr></table></div></p>
<h4 id="_377">头文件<a class="headerlink" href="#_377" title="Permanent link">&para;</a></h4>
<h3 id="threaded-binary-tree_1">线索二叉树 Threaded Binary Tree(了解即可)<a class="headerlink" href="#threaded-binary-tree_1" title="Permanent link">&para;</a></h3>
<h6 id="_378">问题，如何寻找特点遍历顺序中二叉树节点的前驱和后继<a class="headerlink" href="#_378" title="Permanent link">&para;</a></h6>
<h6 id="_379">办法<a class="headerlink" href="#_379" title="Permanent link">&para;</a></h6>
<h6 id="_380">通过遍历，浪费时间<a class="headerlink" href="#_380" title="Permanent link">&para;</a></h6>
<h6 id="_381">给结构体内增加前驱和后继指针，增加存储负担<a class="headerlink" href="#_381" title="Permanent link">&para;</a></h6>
<h6 id="_382">利用二叉链表中的空指针域<a class="headerlink" href="#_382" title="Permanent link">&para;</a></h6>
<h6 id="_383">定理<a class="headerlink" href="#_383" title="Permanent link">&para;</a></h6>
<h6 id="_384">如果一个二叉树有 个节点，那么空指针域为 个<a class="headerlink" href="#_384" title="Permanent link">&para;</a></h6>
<h6 id="_385">总指针域为 个，除去根节点，一个有 个节点，即需要 个指针域<a class="headerlink" href="#_385" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-184-1">1</a></span>
<span class="normal"><a href="#__codelineno-184-2">2</a></span>
<span class="normal"><a href="#__codelineno-184-3">3</a></span>
<span class="normal"><a href="#__codelineno-184-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-184-1" name="__codelineno-184-1"></a>}
<a id="__codelineno-184-2" name="__codelineno-184-2"></a>}
<a id="__codelineno-184-3" name="__codelineno-184-3"></a>*root = NULL; //销毁完毕，把root指向空
<a id="__codelineno-184-4" name="__codelineno-184-4"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-185-1">1</a></span>
<span class="normal"><a href="#__codelineno-185-2">2</a></span>
<span class="normal"><a href="#__codelineno-185-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-185-1" name="__codelineno-185-1"></a>#include &quot;Queue.h&quot;
<a id="__codelineno-185-2" name="__codelineno-185-2"></a>#include &quot;Stack.h&quot;
<a id="__codelineno-185-3" name="__codelineno-185-3"></a>#include &quot;define.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-186-1">1</a></span>
<span class="normal"><a href="#__codelineno-186-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-186-1" name="__codelineno-186-1"></a>#ifndef __BINARYTREE_H
<a id="__codelineno-186-2" name="__codelineno-186-2"></a>#define __BINARYTREE_H
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-187-1">1</a></span>
<span class="normal"><a href="#__codelineno-187-2">2</a></span>
<span class="normal"><a href="#__codelineno-187-3">3</a></span>
<span class="normal"><a href="#__codelineno-187-4">4</a></span>
<span class="normal"><a href="#__codelineno-187-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-187-1" name="__codelineno-187-1"></a>typedef char BitreeElemType;
<a id="__codelineno-187-2" name="__codelineno-187-2"></a>typedef struct __BiNode {
<a id="__codelineno-187-3" name="__codelineno-187-3"></a>BitreeElemType data;
<a id="__codelineno-187-4" name="__codelineno-187-4"></a>__BiNode *lchild, *rchild;
<a id="__codelineno-187-5" name="__codelineno-187-5"></a>} BiNode, *BiTree;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-188-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-188-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-188-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-188-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-188-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-188-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-188-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-188-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-188-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-188-10">10</a></span>
<span class="normal"><a href="#__codelineno-188-11">11</a></span>
<span class="normal"><a href="#__codelineno-188-12">12</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-188-1" name="__codelineno-188-1"></a>void Creat_BiTree_Pre(BiTree *T);
<a id="__codelineno-188-2" name="__codelineno-188-2"></a>void InOrder(BiTree T);
<a id="__codelineno-188-3" name="__codelineno-188-3"></a>void InOrder_unrec(BiTree T);
<a id="__codelineno-188-4" name="__codelineno-188-4"></a>void PreOrder(BiTree T);
<a id="__codelineno-188-5" name="__codelineno-188-5"></a>void PostOrder(BiTree T);
<a id="__codelineno-188-6" name="__codelineno-188-6"></a>void LevelOrer(BiTree T);
<a id="__codelineno-188-7" name="__codelineno-188-7"></a>void Copy(BiTree *Tnew, const BiTree T);
<a id="__codelineno-188-8" name="__codelineno-188-8"></a>int Depth(BiTree T);
<a id="__codelineno-188-9" name="__codelineno-188-9"></a>int Nodes(BiTree T);
<a id="__codelineno-188-10" name="__codelineno-188-10"></a>void Destroy_unrec(BiTree *root);
<a id="__codelineno-188-11" name="__codelineno-188-11"></a>void Destroy(BiTree *root);
<a id="__codelineno-188-12" name="__codelineno-188-12"></a>#endif
</code></pre></div></td></tr></table></div></p>
<h6 id="_386">线索二叉树的定义<a class="headerlink" href="#_386" title="Permanent link">&para;</a></h6>
<h6 id="_387">如果某个节点的左孩子为空，那么利用左孩子指针域，把它指向它的前驱<a class="headerlink" href="#_387" title="Permanent link">&para;</a></h6>
<h6 id="_388">如果右孩子为空，则指向它后继<a class="headerlink" href="#_388" title="Permanent link">&para;</a></h6>
<h6 id="_389">这种改变指向的指针称为线索<a class="headerlink" href="#_389" title="Permanent link">&para;</a></h6>
<h4 id="_390">数据类型定义<a class="headerlink" href="#_390" title="Permanent link">&para;</a></h4>
<h6 id="_391">左孩子为空<a class="headerlink" href="#_391" title="Permanent link">&para;</a></h6>
<h6 id="_392">左孩子指向前驱<a class="headerlink" href="#_392" title="Permanent link">&para;</a></h6>
<h6 id="_393">右孩子为空<a class="headerlink" href="#_393" title="Permanent link">&para;</a></h6>
<h6 id="_394">右孩子指向前驱<a class="headerlink" href="#_394" title="Permanent link">&para;</a></h6>
<h6 id="_395">如果按照遍历的顺序，那么序列中第一个元素必然没有前驱<a class="headerlink" href="#_395" title="Permanent link">&para;</a></h6>
<h6 id="_396">把该节点的左孩子指向一个头指针<a class="headerlink" href="#_396" title="Permanent link">&para;</a></h6>
<h6 id="_397">该头指针的左孩子指向根节点，右孩子指向序列最后一个节点<a class="headerlink" href="#_397" title="Permanent link">&para;</a></h6>
<h6 id="_398">一个中序遍历为 的线索二叉树<a class="headerlink" href="#_398" title="Permanent link">&para;</a></h6>
<h6 id="_399">如下图<a class="headerlink" href="#_399" title="Permanent link">&para;</a></h6>
<h3 id="_400">树和森林<a class="headerlink" href="#_400" title="Permanent link">&para;</a></h3>
<h4 id="_401">树的存储结构<a class="headerlink" href="#_401" title="Permanent link">&para;</a></h4>
<h6 id="1_6">1. 双亲表示法<a class="headerlink" href="#1_6" title="Permanent link">&para;</a></h6>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-189-1">1</a></span>
<span class="normal"><a href="#__codelineno-189-2">2</a></span>
<span class="normal"><a href="#__codelineno-189-3">3</a></span>
<span class="normal"><a href="#__codelineno-189-4">4</a></span>
<span class="normal"><a href="#__codelineno-189-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-189-1" name="__codelineno-189-1"></a>typedef struct BiThrNode {
<a id="__codelineno-189-2" name="__codelineno-189-2"></a>int data;
<a id="__codelineno-189-3" name="__codelineno-189-3"></a>int ltag, rtag; //为了区分左右孩子指向为空还是前驱或后继，新增ltag,rtag
<a id="__codelineno-189-4" name="__codelineno-189-4"></a>BiThrNode * lchidl, *rchild;
<a id="__codelineno-189-5" name="__codelineno-189-5"></a>} *BiThrTree;
</code></pre></div></td></tr></table></div>
<h6 id="2_4">2. 孩子链表<a class="headerlink" href="#2_4" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-190-1">1</a></span>
<span class="normal"><a href="#__codelineno-190-2">2</a></span>
<span class="normal"><a href="#__codelineno-190-3">3</a></span>
<span class="normal"><a href="#__codelineno-190-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-190-1" name="__codelineno-190-1"></a>struct PTNode {
<a id="__codelineno-190-2" name="__codelineno-190-2"></a>DataType data;
<a id="__codelineno-190-3" name="__codelineno-190-3"></a>int parent; //存放parent在数组中的位置
<a id="__codelineno-190-4" name="__codelineno-190-4"></a>};
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-191-1">1</a></span>
<span class="normal"><a href="#__codelineno-191-2">2</a></span>
<span class="normal"><a href="#__codelineno-191-3">3</a></span>
<span class="normal"><a href="#__codelineno-191-4">4</a></span>
<span class="normal"><a href="#__codelineno-191-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-191-1" name="__codelineno-191-1"></a>struct PTree {
<a id="__codelineno-191-2" name="__codelineno-191-2"></a>PTNode[MAXSIZE];
<a id="__codelineno-191-3" name="__codelineno-191-3"></a>int root; //根节点位置
<a id="__codelineno-191-4" name="__codelineno-191-4"></a>int n; //当前节点个数
<a id="__codelineno-191-5" name="__codelineno-191-5"></a>};
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-192-1">1</a></span>
<span class="normal"><a href="#__codelineno-192-2">2</a></span>
<span class="normal"><a href="#__codelineno-192-3">3</a></span>
<span class="normal"><a href="#__codelineno-192-4">4</a></span>
<span class="normal"><a href="#__codelineno-192-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-192-1" name="__codelineno-192-1"></a>//孩子节点结构
<a id="__codelineno-192-2" name="__codelineno-192-2"></a>struct CTNode {
<a id="__codelineno-192-3" name="__codelineno-192-3"></a>int chlid;
<a id="__codelineno-192-4" name="__codelineno-192-4"></a>CTNode *next;
<a id="__codelineno-192-5" name="__codelineno-192-5"></a>};
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-193-1">1</a></span>
<span class="normal"><a href="#__codelineno-193-2">2</a></span>
<span class="normal"><a href="#__codelineno-193-3">3</a></span>
<span class="normal"><a href="#__codelineno-193-4">4</a></span>
<span class="normal"><a href="#__codelineno-193-5">5</a></span>
<span class="normal"><a href="#__codelineno-193-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-193-1" name="__codelineno-193-1"></a>//双亲结点结构
<a id="__codelineno-193-2" name="__codelineno-193-2"></a>struct CTBox {
<a id="__codelineno-193-3" name="__codelineno-193-3"></a>DataType data;
<a id="__codelineno-193-4" name="__codelineno-193-4"></a>int parent; //可有可无，看具体需求
<a id="__codelineno-193-5" name="__codelineno-193-5"></a>CTNode * child;
<a id="__codelineno-193-6" name="__codelineno-193-6"></a>};
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-194-1">1</a></span>
<span class="normal"><a href="#__codelineno-194-2">2</a></span>
<span class="normal"><a href="#__codelineno-194-3">3</a></span>
<span class="normal"><a href="#__codelineno-194-4">4</a></span>
<span class="normal"><a href="#__codelineno-194-5">5</a></span>
<span class="normal"><a href="#__codelineno-194-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-194-1" name="__codelineno-194-1"></a>//整体树结构
<a id="__codelineno-194-2" name="__codelineno-194-2"></a>struct CTree {
<a id="__codelineno-194-3" name="__codelineno-194-3"></a>CTBox[MAXSIZE];
<a id="__codelineno-194-4" name="__codelineno-194-4"></a>int root;
<a id="__codelineno-194-5" name="__codelineno-194-5"></a>int n;
<a id="__codelineno-194-6" name="__codelineno-194-6"></a>};
</code></pre></div></td></tr></table></div></p>
<h6 id="3_5">3. 孩子兄弟表示法(树转化二叉树的基础)<a class="headerlink" href="#3_5" title="Permanent link">&para;</a></h6>
<h4 id="_402">树与二叉树之间相互转换<a class="headerlink" href="#_402" title="Permanent link">&para;</a></h4>
<h6 id="_403">树转二叉树<a class="headerlink" href="#_403" title="Permanent link">&para;</a></h6>
<h6 id="_404">在兄弟之间连线<a class="headerlink" href="#_404" title="Permanent link">&para;</a></h6>
<h6 id="_405">对于任意一个节点 ，除了其左孩子外，去除掉所有孩子与其的关系<a class="headerlink" href="#_405" title="Permanent link">&para;</a></h6>
<h6 id="_406">以根节点的左孩子为中心，顺时针旋转 ，再与根节点相连<a class="headerlink" href="#_406" title="Permanent link">&para;</a></h6>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-195-1">1</a></span>
<span class="normal"><a href="#__codelineno-195-2">2</a></span>
<span class="normal"><a href="#__codelineno-195-3">3</a></span>
<span class="normal"><a href="#__codelineno-195-4">4</a></span>
<span class="normal"><a href="#__codelineno-195-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-195-1" name="__codelineno-195-1"></a>//节点的child指针域指向它的第一个孩子，sibling指向第一个兄弟
<a id="__codelineno-195-2" name="__codelineno-195-2"></a>struct CSNode {
<a id="__codelineno-195-3" name="__codelineno-195-3"></a>DataType data;
<a id="__codelineno-195-4" name="__codelineno-195-4"></a>CSNode * child, *sibling;
<a id="__codelineno-195-5" name="__codelineno-195-5"></a>};
</code></pre></div></td></tr></table></div>
<h6 id="_407">二叉树转树<a class="headerlink" href="#_407" title="Permanent link">&para;</a></h6>
<h6 id="_408">若 节点是双亲节点的左孩子，则将 的右孩子，右孩子的右孩子 连接到 的双亲结点上<a class="headerlink" href="#_408" title="Permanent link">&para;</a></h6>
<h6 id="_409">抹掉所有双亲结点和右孩子之间关系<a class="headerlink" href="#_409" title="Permanent link">&para;</a></h6>
<h6 id="_410">整理成树状<a class="headerlink" href="#_410" title="Permanent link">&para;</a></h6>
<h4 id="_411">森林与二叉树之间的转化<a class="headerlink" href="#_411" title="Permanent link">&para;</a></h4>
<h6 id="_412">森林转二叉树<a class="headerlink" href="#_412" title="Permanent link">&para;</a></h6>
<h6 id="_413">将森林中的各棵树转化为二叉树<a class="headerlink" href="#_413" title="Permanent link">&para;</a></h6>
<h6 id="_414">链接这些二叉树的根节点<a class="headerlink" href="#_414" title="Permanent link">&para;</a></h6>
<h6 id="_415">第一棵树的根为二叉树的根，进行调整<a class="headerlink" href="#_415" title="Permanent link">&para;</a></h6>
<h6 id="_416">二叉树转森林<a class="headerlink" href="#_416" title="Permanent link">&para;</a></h6>
<h6 id="_417">若是二叉树的根，则取消所有 的右孩子，右孩子的右孩子 之间的关系<a class="headerlink" href="#_417" title="Permanent link">&para;</a></h6>
<h6 id="_418">此时有 颗孤立的二叉树，把这些二叉树转成树<a class="headerlink" href="#_418" title="Permanent link">&para;</a></h6>
<h4 id="_419">树和森林的遍历<a class="headerlink" href="#_419" title="Permanent link">&para;</a></h4>
<h6 id="_420">树的遍历<a class="headerlink" href="#_420" title="Permanent link">&para;</a></h6>
<h6 id="_421">先根遍历 若树不为空，则先访问根节点，然后再依次先根遍历遍历各个子树<a class="headerlink" href="#_421" title="Permanent link">&para;</a></h6>
<h6 id="_422">后根遍历 若树不为空，先依次后根遍历各个子树，再访问根节点<a class="headerlink" href="#_422" title="Permanent link">&para;</a></h6>
<h6 id="_423">层次遍历 自上到下，从左到右<a class="headerlink" href="#_423" title="Permanent link">&para;</a></h6>
<h6 id="s">s<a class="headerlink" href="#s" title="Permanent link">&para;</a></h6>
<h6 id="_424">先根遍历为<a class="headerlink" href="#_424" title="Permanent link">&para;</a></h6>
<h6 id="_425">后根遍历<a class="headerlink" href="#_425" title="Permanent link">&para;</a></h6>
<h6 id="_426">森林的遍历<a class="headerlink" href="#_426" title="Permanent link">&para;</a></h6>
<h6 id="_427">假设有森林 ，有 棵互不相交的树<a class="headerlink" href="#_427" title="Permanent link">&para;</a></h6>
<h6 id="_428">将森林看成三部分<a class="headerlink" href="#_428" title="Permanent link">&para;</a></h6>
<h6 id="_429">森林中第一棵树的根节点<a class="headerlink" href="#_429" title="Permanent link">&para;</a></h6>
<h6 id="_430">森林中第一棵树的所有子树<a class="headerlink" href="#_430" title="Permanent link">&para;</a></h6>
<h6 id="_431">森林中 到 颗树<a class="headerlink" href="#_431" title="Permanent link">&para;</a></h6>
<h6 id="_432">先序遍历<a class="headerlink" href="#_432" title="Permanent link">&para;</a></h6>
<h6 id="_433">访问 的根节点<a class="headerlink" href="#_433" title="Permanent link">&para;</a></h6>
<h6 id="_434">先序遍历 的所有子树<a class="headerlink" href="#_434" title="Permanent link">&para;</a></h6>
<h6 id="_435">先序遍历 到<a class="headerlink" href="#_435" title="Permanent link">&para;</a></h6>
<h6 id="_436">即从左到右依次对 进行先根遍历<a class="headerlink" href="#_436" title="Permanent link">&para;</a></h6>
<h6 id="_437">中序遍历<a class="headerlink" href="#_437" title="Permanent link">&para;</a></h6>
<h6 id="_438">中序遍历 的所有子树<a class="headerlink" href="#_438" title="Permanent link">&para;</a></h6>
<h6 id="_439">访问 的根节点<a class="headerlink" href="#_439" title="Permanent link">&para;</a></h6>
<h6 id="_440">中序遍历 到<a class="headerlink" href="#_440" title="Permanent link">&para;</a></h6>
<h6 id="_441">即从左到右依次对 进行后根遍历<a class="headerlink" href="#_441" title="Permanent link">&para;</a></h6>
<h6 id="_442">对上图进行先序遍历和中序遍历<a class="headerlink" href="#_442" title="Permanent link">&para;</a></h6>
<h6 id="_443">先序<a class="headerlink" href="#_443" title="Permanent link">&para;</a></h6>
<h6 id="_444">中序<a class="headerlink" href="#_444" title="Permanent link">&para;</a></h6>
<h3 id="_445">哈夫曼树<a class="headerlink" href="#_445" title="Permanent link">&para;</a></h3>
<h4 id="_446">术语<a class="headerlink" href="#_446" title="Permanent link">&para;</a></h4>
<h6 id="_447">路径<a class="headerlink" href="#_447" title="Permanent link">&para;</a></h6>
<h6 id="_448">从树中一个节点到另一个节点之间的分支，组成两个节点间的路径<a class="headerlink" href="#_448" title="Permanent link">&para;</a></h6>
<h6 id="_449">节点的路径长度<a class="headerlink" href="#_449" title="Permanent link">&para;</a></h6>
<h6 id="_450">两节点间路径上的分支数<a class="headerlink" href="#_450" title="Permanent link">&para;</a></h6>
<h6 id="_451">树的路径长度<a class="headerlink" href="#_451" title="Permanent link">&para;</a></h6>
<h6 id="_452">从树根到每一个节点的路径长度之和，记作<a class="headerlink" href="#_452" title="Permanent link">&para;</a></h6>
<h6 id="_453">节点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树<a class="headerlink" href="#_453" title="Permanent link">&para;</a></h6>
<h6 id="_454">权<a class="headerlink" href="#_454" title="Permanent link">&para;</a></h6>
<h6 id="_455">将树中节点赋给一个含有某种意义的值，这个值叫<a class="headerlink" href="#_455" title="Permanent link">&para;</a></h6>
<h6 id="_456">结点的带权路径长度<a class="headerlink" href="#_456" title="Permanent link">&para;</a></h6>
<h6 id="_457">从根节点到该节点之间的路径长度与该节点的乘积，即<a class="headerlink" href="#_457" title="Permanent link">&para;</a></h6>
<h6 id="_458">树的带权路径长度<a class="headerlink" href="#_458" title="Permanent link">&para;</a></h6>
<h6 id="_459">树中所有叶子节点的带权路径长度之和<a class="headerlink" href="#_459" title="Permanent link">&para;</a></h6>
<h6 id="_460">如下图<a class="headerlink" href="#_460" title="Permanent link">&para;</a></h6>
<h4 id="_461">最优二叉树<a class="headerlink" href="#_461" title="Permanent link">&para;</a></h4>
<h6 id="_462">哈夫曼树，又称最优二叉树，即带权路径 最短的树<a class="headerlink" href="#_462" title="Permanent link">&para;</a></h6>
<h6 id="_463">注意<a class="headerlink" href="#_463" title="Permanent link">&para;</a></h6>
<h6 id="_464">是 相同的树比较之下<a class="headerlink" href="#_464" title="Permanent link">&para;</a></h6>
<h6 id="_465">完全二叉树包括满二叉树不一定是哈夫曼树<a class="headerlink" href="#_465" title="Permanent link">&para;</a></h6>
<h6 id="_466">哈夫曼树中权值越大的叶子节点离根节点越近<a class="headerlink" href="#_466" title="Permanent link">&para;</a></h6>
<h6 id="_467">具有相同带权路径的哈夫曼树，节点位置不唯一<a class="headerlink" href="#_467" title="Permanent link">&para;</a></h6>
<h4 id="_468">构造哈夫曼树<a class="headerlink" href="#_468" title="Permanent link">&para;</a></h4>
<h4 id="step_1">step和定理<a class="headerlink" href="#step_1" title="Permanent link">&para;</a></h4>
<h6 id="_469">根据 个给定的权值 构成 个只有根节点的森林 森林里全是根<a class="headerlink" href="#_469" title="Permanent link">&para;</a></h6>
<h6 id="_470">在 中选取两个权值最小的树 ，构造一颗新的二叉树<a class="headerlink" href="#_470" title="Permanent link">&para;</a></h6>
<h6 id="_471">在 中删除 ，把 加入 中<a class="headerlink" href="#_471" title="Permanent link">&para;</a></h6>
<h6 id="_472">重复如上步骤，直到 中只有一颗树<a class="headerlink" href="#_472" title="Permanent link">&para;</a></h6>
<h6 id="_473">定理<a class="headerlink" href="#_473" title="Permanent link">&para;</a></h6>
<h6 id="_474">包含 个节点的树，需要经过 次合并才能形成哈夫曼树<a class="headerlink" href="#_474" title="Permanent link">&para;</a></h6>
<h6 id="_475">定理<a class="headerlink" href="#_475" title="Permanent link">&para;</a></h6>
<h6 id="_476">把一颗含有 个节点的树，转化成哈夫曼树，那么这个哈夫曼树一共有 个<a class="headerlink" href="#_476" title="Permanent link">&para;</a></h6>
<h6 id="_477">定理<a class="headerlink" href="#_477" title="Permanent link">&para;</a></h6>
<h4 id="_478">代码实现<a class="headerlink" href="#_478" title="Permanent link">&para;</a></h4>
<h6 id="_479">数据类型定义<a class="headerlink" href="#_479" title="Permanent link">&para;</a></h6>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-196-1">1</a></span>
<span class="normal"><a href="#__codelineno-196-2">2</a></span>
<span class="normal"><a href="#__codelineno-196-3">3</a></span>
<span class="normal"><a href="#__codelineno-196-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-196-1" name="__codelineno-196-1"></a>typedef struct __HTNode {
<a id="__codelineno-196-2" name="__codelineno-196-2"></a>int weight;
<a id="__codelineno-196-3" name="__codelineno-196-3"></a>int parent, lchild, rchild;
<a id="__codelineno-196-4" name="__codelineno-196-4"></a>} HTNode, *HTree;
</code></pre></div></td></tr></table></div>
<p>前置函数，选取两个最小值</p>
<p>Creat_Huffman</p>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-197-1">1</a></span>
<span class="normal"><a href="#__codelineno-197-2">2</a></span>
<span class="normal"><a href="#__codelineno-197-3">3</a></span>
<span class="normal"><a href="#__codelineno-197-4">4</a></span>
<span class="normal"><a href="#__codelineno-197-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-197-1" name="__codelineno-197-1"></a>void Select_Min(const HTree T, int length, int *e1, int *e2) {
<a id="__codelineno-197-2" name="__codelineno-197-2"></a>int min1, min2;
<a id="__codelineno-197-3" name="__codelineno-197-3"></a>min1 = min2 = INT_MAX;
<a id="__codelineno-197-4" name="__codelineno-197-4"></a>int pos1, pos2;
<a id="__codelineno-197-5" name="__codelineno-197-5"></a>pos1 = pos2 = 0 ;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-198-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-198-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-198-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-198-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-198-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-198-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-198-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-198-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-198-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-198-10">10</a></span>
<span class="normal"><a href="#__codelineno-198-11">11</a></span>
<span class="normal"><a href="#__codelineno-198-12">12</a></span>
<span class="normal"><a href="#__codelineno-198-13">13</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-198-1" name="__codelineno-198-1"></a>for (int i = 1 ; i &lt; length + 1 ; ++i) {
<a id="__codelineno-198-2" name="__codelineno-198-2"></a>if (T[i].parent == 0 ) { //! parent==0 说明在森林中
<a id="__codelineno-198-3" name="__codelineno-198-3"></a>if (T[i].weight &lt; min1) {
<a id="__codelineno-198-4" name="__codelineno-198-4"></a>min2 = min1;
<a id="__codelineno-198-5" name="__codelineno-198-5"></a>pos2 = pos1;
<a id="__codelineno-198-6" name="__codelineno-198-6"></a>min1 = T[i].weight;
<a id="__codelineno-198-7" name="__codelineno-198-7"></a>pos1 = i;
<a id="__codelineno-198-8" name="__codelineno-198-8"></a>} else if (T[i].weight &lt; min2) {
<a id="__codelineno-198-9" name="__codelineno-198-9"></a>min2 = T[i].weight;
<a id="__codelineno-198-10" name="__codelineno-198-10"></a>pos2 = i;
<a id="__codelineno-198-11" name="__codelineno-198-11"></a>}
<a id="__codelineno-198-12" name="__codelineno-198-12"></a>}
<a id="__codelineno-198-13" name="__codelineno-198-13"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-199-1">1</a></span>
<span class="normal"><a href="#__codelineno-199-2">2</a></span>
<span class="normal"><a href="#__codelineno-199-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-199-1" name="__codelineno-199-1"></a>*e1 = pos1;
<a id="__codelineno-199-2" name="__codelineno-199-2"></a>*e2 = pos2;
<a id="__codelineno-199-3" name="__codelineno-199-3"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-200-1">1</a></span>
<span class="normal"><a href="#__codelineno-200-2">2</a></span>
<span class="normal"><a href="#__codelineno-200-3">3</a></span>
<span class="normal"><a href="#__codelineno-200-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-200-1" name="__codelineno-200-1"></a>void Creat_Huffman(HTree *T, int n) {
<a id="__codelineno-200-2" name="__codelineno-200-2"></a>if (n &lt;= 1 )
<a id="__codelineno-200-3" name="__codelineno-200-3"></a>return;
<a id="__codelineno-200-4" name="__codelineno-200-4"></a>int m = 2 * n - 1 ; //定理 2
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-201-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-201-1" name="__codelineno-201-1"></a>*T = (HTree)malloc(sizeof(HTNode) * (m + 1 )); // 0号位置不存元素
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-202-1">1</a></span>
<span class="normal"><a href="#__codelineno-202-2">2</a></span>
<span class="normal"><a href="#__codelineno-202-3">3</a></span>
<span class="normal"><a href="#__codelineno-202-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-202-1" name="__codelineno-202-1"></a>for (int i = 1 ; i &lt; m + 1 ; ++i) { //进行初始化
<a id="__codelineno-202-2" name="__codelineno-202-2"></a>(*T)[i].lchild = (*T)[i].rchild = 0 ;
<a id="__codelineno-202-3" name="__codelineno-202-3"></a>(*T)[i].parent = 0 ;
<a id="__codelineno-202-4" name="__codelineno-202-4"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-203-1">1</a></span>
<span class="normal"><a href="#__codelineno-203-2">2</a></span>
<span class="normal"><a href="#__codelineno-203-3">3</a></span>
<span class="normal"><a href="#__codelineno-203-4">4</a></span>
<span class="normal"><a href="#__codelineno-203-5">5</a></span>
<span class="normal"><a href="#__codelineno-203-6">6</a></span>
<span class="normal"><a href="#__codelineno-203-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-203-1" name="__codelineno-203-1"></a>for (int i = 1 ; i &lt; n + 1 ; ++i) { //赋值weight
<a id="__codelineno-203-2" name="__codelineno-203-2"></a>scanf(&quot; %d&quot;, &amp;(*T)[i].weight);
<a id="__codelineno-203-3" name="__codelineno-203-3"></a>}
<a id="__codelineno-203-4" name="__codelineno-203-4"></a>//-------------------初始化完毕，开始构造--------------------------
<a id="__codelineno-203-5" name="__codelineno-203-5"></a>int min1, min2; //表示第一小和第二小的位置
<a id="__codelineno-203-6" name="__codelineno-203-6"></a>for (int i = n + 1 ; i &lt; m + 1 ; ++i) { // n+1号位置为新构造的节点下标
<a id="__codelineno-203-7" name="__codelineno-203-7"></a>Select_Min(*T, i - 1 , &amp;min1, &amp;min2); //! 核心语句 动态的选择大小
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-204-1">1</a></span>
<span class="normal"><a href="#__codelineno-204-2">2</a></span>
<span class="normal"><a href="#__codelineno-204-3">3</a></span>
<span class="normal"><a href="#__codelineno-204-4">4</a></span>
<span class="normal"><a href="#__codelineno-204-5">5</a></span>
<span class="normal"><a href="#__codelineno-204-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-204-1" name="__codelineno-204-1"></a>(*T)[min1].parent = (*T)[min2].parent = i; //合并
<a id="__codelineno-204-2" name="__codelineno-204-2"></a>(*T)[i].lchild = min1; //新节点的左右孩子
<a id="__codelineno-204-3" name="__codelineno-204-3"></a>(*T)[i].rchild = min2;
<a id="__codelineno-204-4" name="__codelineno-204-4"></a>(*T)[i].weight = (*T)[min1].weight + (*T)[min2].weight; //赋值权值
<a id="__codelineno-204-5" name="__codelineno-204-5"></a>}
<a id="__codelineno-204-6" name="__codelineno-204-6"></a>}
</code></pre></div></td></tr></table></div></p>
<h6 id="_480">测试代码<a class="headerlink" href="#_480" title="Permanent link">&para;</a></h6>
<h3 id="_481">哈夫曼编码<a class="headerlink" href="#_481" title="Permanent link">&para;</a></h3>
<h6 id="_482">讨论的背景<a class="headerlink" href="#_482" title="Permanent link">&para;</a></h6>
<h6 id="_483">在远程通信中传递字符串时，需要转换成二进制的字符串<a class="headerlink" href="#_483" title="Permanent link">&para;</a></h6>
<h6 id="_484">即，让待传递字符串中出现次数多的字符采用尽可能短的编码<a class="headerlink" href="#_484" title="Permanent link">&para;</a></h6>
<h6 id="_485">这样的话二进制字符串的编码就会缩短<a class="headerlink" href="#_485" title="Permanent link">&para;</a></h6>
<h6 id="_486">但，由于二进制只有 和 ，所以有可能二进制代码转成字符时，出现二义性<a class="headerlink" href="#_486" title="Permanent link">&para;</a></h6>
<h6 id="_487">所以要设计长度不等的编码，则必须使任一字符的编码都不是另一个字符编码的前缀<a class="headerlink" href="#_487" title="Permanent link">&para;</a></h6>
<h6 id="_488">如上形式的编码称为 前缀码<a class="headerlink" href="#_488" title="Permanent link">&para;</a></h6>
<h6 id="_489">哈夫曼编码<a class="headerlink" href="#_489" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-205-1">1</a></span>
<span class="normal"><a href="#__codelineno-205-2">2</a></span>
<span class="normal"><a href="#__codelineno-205-3">3</a></span>
<span class="normal"><a href="#__codelineno-205-4">4</a></span>
<span class="normal"><a href="#__codelineno-205-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-205-1" name="__codelineno-205-1"></a>#include &quot;HuffmanTree.h&quot;
<a id="__codelineno-205-2" name="__codelineno-205-2"></a>#define NODES 8
<a id="__codelineno-205-3" name="__codelineno-205-3"></a>int main(void) {
<a id="__codelineno-205-4" name="__codelineno-205-4"></a>HTree T = NULL;
<a id="__codelineno-205-5" name="__codelineno-205-5"></a>Creat_Huffman(&amp;T, NODES);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-206-1">1</a></span>
<span class="normal"><a href="#__codelineno-206-2">2</a></span>
<span class="normal"><a href="#__codelineno-206-3">3</a></span>
<span class="normal"><a href="#__codelineno-206-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-206-1" name="__codelineno-206-1"></a>for (int i = 1 ; i &lt; 2 * NODES; ++i) {
<a id="__codelineno-206-2" name="__codelineno-206-2"></a>printf(&quot;weight = %d\tparent = %d\tlchild = %d\trchild = %d\n&quot;, T[i].weight,
<a id="__codelineno-206-3" name="__codelineno-206-3"></a>T[i].parent, T[i].lchild, T[i].rchild);
<a id="__codelineno-206-4" name="__codelineno-206-4"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-207-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-207-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-207-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-207-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-207-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-207-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-207-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-207-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-207-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-207-10">10</a></span>
<span class="normal"><a href="#__codelineno-207-11">11</a></span>
<span class="normal"><a href="#__codelineno-207-12">12</a></span>
<span class="normal"><a href="#__codelineno-207-13">13</a></span>
<span class="normal"><a href="#__codelineno-207-14">14</a></span>
<span class="normal"><a href="#__codelineno-207-15">15</a></span>
<span class="normal"><a href="#__codelineno-207-16">16</a></span>
<span class="normal"><a href="#__codelineno-207-17">17</a></span>
<span class="normal"><a href="#__codelineno-207-18">18</a></span>
<span class="normal"><a href="#__codelineno-207-19">19</a></span>
<span class="normal"><a href="#__codelineno-207-20">20</a></span>
<span class="normal"><a href="#__codelineno-207-21">21</a></span>
<span class="normal"><a href="#__codelineno-207-22">22</a></span>
<span class="normal"><a href="#__codelineno-207-23">23</a></span>
<span class="normal"><a href="#__codelineno-207-24">24</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-207-1" name="__codelineno-207-1"></a>system(&quot;pause&quot;);
<a id="__codelineno-207-2" name="__codelineno-207-2"></a>return 0 ;
<a id="__codelineno-207-3" name="__codelineno-207-3"></a>}
<a id="__codelineno-207-4" name="__codelineno-207-4"></a>//
<a id="__codelineno-207-5" name="__codelineno-207-5"></a>/*
<a id="__codelineno-207-6" name="__codelineno-207-6"></a>input: 7 19 2 6 32 3 21 10
<a id="__codelineno-207-7" name="__codelineno-207-7"></a>------------------------------------------
<a id="__codelineno-207-8" name="__codelineno-207-8"></a>output:
<a id="__codelineno-207-9" name="__codelineno-207-9"></a>weight = 7 parent = 11 lchild = 0 rchild = 0
<a id="__codelineno-207-10" name="__codelineno-207-10"></a>weight = 19 parent = 13 lchild = 0 rchild = 0
<a id="__codelineno-207-11" name="__codelineno-207-11"></a>weight = 2 parent = 9 lchild = 0 rchild = 0
<a id="__codelineno-207-12" name="__codelineno-207-12"></a>weight = 6 parent = 10 lchild = 0 rchild = 0
<a id="__codelineno-207-13" name="__codelineno-207-13"></a>weight = 32 parent = 14 lchild = 0 rchild = 0
<a id="__codelineno-207-14" name="__codelineno-207-14"></a>weight = 3 parent = 9 lchild = 0 rchild = 0
<a id="__codelineno-207-15" name="__codelineno-207-15"></a>weight = 21 parent = 13 lchild = 0 rchild = 0
<a id="__codelineno-207-16" name="__codelineno-207-16"></a>weight = 10 parent = 11 lchild = 0 rchild = 0
<a id="__codelineno-207-17" name="__codelineno-207-17"></a>weight = 5 parent = 10 lchild = 3 rchild = 6
<a id="__codelineno-207-18" name="__codelineno-207-18"></a>weight = 11 parent = 12 lchild = 9 rchild = 4
<a id="__codelineno-207-19" name="__codelineno-207-19"></a>weight = 17 parent = 12 lchild = 1 rchild = 8
<a id="__codelineno-207-20" name="__codelineno-207-20"></a>weight = 28 parent = 14 lchild = 10 rchild = 11
<a id="__codelineno-207-21" name="__codelineno-207-21"></a>weight = 40 parent = 15 lchild = 2 rchild = 7
<a id="__codelineno-207-22" name="__codelineno-207-22"></a>weight = 60 parent = 15 lchild = 12 rchild = 5
<a id="__codelineno-207-23" name="__codelineno-207-23"></a>weight = 100 parent = 0 lchild = 13 rchild = 14
<a id="__codelineno-207-24" name="__codelineno-207-24"></a>*/
</code></pre></div></td></tr></table></div></p>
<h6 id="_490">哈夫曼编码是总长最短的前缀码<a class="headerlink" href="#_490" title="Permanent link">&para;</a></h6>
<h6 id="_491">统计字符集中每个字符在电文中出现的平均概率概率越大，编码要求最短<a class="headerlink" href="#_491" title="Permanent link">&para;</a></h6>
<h6 id="_492">利用哈夫曼树的特点 权值越大的叶子离根越近 将每个字符的概率值最为权值，构造哈夫曼树<a class="headerlink" href="#_492" title="Permanent link">&para;</a></h6>
<h6 id="_493">在哈夫曼树的每个分支上标 和 ，左分支为 ，右分支为<a class="headerlink" href="#_493" title="Permanent link">&para;</a></h6>
<h6 id="_494">为什么哈夫曼编码是最短的前缀码？<a class="headerlink" href="#_494" title="Permanent link">&para;</a></h6>
<h6 id="_495">根据哈夫曼树的特性，原树中的 个节点，在哈夫曼树中变成了叶子<a class="headerlink" href="#_495" title="Permanent link">&para;</a></h6>
<h6 id="_496">叶子节点不会是另一个叶子的双亲或是祖先，所以是前缀码<a class="headerlink" href="#_496" title="Permanent link">&para;</a></h6>
<h6 id="_497">哈夫曼树的性质<a class="headerlink" href="#_497" title="Permanent link">&para;</a></h6>
<h6 id="_498">性质 哈夫曼编码是前缀码<a class="headerlink" href="#_498" title="Permanent link">&para;</a></h6>
<h6 id="_499">性质 哈夫曼编码是最优前缀码<a class="headerlink" href="#_499" title="Permanent link">&para;</a></h6>
<h4 id="_500">代码实现<a class="headerlink" href="#_500" title="Permanent link">&para;</a></h4>
<h6 id="_501">测试代码<a class="headerlink" href="#_501" title="Permanent link">&para;</a></h6>
<h6 id="_502">构建如下哈夫曼编码<a class="headerlink" href="#_502" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-208-1">1</a></span>
<span class="normal"><a href="#__codelineno-208-2">2</a></span>
<span class="normal"><a href="#__codelineno-208-3">3</a></span>
<span class="normal"><a href="#__codelineno-208-4">4</a></span>
<span class="normal"><a href="#__codelineno-208-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-208-1" name="__codelineno-208-1"></a>HuffmanCode Creat_HuffmanCode(const HTree HT, int n) {
<a id="__codelineno-208-2" name="__codelineno-208-2"></a>// HC和哈夫曼树一样，不使用 0 号下标
<a id="__codelineno-208-3" name="__codelineno-208-3"></a>HuffmanCode HC = (char **)malloc(sizeof(char *) * (n + 1 ));
<a id="__codelineno-208-4" name="__codelineno-208-4"></a>char *temp_string = (char *)malloc(sizeof(char) * n); //此数组使用 0 号下标
<a id="__codelineno-208-5" name="__codelineno-208-5"></a>temp_string[n - 1 ] = &#39;\0&#39;; //因为存放字符串所以最后一个位置 &#39;\0&#39;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-209-1">1</a></span>
<span class="normal"><a href="#__codelineno-209-2">2</a></span>
<span class="normal"><a href="#__codelineno-209-3">3</a></span>
<span class="normal"><a href="#__codelineno-209-4">4</a></span>
<span class="normal"><a href="#__codelineno-209-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-209-1" name="__codelineno-209-1"></a>for (int i = 1 ; i &lt; n + 1 ; ++i) {
<a id="__codelineno-209-2" name="__codelineno-209-2"></a>int parent = HT[i].parent; //需要向上回溯
<a id="__codelineno-209-3" name="__codelineno-209-3"></a>int current = i; //回溯中当前节点
<a id="__codelineno-209-4" name="__codelineno-209-4"></a>int start = n - 1 ; //数组中最后一个位置，即&#39;\0&#39;
<a id="__codelineno-209-5" name="__codelineno-209-5"></a>while (parent) {
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-210-1">1</a></span>
<span class="normal"><a href="#__codelineno-210-2">2</a></span>
<span class="normal"><a href="#__codelineno-210-3">3</a></span>
<span class="normal"><a href="#__codelineno-210-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-210-1" name="__codelineno-210-1"></a>if (current == HT[parent].lchild) //如果是左孩子，那么为&#39;0&#39;
<a id="__codelineno-210-2" name="__codelineno-210-2"></a>temp_string[--start] = &#39;0&#39;;
<a id="__codelineno-210-3" name="__codelineno-210-3"></a>else
<a id="__codelineno-210-4" name="__codelineno-210-4"></a>temp_string[--start] = &#39;1&#39;; //右孩子为 &#39;1&#39;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-211-1">1</a></span>
<span class="normal"><a href="#__codelineno-211-2">2</a></span>
<span class="normal"><a href="#__codelineno-211-3">3</a></span>
<span class="normal"><a href="#__codelineno-211-4">4</a></span>
<span class="normal"><a href="#__codelineno-211-5">5</a></span>
<span class="normal"><a href="#__codelineno-211-6">6</a></span>
<span class="normal"><a href="#__codelineno-211-7">7</a></span>
<span class="normal"><a href="#__codelineno-211-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-211-1" name="__codelineno-211-1"></a>current = parent;
<a id="__codelineno-211-2" name="__codelineno-211-2"></a>parent = HT[parent].parent;
<a id="__codelineno-211-3" name="__codelineno-211-3"></a>}
<a id="__codelineno-211-4" name="__codelineno-211-4"></a>//计算长度:因为strat表示字符串的起始下标，n-1表示末尾结束符&#39;\0&#39;,所以 length
<a id="__codelineno-211-5" name="__codelineno-211-5"></a>//= n-1-start+1=n-start;
<a id="__codelineno-211-6" name="__codelineno-211-6"></a>HC[i] = (char *)malloc(sizeof(char) * (n - start)); //根据长度分配空间
<a id="__codelineno-211-7" name="__codelineno-211-7"></a>strcpy(HC[i], &amp;temp_string[start]); //拷贝字符串
<a id="__codelineno-211-8" name="__codelineno-211-8"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-212-1">1</a></span>
<span class="normal"><a href="#__codelineno-212-2">2</a></span>
<span class="normal"><a href="#__codelineno-212-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-212-1" name="__codelineno-212-1"></a>free(temp_string); //释放堆空间
<a id="__codelineno-212-2" name="__codelineno-212-2"></a>return HC;
<a id="__codelineno-212-3" name="__codelineno-212-3"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-213-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-213-1" name="__codelineno-213-1"></a>#include &quot;HuffmanTree.h&quot;
</code></pre></div></td></tr></table></div></p>
<h1 id="define-nodes-7">define NODES 7<a class="headerlink" href="#define-nodes-7" title="Permanent link">&para;</a></h1>
<p>int main(void) {
HTree T = NULL;
Creat_Huffman(&amp;T, NODES);</p>
<p>HuffmanCode HC = Creat_HuffmanCode(T, NODES);
int a = 65 ; // ASCII 65 是'A'
for (int i = 1 ; i &lt; NODES + 1 ; ++i) {
printf("%c=%s\n", a, HC[i]);
++a;
}</p>
<p>system("pause");
return 0 ;
}
//
/*
input: 40 30 15 5 4 3 3</p>
<hr />
<p>output:
A=0
B=10
C=110
D=11111
E=11110
F=11100
G=11101
*/</p>
<h4 id="_503">整体头文件<a class="headerlink" href="#_503" title="Permanent link">&para;</a></h4>
<h2 id="5-graph_1">5. 图(Graph)<a class="headerlink" href="#5-graph_1" title="Permanent link">&para;</a></h2>
<h3 id="_504">图的定义和术语<a class="headerlink" href="#_504" title="Permanent link">&para;</a></h3>
<h6 id="_505">图<a class="headerlink" href="#_505" title="Permanent link">&para;</a></h6>
<h6 id="_506">顶点的有限非空集合<a class="headerlink" href="#_506" title="Permanent link">&para;</a></h6>
<h6 id="_507">边的有限集合<a class="headerlink" href="#_507" title="Permanent link">&para;</a></h6>
<h6 id="_508">图分为有向图 和无向图<a class="headerlink" href="#_508" title="Permanent link">&para;</a></h6>
<h6 id="_509">如下图<a class="headerlink" href="#_509" title="Permanent link">&para;</a></h6>
<h4 id="_510">完全图<a class="headerlink" href="#_510" title="Permanent link">&para;</a></h4>
<h6 id="_511">完全图<a class="headerlink" href="#_511" title="Permanent link">&para;</a></h6>
<h6 id="_512">任意两个点都有一条边相连<a class="headerlink" href="#_512" title="Permanent link">&para;</a></h6>
<h6 id="_513">若有 个顶点的无向完全图，则<a class="headerlink" href="#_513" title="Permanent link">&para;</a></h6>
<h6 id="_514">若有 个顶点的有向完全图，则<a class="headerlink" href="#_514" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-214-1">1</a></span>
<span class="normal"><a href="#__codelineno-214-2">2</a></span>
<span class="normal"><a href="#__codelineno-214-3">3</a></span>
<span class="normal"><a href="#__codelineno-214-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-214-1" name="__codelineno-214-1"></a>#include &quot;define.h&quot;
<a id="__codelineno-214-2" name="__codelineno-214-2"></a>#include &quot;string.h&quot;
<a id="__codelineno-214-3" name="__codelineno-214-3"></a>#ifndef __HUFFMANTREE_H
<a id="__codelineno-214-4" name="__codelineno-214-4"></a>#define __HUFFMANTREE_H
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-215-1">1</a></span>
<span class="normal"><a href="#__codelineno-215-2">2</a></span>
<span class="normal"><a href="#__codelineno-215-3">3</a></span>
<span class="normal"><a href="#__codelineno-215-4">4</a></span>
<span class="normal"><a href="#__codelineno-215-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-215-1" name="__codelineno-215-1"></a>typedef struct __HTNode {
<a id="__codelineno-215-2" name="__codelineno-215-2"></a>int weight;
<a id="__codelineno-215-3" name="__codelineno-215-3"></a>int parent, lchild, rchild;
<a id="__codelineno-215-4" name="__codelineno-215-4"></a>} HTNode, *HTree;
<a id="__codelineno-215-5" name="__codelineno-215-5"></a>typedef char **HuffmanCode;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-216-1">1</a></span>
<span class="normal"><a href="#__codelineno-216-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-216-1" name="__codelineno-216-1"></a>void Select_Min(const HTree T, int length, int *e1, int *e2);
<a id="__codelineno-216-2" name="__codelineno-216-2"></a>void Creat_Huffman(HTree *T, int n);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-217-1">1</a></span>
<span class="normal"><a href="#__codelineno-217-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-217-1" name="__codelineno-217-1"></a>HuffmanCode Creat_HuffmanCode(const HTree HT, int n);
<a id="__codelineno-217-2" name="__codelineno-217-2"></a>#endif
</code></pre></div></td></tr></table></div></p>
<h4 id="sparse-graphdense-gaph_1">稀疏图(Sparse Graph)和稠密图(Dense Gaph)<a class="headerlink" href="#sparse-graphdense-gaph_1" title="Permanent link">&para;</a></h4>
<h6 id="_515">稠密图<a class="headerlink" href="#_515" title="Permanent link">&para;</a></h6>
<h6 id="_516">稠密图 有较多边的图<a class="headerlink" href="#_516" title="Permanent link">&para;</a></h6>
<h4 id="degree_1">顶点的度(degree)<a class="headerlink" href="#degree_1" title="Permanent link">&para;</a></h4>
<h6 id="_517">与该顶点相关联的边的数量<a class="headerlink" href="#_517" title="Permanent link">&para;</a></h6>
<h6 id="_518">中，顶点的度<a class="headerlink" href="#_518" title="Permanent link">&para;</a></h6>
<h6 id="_519">问题 当 中，仅有一个顶点的 为 ，其余顶点的 ，此时图为什么形状<a class="headerlink" href="#_519" title="Permanent link">&para;</a></h6>
<h6 id="_520">答 树，有向树<a class="headerlink" href="#_520" title="Permanent link">&para;</a></h6>
<h4 id="path_1">路径(path)<a class="headerlink" href="#path_1" title="Permanent link">&para;</a></h4>
<h6 id="_521">路径 接续的边构成的顶点序列<a class="headerlink" href="#_521" title="Permanent link">&para;</a></h6>
<h6 id="_522">路径长度 路径上边的数量或权值之和<a class="headerlink" href="#_522" title="Permanent link">&para;</a></h6>
<h6 id="_523">回路 第一个顶点和最后一个顶点相同的路径<a class="headerlink" href="#_523" title="Permanent link">&para;</a></h6>
<h6 id="_524">路径 路径上的顶点均不相同<a class="headerlink" href="#_524" title="Permanent link">&para;</a></h6>
<h6 id="_525">回路 除路径起点和终点可以相同外，其余顶点均不相同的路径<a class="headerlink" href="#_525" title="Permanent link">&para;</a></h6>
<h4 id="connected-graph_1">连通图(Connected Graph)<a class="headerlink" href="#connected-graph_1" title="Permanent link">&para;</a></h4>
<h6 id="_526">若连通图<a class="headerlink" href="#_526" title="Permanent link">&para;</a></h6>
<h6 id="_527">在无向图 中<a class="headerlink" href="#_527" title="Permanent link">&para;</a></h6>
<h6 id="_528">若对任何两个顶点 ，都存在 路径，则 是连通图<a class="headerlink" href="#_528" title="Permanent link">&para;</a></h6>
<h6 id="_529">弱连通图<a class="headerlink" href="#_529" title="Permanent link">&para;</a></h6>
<h6 id="_530">若把有向图 中所有的边替换成无向边，此时得到的图为 的基图<a class="headerlink" href="#_530" title="Permanent link">&para;</a></h6>
<h6 id="_531">若它的基图为连通图，则 为若连通<a class="headerlink" href="#_531" title="Permanent link">&para;</a></h6>
<h6 id="_532">强连通<a class="headerlink" href="#_532" title="Permanent link">&para;</a></h6>
<h6 id="_533">任取有向图 中两个顶点 ，若 和 中间存在路径，则 为强连通<a class="headerlink" href="#_533" title="Permanent link">&para;</a></h6>
<h4 id="connected-component_1">连通子图和连通分量(Connected Component)<a class="headerlink" href="#connected-component_1" title="Permanent link">&para;</a></h4>
<h6 id="_534">无向图 的极大连通子图称为 的连通分量<a class="headerlink" href="#_534" title="Permanent link">&para;</a></h6>
<h6 id="_535">极大连通子图 若无向图 的子图 为连通图<a class="headerlink" href="#_535" title="Permanent link">&para;</a></h6>
<h6 id="_536">任取 即<a class="headerlink" href="#_536" title="Permanent link">&para;</a></h6>
<h6 id="_537">若把 加入到 中，如果 不再连通，则称 为 的极大连通子图<a class="headerlink" href="#_537" title="Permanent link">&para;</a></h6>
<h6 id="_538">如下图<a class="headerlink" href="#_538" title="Permanent link">&para;</a></h6>
<h6 id="_539">强连通分量<a class="headerlink" href="#_539" title="Permanent link">&para;</a></h6>
<h6 id="_540">有向图 的极大强连通子图称为 的连通分量<a class="headerlink" href="#_540" title="Permanent link">&para;</a></h6>
<h6 id="_541">若有向图 的子图 为连通图<a class="headerlink" href="#_541" title="Permanent link">&para;</a></h6>
<h6 id="_542">任取 即<a class="headerlink" href="#_542" title="Permanent link">&para;</a></h6>
<h6 id="_543">若把 加入到 中，如果 不再连通，则称 为 的极大强连通子图<a class="headerlink" href="#_543" title="Permanent link">&para;</a></h6>
<h4 id="spanning-tree_2">极小连通子图和生成树(Spanning Tree)<a class="headerlink" href="#spanning-tree_2" title="Permanent link">&para;</a></h4>
<h6 id="_544">若子图 是 的连通子图，在改子图中删除任意一条边， 不再连通，则称 是 的极小连通子图<a class="headerlink" href="#_544" title="Permanent link">&para;</a></h6>
<h6 id="_545">注意 极小连通子图中不存在 ，极大连通子图可以存在<a class="headerlink" href="#_545" title="Permanent link">&para;</a></h6>
<h6 id="_546">生成树<a class="headerlink" href="#_546" title="Permanent link">&para;</a></h6>
<h6 id="_547">若无向图 ， 中所有的点构成的极小连通子图就是 的生成树<a class="headerlink" href="#_547" title="Permanent link">&para;</a></h6>
<h3 id="_548">图的存储结构<a class="headerlink" href="#_548" title="Permanent link">&para;</a></h3>
<h4 id="adjacency-matrix_1">邻接矩阵(Adjacency Matrix)<a class="headerlink" href="#adjacency-matrix_1" title="Permanent link">&para;</a></h4>
<h6 id="_549">若有图 ，有 个顶点，则对应 矩阵<a class="headerlink" href="#_549" title="Permanent link">&para;</a></h6>
<h6 id="_550">注意 无向图的邻接矩阵为对称矩阵，而有向图的邻接矩阵未必<a class="headerlink" href="#_550" title="Permanent link">&para;</a></h6>
<h6 id="_551">无向图<a class="headerlink" href="#_551" title="Permanent link">&para;</a></h6>
<h6 id="_552">的邻接矩阵为<a class="headerlink" href="#_552" title="Permanent link">&para;</a></h6>
<h6 id="_553">行中 的个数<a class="headerlink" href="#_553" title="Permanent link">&para;</a></h6>
<h6 id="_554">有向图<a class="headerlink" href="#_554" title="Permanent link">&para;</a></h6>
<h6 id="_555">第列 的个数<a class="headerlink" href="#_555" title="Permanent link">&para;</a></h6>
<h6 id="_556">第行 的个数<a class="headerlink" href="#_556" title="Permanent link">&para;</a></h6>
<h6 id="weighted-graph_1">带权图(网) weighted Graph<a class="headerlink" href="#weighted-graph_1" title="Permanent link">&para;</a></h6>
<h6 id="_557">若有带权图 ，有 个顶点，则对应 矩阵<a class="headerlink" href="#_557" title="Permanent link">&para;</a></h6>
<h6 id="_558">代码实现<a class="headerlink" href="#_558" title="Permanent link">&para;</a></h6>
<h6 id="_559">数据类型定义<a class="headerlink" href="#_559" title="Permanent link">&para;</a></h6>
<h6 id="_560">无向无权图<a class="headerlink" href="#_560" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-218-1">1</a></span>
<span class="normal"><a href="#__codelineno-218-2">2</a></span>
<span class="normal"><a href="#__codelineno-218-3">3</a></span>
<span class="normal"><a href="#__codelineno-218-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-218-1" name="__codelineno-218-1"></a>#define MAXWEIGHT 99999 //最大权值
<a id="__codelineno-218-2" name="__codelineno-218-2"></a>#define MAXVERTEX 20 //最大定点数
<a id="__codelineno-218-3" name="__codelineno-218-3"></a>typedef char VetexType; //顶点用字符表示
<a id="__codelineno-218-4" name="__codelineno-218-4"></a>typedef int MatrixType; //矩阵类型
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-219-1">1</a></span>
<span class="normal"><a href="#__codelineno-219-2">2</a></span>
<span class="normal"><a href="#__codelineno-219-3">3</a></span>
<span class="normal"><a href="#__codelineno-219-4">4</a></span>
<span class="normal"><a href="#__codelineno-219-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-219-1" name="__codelineno-219-1"></a>typedef struct __AMGraph {
<a id="__codelineno-219-2" name="__codelineno-219-2"></a>char vertex[MAXVERTEX];
<a id="__codelineno-219-3" name="__codelineno-219-3"></a>MatrixType edge[MAXVERTEX][MAXVERTEX];
<a id="__codelineno-219-4" name="__codelineno-219-4"></a>int vertices, edges;
<a id="__codelineno-219-5" name="__codelineno-219-5"></a>} AMGraph;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-220-1">1</a></span>
<span class="normal"><a href="#__codelineno-220-2">2</a></span>
<span class="normal"><a href="#__codelineno-220-3">3</a></span>
<span class="normal"><a href="#__codelineno-220-4">4</a></span>
<span class="normal"><a href="#__codelineno-220-5">5</a></span>
<span class="normal"><a href="#__codelineno-220-6">6</a></span>
<span class="normal"><a href="#__codelineno-220-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-220-1" name="__codelineno-220-1"></a>void Creat_unAMGraph_unweightd(AMGraph *G) {
<a id="__codelineno-220-2" name="__codelineno-220-2"></a>//初始化点和边个数
<a id="__codelineno-220-3" name="__codelineno-220-3"></a>printf(&quot;Please input the number of vertices:&quot;);
<a id="__codelineno-220-4" name="__codelineno-220-4"></a>scanf(&quot; %d&quot;, &amp;G-&gt;vertices);
<a id="__codelineno-220-5" name="__codelineno-220-5"></a>printf(&quot;Please input the number of edges:&quot;);
<a id="__codelineno-220-6" name="__codelineno-220-6"></a>scanf(&quot; %d&quot;, &amp;G-&gt;edges);
<a id="__codelineno-220-7" name="__codelineno-220-7"></a>//输入各个顶点的名字
</code></pre></div></td></tr></table></div></p>
<h6 id="_561">测试代码<a class="headerlink" href="#_561" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-221-1">1</a></span>
<span class="normal"><a href="#__codelineno-221-2">2</a></span>
<span class="normal"><a href="#__codelineno-221-3">3</a></span>
<span class="normal"><a href="#__codelineno-221-4">4</a></span>
<span class="normal"><a href="#__codelineno-221-5">5</a></span>
<span class="normal"><a href="#__codelineno-221-6">6</a></span>
<span class="normal"><a href="#__codelineno-221-7">7</a></span>
<span class="normal"><a href="#__codelineno-221-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-221-1" name="__codelineno-221-1"></a>printf(&quot;Please input the name of vertices(just like A B C):&quot;);
<a id="__codelineno-221-2" name="__codelineno-221-2"></a>for (int i = 0 ; i &lt; G-&gt;vertices; ++i) {
<a id="__codelineno-221-3" name="__codelineno-221-3"></a>scanf(&quot; %c&quot;, &amp;G-&gt;vertex[i]);
<a id="__codelineno-221-4" name="__codelineno-221-4"></a>}
<a id="__codelineno-221-5" name="__codelineno-221-5"></a>//把矩阵初始化
<a id="__codelineno-221-6" name="__codelineno-221-6"></a>for (int i = 0 ; i &lt; G-&gt;vertices; ++i)
<a id="__codelineno-221-7" name="__codelineno-221-7"></a>for (int j = 0 ; j &lt; G-&gt;vertices; ++j)
<a id="__codelineno-221-8" name="__codelineno-221-8"></a>G-&gt;edge[i][j] = 0 ;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-222-1">1</a></span>
<span class="normal"><a href="#__codelineno-222-2">2</a></span>
<span class="normal"><a href="#__codelineno-222-3">3</a></span>
<span class="normal"><a href="#__codelineno-222-4">4</a></span>
<span class="normal"><a href="#__codelineno-222-5">5</a></span>
<span class="normal"><a href="#__codelineno-222-6">6</a></span>
<span class="normal"><a href="#__codelineno-222-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-222-1" name="__codelineno-222-1"></a>char v1, v2; //一条边的顶点
<a id="__codelineno-222-2" name="__codelineno-222-2"></a>int index_v1, index_v2; //边的顶点的下标
<a id="__codelineno-222-3" name="__codelineno-222-3"></a>for (int i = 0 ; i &lt; G-&gt;edges; ++i) {
<a id="__codelineno-222-4" name="__codelineno-222-4"></a>printf(&quot;(for %d)Please input the edge(just like A B):&quot;, i + 1 );
<a id="__codelineno-222-5" name="__codelineno-222-5"></a>scanf(&quot; %c %c&quot;, &amp;v1, &amp;v2);
<a id="__codelineno-222-6" name="__codelineno-222-6"></a>index_v1 = Locate_vertex(G, v1);
<a id="__codelineno-222-7" name="__codelineno-222-7"></a>index_v2 = Locate_vertex(G, v2);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-223-1">1</a></span>
<span class="normal"><a href="#__codelineno-223-2">2</a></span>
<span class="normal"><a href="#__codelineno-223-3">3</a></span>
<span class="normal"><a href="#__codelineno-223-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-223-1" name="__codelineno-223-1"></a>G-&gt;edge[index_v1][index_v2] = 1 ;
<a id="__codelineno-223-2" name="__codelineno-223-2"></a>G-&gt;edge[index_v2][index_v1] = 1 ;
<a id="__codelineno-223-3" name="__codelineno-223-3"></a>}
<a id="__codelineno-223-4" name="__codelineno-223-4"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-224-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-224-1" name="__codelineno-224-1"></a>#include &quot;Graph.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-225-1">1</a></span>
<span class="normal"><a href="#__codelineno-225-2">2</a></span>
<span class="normal"><a href="#__codelineno-225-3">3</a></span>
<span class="normal"><a href="#__codelineno-225-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-225-1" name="__codelineno-225-1"></a>int main(void) {
<a id="__codelineno-225-2" name="__codelineno-225-2"></a>AMGraph G;
<a id="__codelineno-225-3" name="__codelineno-225-3"></a>Creat_unAMGraph_unweightd(&amp;G);
<a id="__codelineno-225-4" name="__codelineno-225-4"></a>print_Matrix(&amp;G);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-226-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-226-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-226-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-226-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-226-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-226-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-226-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-226-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-226-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-226-10">10</a></span>
<span class="normal"><a href="#__codelineno-226-11">11</a></span>
<span class="normal"><a href="#__codelineno-226-12">12</a></span>
<span class="normal"><a href="#__codelineno-226-13">13</a></span>
<span class="normal"><a href="#__codelineno-226-14">14</a></span>
<span class="normal"><a href="#__codelineno-226-15">15</a></span>
<span class="normal"><a href="#__codelineno-226-16">16</a></span>
<span class="normal"><a href="#__codelineno-226-17">17</a></span>
<span class="normal"><a href="#__codelineno-226-18">18</a></span>
<span class="normal"><a href="#__codelineno-226-19">19</a></span>
<span class="normal"><a href="#__codelineno-226-20">20</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-226-1" name="__codelineno-226-1"></a>system(&quot;pause&quot;);
<a id="__codelineno-226-2" name="__codelineno-226-2"></a>return 0 ;
<a id="__codelineno-226-3" name="__codelineno-226-3"></a>}
<a id="__codelineno-226-4" name="__codelineno-226-4"></a>//
<a id="__codelineno-226-5" name="__codelineno-226-5"></a>/*
<a id="__codelineno-226-6" name="__codelineno-226-6"></a>5 6
<a id="__codelineno-226-7" name="__codelineno-226-7"></a>A B C D E
<a id="__codelineno-226-8" name="__codelineno-226-8"></a>A B
<a id="__codelineno-226-9" name="__codelineno-226-9"></a>A D
<a id="__codelineno-226-10" name="__codelineno-226-10"></a>B C
<a id="__codelineno-226-11" name="__codelineno-226-11"></a>D C
<a id="__codelineno-226-12" name="__codelineno-226-12"></a>C E
<a id="__codelineno-226-13" name="__codelineno-226-13"></a>B E
<a id="__codelineno-226-14" name="__codelineno-226-14"></a>----------------------
<a id="__codelineno-226-15" name="__codelineno-226-15"></a>0 1 0 1 0
<a id="__codelineno-226-16" name="__codelineno-226-16"></a>1 0 1 0 1
<a id="__codelineno-226-17" name="__codelineno-226-17"></a>0 1 0 1 1
<a id="__codelineno-226-18" name="__codelineno-226-18"></a>1 0 1 0 0
<a id="__codelineno-226-19" name="__codelineno-226-19"></a>0 1 1 0 0
<a id="__codelineno-226-20" name="__codelineno-226-20"></a>*/
</code></pre></div></td></tr></table></div></p>
<h6 id="_562">无向带权图<a class="headerlink" href="#_562" title="Permanent link">&para;</a></h6>
<h6 id="_563">有向带权图<a class="headerlink" href="#_563" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-227-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-227-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-227-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-227-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-227-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-227-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-227-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-227-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-227-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-227-10">10</a></span>
<span class="normal"><a href="#__codelineno-227-11">11</a></span>
<span class="normal"><a href="#__codelineno-227-12">12</a></span>
<span class="normal"><a href="#__codelineno-227-13">13</a></span>
<span class="normal"><a href="#__codelineno-227-14">14</a></span>
<span class="normal"><a href="#__codelineno-227-15">15</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-227-1" name="__codelineno-227-1"></a>void Creat_unAMGraph_weightd(AMGraph *G) {
<a id="__codelineno-227-2" name="__codelineno-227-2"></a>//初始化点和边个数
<a id="__codelineno-227-3" name="__codelineno-227-3"></a>printf(&quot;Please input the number of vertices:&quot;);
<a id="__codelineno-227-4" name="__codelineno-227-4"></a>scanf(&quot; %d&quot;, &amp;G-&gt;vertices);
<a id="__codelineno-227-5" name="__codelineno-227-5"></a>printf(&quot;Please input the number of edges:&quot;);
<a id="__codelineno-227-6" name="__codelineno-227-6"></a>scanf(&quot; %d&quot;, &amp;G-&gt;edges);
<a id="__codelineno-227-7" name="__codelineno-227-7"></a>//输入各个顶点的名字
<a id="__codelineno-227-8" name="__codelineno-227-8"></a>printf(&quot;Please input the name of vertices(just like A B C):&quot;);
<a id="__codelineno-227-9" name="__codelineno-227-9"></a>for (int i = 0 ; i &lt; G-&gt;vertices; ++i) {
<a id="__codelineno-227-10" name="__codelineno-227-10"></a>scanf(&quot; %c&quot;, &amp;G-&gt;vertex[i]);
<a id="__codelineno-227-11" name="__codelineno-227-11"></a>}
<a id="__codelineno-227-12" name="__codelineno-227-12"></a>//把矩阵初始化
<a id="__codelineno-227-13" name="__codelineno-227-13"></a>for (int i = 0 ; i &lt; G-&gt;vertices; ++i)
<a id="__codelineno-227-14" name="__codelineno-227-14"></a>for (int j = 0 ; j &lt; G-&gt;vertices; ++j)
<a id="__codelineno-227-15" name="__codelineno-227-15"></a>G-&gt;edge[i][j] = MAXWEIGHT;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-228-1">1</a></span>
<span class="normal"><a href="#__codelineno-228-2">2</a></span>
<span class="normal"><a href="#__codelineno-228-3">3</a></span>
<span class="normal"><a href="#__codelineno-228-4">4</a></span>
<span class="normal"><a href="#__codelineno-228-5">5</a></span>
<span class="normal"><a href="#__codelineno-228-6">6</a></span>
<span class="normal"><a href="#__codelineno-228-7">7</a></span>
<span class="normal"><a href="#__codelineno-228-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-228-1" name="__codelineno-228-1"></a>char v1, v2; //一条边的顶点
<a id="__codelineno-228-2" name="__codelineno-228-2"></a>int index_v1, index_v2; //边的顶点的下标
<a id="__codelineno-228-3" name="__codelineno-228-3"></a>int weight;
<a id="__codelineno-228-4" name="__codelineno-228-4"></a>for (int i = 0 ; i &lt; G-&gt;edges; ++i) {
<a id="__codelineno-228-5" name="__codelineno-228-5"></a>printf(&quot;(for %d)Please input the edge(just like A B):&quot;, i + 1 );
<a id="__codelineno-228-6" name="__codelineno-228-6"></a>scanf(&quot; %c %c %d&quot;, &amp;v1, &amp;v2, &amp;weight); //相比无向无权图只多了一个weight
<a id="__codelineno-228-7" name="__codelineno-228-7"></a>index_v1 = Locate_vertex(G, v1);
<a id="__codelineno-228-8" name="__codelineno-228-8"></a>index_v2 = Locate_vertex(G, v2);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-229-1">1</a></span>
<span class="normal"><a href="#__codelineno-229-2">2</a></span>
<span class="normal"><a href="#__codelineno-229-3">3</a></span>
<span class="normal"><a href="#__codelineno-229-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-229-1" name="__codelineno-229-1"></a>G-&gt;edge[index_v1][index_v2] = weight;
<a id="__codelineno-229-2" name="__codelineno-229-2"></a>G-&gt;edge[index_v2][index_v1] = weight;
<a id="__codelineno-229-3" name="__codelineno-229-3"></a>}
<a id="__codelineno-229-4" name="__codelineno-229-4"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-230-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-230-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-230-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-230-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-230-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-230-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-230-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-230-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-230-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-230-10">10</a></span>
<span class="normal"><a href="#__codelineno-230-11">11</a></span>
<span class="normal"><a href="#__codelineno-230-12">12</a></span>
<span class="normal"><a href="#__codelineno-230-13">13</a></span>
<span class="normal"><a href="#__codelineno-230-14">14</a></span>
<span class="normal"><a href="#__codelineno-230-15">15</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-230-1" name="__codelineno-230-1"></a>void Creat_AMGraph_weightd(AMGraph *G) {
<a id="__codelineno-230-2" name="__codelineno-230-2"></a>//初始化点和边个数
<a id="__codelineno-230-3" name="__codelineno-230-3"></a>printf(&quot;Please input the number of vertices:&quot;);
<a id="__codelineno-230-4" name="__codelineno-230-4"></a>scanf(&quot; %d&quot;, &amp;G-&gt;vertices);
<a id="__codelineno-230-5" name="__codelineno-230-5"></a>printf(&quot;Please input the number of edges:&quot;);
<a id="__codelineno-230-6" name="__codelineno-230-6"></a>scanf(&quot; %d&quot;, &amp;G-&gt;edges);
<a id="__codelineno-230-7" name="__codelineno-230-7"></a>//输入各个顶点的名字
<a id="__codelineno-230-8" name="__codelineno-230-8"></a>printf(&quot;Please input the name of vertices(just like A B C):&quot;);
<a id="__codelineno-230-9" name="__codelineno-230-9"></a>for (int i = 0 ; i &lt; G-&gt;vertices; ++i) {
<a id="__codelineno-230-10" name="__codelineno-230-10"></a>scanf(&quot; %c&quot;, &amp;G-&gt;vertex[i]);
<a id="__codelineno-230-11" name="__codelineno-230-11"></a>}
<a id="__codelineno-230-12" name="__codelineno-230-12"></a>//把矩阵初始化
<a id="__codelineno-230-13" name="__codelineno-230-13"></a>for (int i = 0 ; i &lt; G-&gt;vertices; ++i)
<a id="__codelineno-230-14" name="__codelineno-230-14"></a>for (int j = 0 ; j &lt; G-&gt;vertices; ++j)
<a id="__codelineno-230-15" name="__codelineno-230-15"></a>G-&gt;edge[i][j] = MAXWEIGHT;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-231-1">1</a></span>
<span class="normal"><a href="#__codelineno-231-2">2</a></span>
<span class="normal"><a href="#__codelineno-231-3">3</a></span>
<span class="normal"><a href="#__codelineno-231-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-231-1" name="__codelineno-231-1"></a>char v1, v2; //一条边的顶点
<a id="__codelineno-231-2" name="__codelineno-231-2"></a>int index_v1, index_v2; //边的顶点的下标
<a id="__codelineno-231-3" name="__codelineno-231-3"></a>int weight;
<a id="__codelineno-231-4" name="__codelineno-231-4"></a>for (int i = 0 ; i &lt; G-&gt;edges; ++i) {
</code></pre></div></td></tr></table></div></p>
<h6 id="_564">有向无权图<a class="headerlink" href="#_564" title="Permanent link">&para;</a></h6>
<h4 id="adjacency-list_1">邻接表(Adjacency List)<a class="headerlink" href="#adjacency-list_1" title="Permanent link">&para;</a></h4>
<h6 id="_565">数据类型定义<a class="headerlink" href="#_565" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-232-1">1</a></span>
<span class="normal"><a href="#__codelineno-232-2">2</a></span>
<span class="normal"><a href="#__codelineno-232-3">3</a></span>
<span class="normal"><a href="#__codelineno-232-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-232-1" name="__codelineno-232-1"></a>printf(&quot;(for %d)Please input the edge(just like A B):&quot;, i + 1 );
<a id="__codelineno-232-2" name="__codelineno-232-2"></a>scanf(&quot; %c %c %d&quot;, &amp;v1, &amp;v2, &amp;weight);
<a id="__codelineno-232-3" name="__codelineno-232-3"></a>index_v1 = Locate_vertex(G, v1);
<a id="__codelineno-232-4" name="__codelineno-232-4"></a>index_v2 = Locate_vertex(G, v2);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-233-1">1</a></span>
<span class="normal"><a href="#__codelineno-233-2">2</a></span>
<span class="normal"><a href="#__codelineno-233-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-233-1" name="__codelineno-233-1"></a>G-&gt;edge[index_v1][index_v2] = weight;
<a id="__codelineno-233-2" name="__codelineno-233-2"></a>}
<a id="__codelineno-233-3" name="__codelineno-233-3"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-234-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-234-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-234-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-234-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-234-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-234-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-234-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-234-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-234-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-234-10">10</a></span>
<span class="normal"><a href="#__codelineno-234-11">11</a></span>
<span class="normal"><a href="#__codelineno-234-12">12</a></span>
<span class="normal"><a href="#__codelineno-234-13">13</a></span>
<span class="normal"><a href="#__codelineno-234-14">14</a></span>
<span class="normal"><a href="#__codelineno-234-15">15</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-234-1" name="__codelineno-234-1"></a>void Creat_AMGraph_unweightd(AMGraph *G) {
<a id="__codelineno-234-2" name="__codelineno-234-2"></a>//初始化点和边个数
<a id="__codelineno-234-3" name="__codelineno-234-3"></a>printf(&quot;Please input the number of vertices:&quot;);
<a id="__codelineno-234-4" name="__codelineno-234-4"></a>scanf(&quot; %d&quot;, &amp;G-&gt;vertices);
<a id="__codelineno-234-5" name="__codelineno-234-5"></a>printf(&quot;Please input the number of edges:&quot;);
<a id="__codelineno-234-6" name="__codelineno-234-6"></a>scanf(&quot; %d&quot;, &amp;G-&gt;edges);
<a id="__codelineno-234-7" name="__codelineno-234-7"></a>//输入各个顶点的名字
<a id="__codelineno-234-8" name="__codelineno-234-8"></a>printf(&quot;Please input the name of vertices(just like A B C):&quot;);
<a id="__codelineno-234-9" name="__codelineno-234-9"></a>for (int i = 0 ; i &lt; G-&gt;vertices; ++i) {
<a id="__codelineno-234-10" name="__codelineno-234-10"></a>scanf(&quot; %c&quot;, &amp;G-&gt;vertex[i]);
<a id="__codelineno-234-11" name="__codelineno-234-11"></a>}
<a id="__codelineno-234-12" name="__codelineno-234-12"></a>//把矩阵初始化
<a id="__codelineno-234-13" name="__codelineno-234-13"></a>for (int i = 0 ; i &lt; G-&gt;vertices; ++i)
<a id="__codelineno-234-14" name="__codelineno-234-14"></a>for (int j = 0 ; j &lt; G-&gt;vertices; ++j)
<a id="__codelineno-234-15" name="__codelineno-234-15"></a>G-&gt;edge[i][j] = 0 ;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-235-1">1</a></span>
<span class="normal"><a href="#__codelineno-235-2">2</a></span>
<span class="normal"><a href="#__codelineno-235-3">3</a></span>
<span class="normal"><a href="#__codelineno-235-4">4</a></span>
<span class="normal"><a href="#__codelineno-235-5">5</a></span>
<span class="normal"><a href="#__codelineno-235-6">6</a></span>
<span class="normal"><a href="#__codelineno-235-7">7</a></span>
<span class="normal"><a href="#__codelineno-235-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-235-1" name="__codelineno-235-1"></a>char v1, v2; //一条边的顶点
<a id="__codelineno-235-2" name="__codelineno-235-2"></a>int index_v1, index_v2; //边的顶点的下标
<a id="__codelineno-235-3" name="__codelineno-235-3"></a>int weight;
<a id="__codelineno-235-4" name="__codelineno-235-4"></a>for (int i = 0 ; i &lt; G-&gt;edges; ++i) {
<a id="__codelineno-235-5" name="__codelineno-235-5"></a>printf(&quot;(for %d)Please input the edge(just like A B):&quot;, i + 1 );
<a id="__codelineno-235-6" name="__codelineno-235-6"></a>scanf(&quot; %c %c %d&quot;, &amp;v1, &amp;v2, &amp;weight);
<a id="__codelineno-235-7" name="__codelineno-235-7"></a>index_v1 = Locate_vertex(G, v1);
<a id="__codelineno-235-8" name="__codelineno-235-8"></a>index_v2 = Locate_vertex(G, v2);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-236-1">1</a></span>
<span class="normal"><a href="#__codelineno-236-2">2</a></span>
<span class="normal"><a href="#__codelineno-236-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-236-1" name="__codelineno-236-1"></a>G-&gt;edge[index_v1][index_v2] = 1 ; //有向图不是对称矩阵
<a id="__codelineno-236-2" name="__codelineno-236-2"></a>}
<a id="__codelineno-236-3" name="__codelineno-236-3"></a>}
</code></pre></div></td></tr></table></div></p>
<h6 id="_566">代码实现<a class="headerlink" href="#_566" title="Permanent link">&para;</a></h6>
<h6 id="_567">无向无权图<a class="headerlink" href="#_567" title="Permanent link">&para;</a></h6>
<h6 id="weight">无向有权，有向无权，有向有权图的创建方法和此方法类似，只需改动weight,和新建节点个数即可<a class="headerlink" href="#weight" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-237-1">1</a></span>
<span class="normal"><a href="#__codelineno-237-2">2</a></span>
<span class="normal"><a href="#__codelineno-237-3">3</a></span>
<span class="normal"><a href="#__codelineno-237-4">4</a></span>
<span class="normal"><a href="#__codelineno-237-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-237-1" name="__codelineno-237-1"></a>typedef struct __EdgeNode {
<a id="__codelineno-237-2" name="__codelineno-237-2"></a>int adjvertex;
<a id="__codelineno-237-3" name="__codelineno-237-3"></a>__EdgeNode *next;
<a id="__codelineno-237-4" name="__codelineno-237-4"></a>int weight;
<a id="__codelineno-237-5" name="__codelineno-237-5"></a>} EdgeNode;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-238-1">1</a></span>
<span class="normal"><a href="#__codelineno-238-2">2</a></span>
<span class="normal"><a href="#__codelineno-238-3">3</a></span>
<span class="normal"><a href="#__codelineno-238-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-238-1" name="__codelineno-238-1"></a>typedef struct __ALGNode {
<a id="__codelineno-238-2" name="__codelineno-238-2"></a>VertexType name;
<a id="__codelineno-238-3" name="__codelineno-238-3"></a>EdgeNode *first;
<a id="__codelineno-238-4" name="__codelineno-238-4"></a>} ALGNode;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-239-1">1</a></span>
<span class="normal"><a href="#__codelineno-239-2">2</a></span>
<span class="normal"><a href="#__codelineno-239-3">3</a></span>
<span class="normal"><a href="#__codelineno-239-4">4</a></span>
<span class="normal"><a href="#__codelineno-239-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-239-1" name="__codelineno-239-1"></a>typedef struct __ALGraph {
<a id="__codelineno-239-2" name="__codelineno-239-2"></a>ALGNode vertex[MAXVERTEX];
<a id="__codelineno-239-3" name="__codelineno-239-3"></a>int edges, vertices;
<a id="__codelineno-239-4" name="__codelineno-239-4"></a>} ALGraph;
<a id="__codelineno-239-5" name="__codelineno-239-5"></a>//如下图
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-240-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-240-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-240-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-240-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-240-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-240-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-240-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-240-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-240-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-240-10">10</a></span>
<span class="normal"><a href="#__codelineno-240-11">11</a></span>
<span class="normal"><a href="#__codelineno-240-12">12</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-240-1" name="__codelineno-240-1"></a>void Creat_unALGraph_unweighted(ALGraph *G) {
<a id="__codelineno-240-2" name="__codelineno-240-2"></a>//初始化点和边个数
<a id="__codelineno-240-3" name="__codelineno-240-3"></a>printf(&quot;Please input the number of vertices:&quot;);
<a id="__codelineno-240-4" name="__codelineno-240-4"></a>scanf(&quot; %d&quot;, &amp;G-&gt;vertices);
<a id="__codelineno-240-5" name="__codelineno-240-5"></a>printf(&quot;Please input the number of edges:&quot;);
<a id="__codelineno-240-6" name="__codelineno-240-6"></a>scanf(&quot; %d&quot;, &amp;G-&gt;edges);
<a id="__codelineno-240-7" name="__codelineno-240-7"></a>//输入各个顶点的名字
<a id="__codelineno-240-8" name="__codelineno-240-8"></a>printf(&quot;Please input the name of vertices(just like A B C):&quot;);
<a id="__codelineno-240-9" name="__codelineno-240-9"></a>for (int i = 0 ; i &lt; G-&gt;vertices; ++i) {
<a id="__codelineno-240-10" name="__codelineno-240-10"></a>scanf(&quot; %c&quot;, &amp;G-&gt;vertex[i].name);
<a id="__codelineno-240-11" name="__codelineno-240-11"></a>G-&gt;vertex[i].first = NULL;
<a id="__codelineno-240-12" name="__codelineno-240-12"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-241-1">1</a></span>
<span class="normal"><a href="#__codelineno-241-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-241-1" name="__codelineno-241-1"></a>char v1, v2; //一条边的顶点
<a id="__codelineno-241-2" name="__codelineno-241-2"></a>int index_v1, index_v2; //边的顶点的下标
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-242-1">1</a></span>
<span class="normal"><a href="#__codelineno-242-2">2</a></span>
<span class="normal"><a href="#__codelineno-242-3">3</a></span>
<span class="normal"><a href="#__codelineno-242-4">4</a></span>
<span class="normal"><a href="#__codelineno-242-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-242-1" name="__codelineno-242-1"></a>for (int i = 0 ; i &lt; G-&gt;edges; ++i) {
<a id="__codelineno-242-2" name="__codelineno-242-2"></a>printf(&quot;(for %d)Please input the edge(just like A B):&quot;, i + 1 );
<a id="__codelineno-242-3" name="__codelineno-242-3"></a>scanf(&quot; %c %c&quot;, &amp;v1, &amp;v2);
<a id="__codelineno-242-4" name="__codelineno-242-4"></a>index_v1 = Locate_vertex(G, v1);
<a id="__codelineno-242-5" name="__codelineno-242-5"></a>index_v2 = Locate_vertex(G, v2);
</code></pre></div></td></tr></table></div></p>
<h6 id="_568">测试代码<a class="headerlink" href="#_568" title="Permanent link">&para;</a></h6>
<h4 id="_569">邻接表和邻接矩阵的比较<a class="headerlink" href="#_569" title="Permanent link">&para;</a></h4>
<h6 id="_570">邻接矩阵<a class="headerlink" href="#_570" title="Permanent link">&para;</a></h6>
<h6 id="_571">优点<a class="headerlink" href="#_571" title="Permanent link">&para;</a></h6>
<h6 id="_572">便于判断顶点间是否有边<a class="headerlink" href="#_572" title="Permanent link">&para;</a></h6>
<h6 id="_573">便于计算各个顶点的度<a class="headerlink" href="#_573" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-243-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-243-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-243-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-243-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-243-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-243-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-243-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-243-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-243-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-243-10">10</a></span>
<span class="normal"><a href="#__codelineno-243-11">11</a></span>
<span class="normal"><a href="#__codelineno-243-12">12</a></span>
<span class="normal"><a href="#__codelineno-243-13">13</a></span>
<span class="normal"><a href="#__codelineno-243-14">14</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-243-1" name="__codelineno-243-1"></a>//创造新节点 1
<a id="__codelineno-243-2" name="__codelineno-243-2"></a>EdgeNode *pnew1 = (EdgeNode *)malloc(sizeof(EdgeNode));
<a id="__codelineno-243-3" name="__codelineno-243-3"></a>pnew1-&gt;adjvertex = index_v2;
<a id="__codelineno-243-4" name="__codelineno-243-4"></a>//头插法
<a id="__codelineno-243-5" name="__codelineno-243-5"></a>pnew1-&gt;next = G-&gt;vertex[index_v1].first;
<a id="__codelineno-243-6" name="__codelineno-243-6"></a>G-&gt;vertex[index_v1].first = pnew1;
<a id="__codelineno-243-7" name="__codelineno-243-7"></a>//创造新节点 2
<a id="__codelineno-243-8" name="__codelineno-243-8"></a>EdgeNode *pnew2 = (EdgeNode *)malloc(sizeof(EdgeNode));
<a id="__codelineno-243-9" name="__codelineno-243-9"></a>pnew2-&gt;adjvertex = index_v1;
<a id="__codelineno-243-10" name="__codelineno-243-10"></a>//头插法
<a id="__codelineno-243-11" name="__codelineno-243-11"></a>pnew2-&gt;next = G-&gt;vertex[index_v2].first;
<a id="__codelineno-243-12" name="__codelineno-243-12"></a>G-&gt;vertex[index_v2].first = pnew2;
<a id="__codelineno-243-13" name="__codelineno-243-13"></a>}
<a id="__codelineno-243-14" name="__codelineno-243-14"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-244-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-244-1" name="__codelineno-244-1"></a>#include &quot;ALGraph.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-245-1">1</a></span>
<span class="normal"><a href="#__codelineno-245-2">2</a></span>
<span class="normal"><a href="#__codelineno-245-3">3</a></span>
<span class="normal"><a href="#__codelineno-245-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-245-1" name="__codelineno-245-1"></a>int main(void) {
<a id="__codelineno-245-2" name="__codelineno-245-2"></a>ALGraph G;
<a id="__codelineno-245-3" name="__codelineno-245-3"></a>Creat_unALGraph_unweighted(&amp;G);
<a id="__codelineno-245-4" name="__codelineno-245-4"></a>print_ALG_unweighted(&amp;G);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-246-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-246-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-246-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-246-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-246-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-246-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-246-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-246-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-246-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-246-10">10</a></span>
<span class="normal"><a href="#__codelineno-246-11">11</a></span>
<span class="normal"><a href="#__codelineno-246-12">12</a></span>
<span class="normal"><a href="#__codelineno-246-13">13</a></span>
<span class="normal"><a href="#__codelineno-246-14">14</a></span>
<span class="normal"><a href="#__codelineno-246-15">15</a></span>
<span class="normal"><a href="#__codelineno-246-16">16</a></span>
<span class="normal"><a href="#__codelineno-246-17">17</a></span>
<span class="normal"><a href="#__codelineno-246-18">18</a></span>
<span class="normal"><a href="#__codelineno-246-19">19</a></span>
<span class="normal"><a href="#__codelineno-246-20">20</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-246-1" name="__codelineno-246-1"></a>system(&quot;pause&quot;);
<a id="__codelineno-246-2" name="__codelineno-246-2"></a>return 0 ;
<a id="__codelineno-246-3" name="__codelineno-246-3"></a>}
<a id="__codelineno-246-4" name="__codelineno-246-4"></a>//
<a id="__codelineno-246-5" name="__codelineno-246-5"></a>/*
<a id="__codelineno-246-6" name="__codelineno-246-6"></a>5 6
<a id="__codelineno-246-7" name="__codelineno-246-7"></a>A B C D E
<a id="__codelineno-246-8" name="__codelineno-246-8"></a>A B
<a id="__codelineno-246-9" name="__codelineno-246-9"></a>A D
<a id="__codelineno-246-10" name="__codelineno-246-10"></a>B C
<a id="__codelineno-246-11" name="__codelineno-246-11"></a>D C
<a id="__codelineno-246-12" name="__codelineno-246-12"></a>C E
<a id="__codelineno-246-13" name="__codelineno-246-13"></a>B E
<a id="__codelineno-246-14" name="__codelineno-246-14"></a>----------------------
<a id="__codelineno-246-15" name="__codelineno-246-15"></a>A:A--D A--B
<a id="__codelineno-246-16" name="__codelineno-246-16"></a>B:B--E B--C B--A
<a id="__codelineno-246-17" name="__codelineno-246-17"></a>C:C--E C--D C--B
<a id="__codelineno-246-18" name="__codelineno-246-18"></a>D:D--C D--A
<a id="__codelineno-246-19" name="__codelineno-246-19"></a>E:E--B E--C
<a id="__codelineno-246-20" name="__codelineno-246-20"></a>*/
</code></pre></div></td></tr></table></div></p>
<h6 id="_574">缺点<a class="headerlink" href="#_574" title="Permanent link">&para;</a></h6>
<h6 id="_575">不便于插入和删除顶点<a class="headerlink" href="#_575" title="Permanent link">&para;</a></h6>
<h6 id="_576">不便于统计边数，需要扫描矩阵才能计算.<a class="headerlink" href="#_576" title="Permanent link">&para;</a></h6>
<h6 id="_577">空间复杂度较高，但如果 较大时，可以采用上三角或下三角矩阵(因为矩阵是对称的)<a class="headerlink" href="#_577" title="Permanent link">&para;</a></h6>
<h6 id="_578">邻接表<a class="headerlink" href="#_578" title="Permanent link">&para;</a></h6>
<h6 id="_579">优点<a class="headerlink" href="#_579" title="Permanent link">&para;</a></h6>
<h6 id="_580">便于增加和删除顶点<a class="headerlink" href="#_580" title="Permanent link">&para;</a></h6>
<h6 id="_581">便于统计边的数量，按顶点顺序扫描所有边即可。<a class="headerlink" href="#_581" title="Permanent link">&para;</a></h6>
<h6 id="_582">空间效率高，无向图 ，有向图<a class="headerlink" href="#_582" title="Permanent link">&para;</a></h6>
<h6 id="_583">缺点<a class="headerlink" href="#_583" title="Permanent link">&para;</a></h6>
<h6 id="_584">不便于判断两顶点间是否有边(相对于矩阵的随机取值而言)<a class="headerlink" href="#_584" title="Permanent link">&para;</a></h6>
<h6 id="_585">不便于计算各个顶点的度。<a class="headerlink" href="#_585" title="Permanent link">&para;</a></h6>
<h6 id="_586">对于无向图， 第个表的节点个数<a class="headerlink" href="#_586" title="Permanent link">&para;</a></h6>
<h6 id="_587">对无向图<a class="headerlink" href="#_587" title="Permanent link">&para;</a></h6>
<h6 id="_588">)<a class="headerlink" href="#_588" title="Permanent link">&para;</a></h6>
<h5 id="_589">，入度为第个表的节点个数，但是出度却要历遍所有的表<a class="headerlink" href="#_589" title="Permanent link">&para;</a></h5>
<h4 id="_590">十字链表<a class="headerlink" href="#_590" title="Permanent link">&para;</a></h4>
<h6 id="degree_2">十字链表可以解决用邻接链表储存的有向图求顶点degree的问题<a class="headerlink" href="#degree_2" title="Permanent link">&para;</a></h6>
<h6 id="_591">根据上图可知，一条边即是一个顶点的入度，也是另外一个顶点的出度<a class="headerlink" href="#_591" title="Permanent link">&para;</a></h6>
<h6 id="_592">设是 的一条边<a class="headerlink" href="#_592" title="Permanent link">&para;</a></h6>
<h6 id="_593">当建立边节点 时，使 的 域指向，使 的 指向<a class="headerlink" href="#_593" title="Permanent link">&para;</a></h6>
<h6 id="_594">当 再次有出度边 时，使 的 域指向 的 所指节点 指向<a class="headerlink" href="#_594" title="Permanent link">&para;</a></h6>
<h6 id="_595">当 再次有入度边 时，使 的 域指向 的 所指节点 指向<a class="headerlink" href="#_595" title="Permanent link">&para;</a></h6>
<h4 id="_596">邻接多重链表<a class="headerlink" href="#_596" title="Permanent link">&para;</a></h4>
<h6 id="_597">用于 解决 用 邻接表 存储的 无向图 每条边都要存储 两遍 的问题<a class="headerlink" href="#_597" title="Permanent link">&para;</a></h6>
<h6 id="_598">如上图<a class="headerlink" href="#_598" title="Permanent link">&para;</a></h6>
<h6 id="_599">记录该边是否被搜索过<a class="headerlink" href="#_599" title="Permanent link">&para;</a></h6>
<h6 id="_600">分别表示边 顶点的下标<a class="headerlink" href="#_600" title="Permanent link">&para;</a></h6>
<h6 id="_601">分别表示 的下条边节点， 的下条边节点<a class="headerlink" href="#_601" title="Permanent link">&para;</a></h6>
<h6 id="_602">令<a class="headerlink" href="#_602" title="Permanent link">&para;</a></h6>
<h6 id="_603">使 的 指向 的 域， 的 指向 的 域<a class="headerlink" href="#_603" title="Permanent link">&para;</a></h6>
<h6 id="_604">的 的下标， 的 的下标<a class="headerlink" href="#_604" title="Permanent link">&para;</a></h6>
<h6 id="_605">使 和 的 指向<a class="headerlink" href="#_605" title="Permanent link">&para;</a></h6>
<h6 id="_606">遍历<a class="headerlink" href="#_606" title="Permanent link">&para;</a></h6>
<h6 id="_607">令 的 为<a class="headerlink" href="#_607" title="Permanent link">&para;</a></h6>
<h6 id="_608">打印<a class="headerlink" href="#_608" title="Permanent link">&para;</a></h6>
<h3 id="_609">图的遍历<a class="headerlink" href="#_609" title="Permanent link">&para;</a></h3>
<h6 id="_610">图中可能存在 ，且图的任何一点都有可能和其他顶点相连<a class="headerlink" href="#_610" title="Permanent link">&para;</a></h6>
<h6 id="_611">在访问完某个顶点之后，可能会沿着某些边又回到了曾经访问过的顶点<a class="headerlink" href="#_611" title="Permanent link">&para;</a></h6>
<h6 id="_612">解决思路<a class="headerlink" href="#_612" title="Permanent link">&para;</a></h6>
<h6 id="_613">设置辅助数组 ，用来标记顶点是否被访问过<a class="headerlink" href="#_613" title="Permanent link">&para;</a></h6>
<h6 id="_614">顶点未被访问过<a class="headerlink" href="#_614" title="Permanent link">&para;</a></h6>
<h6 id="_615">顶点被访问过<a class="headerlink" href="#_615" title="Permanent link">&para;</a></h6>
<h4 id="depth-first-search_1">深度优先 (Depth First Search)<a class="headerlink" href="#depth-first-search_1" title="Permanent link">&para;</a></h4>
<h6 id="_616">算法描述<a class="headerlink" href="#_616" title="Permanent link">&para;</a></h6>
<h6 id="_617">先访问 ，再访问 的邻接点<a class="headerlink" href="#_617" title="Permanent link">&para;</a></h6>
<h6 id="_618">再访问 的邻接点<a class="headerlink" href="#_618" title="Permanent link">&para;</a></h6>
<h6 id="_619">开始出栈，控制节点再次来到<a class="headerlink" href="#_619" title="Permanent link">&para;</a></h6>
<h6 id="_620">因为 已经被访问过，所以开始访问<a class="headerlink" href="#_620" title="Permanent link">&para;</a></h6>
<h6 id="_621">全部出栈完，控制再次回到<a class="headerlink" href="#_621" title="Permanent link">&para;</a></h6>
<h6 id="_622">出栈，结束<a class="headerlink" href="#_622" title="Permanent link">&para;</a></h6>
<h6 id="_623">代码实现下图<a class="headerlink" href="#_623" title="Permanent link">&para;</a></h6>
<h6 id="_624">注意上图中的当访问完 之后，并不是直接回到<a class="headerlink" href="#_624" title="Permanent link">&para;</a></h6>
<h6 id="_625">而是退回到 ，需要依次出栈<a class="headerlink" href="#_625" title="Permanent link">&para;</a></h6>
<h6 id="_626">遍历矩阵<a class="headerlink" href="#_626" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-247-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-247-1" name="__codelineno-247-1"></a>void DFS_AM(AMGraph *G, int v, bool *visit) {
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-248-1">1</a></span>
<span class="normal"><a href="#__codelineno-248-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-248-1" name="__codelineno-248-1"></a>printf(&quot;%c &quot;, G-&gt;vertex[v]); //先遍历顶点
<a id="__codelineno-248-2" name="__codelineno-248-2"></a>visit[v] = true; //访问标记
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-249-1">1</a></span>
<span class="normal"><a href="#__codelineno-249-2">2</a></span>
<span class="normal"><a href="#__codelineno-249-3">3</a></span>
<span class="normal"><a href="#__codelineno-249-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-249-1" name="__codelineno-249-1"></a>for (int k = 0 ; k &lt; G-&gt;vertices; ++k) {
<a id="__codelineno-249-2" name="__codelineno-249-2"></a>if (G-&gt;edge[v][k] &amp;&amp; !visit[k]) //如果v，k之间存在边，并且k顶点并未被访问过
<a id="__codelineno-249-3" name="__codelineno-249-3"></a>DFS_AM(G, k, visit);
<a id="__codelineno-249-4" name="__codelineno-249-4"></a>}
</code></pre></div></td></tr></table></div></p>
<h6 id="_627">测试代码<a class="headerlink" href="#_627" title="Permanent link">&para;</a></h6>
<h6 id="_628">遍历邻接表<a class="headerlink" href="#_628" title="Permanent link">&para;</a></h6>
<h6 id="_629">注意:使用邻接表时，遍历的顺序和邻接矩阵不一样，因为创建邻接表使用头插法(如果使用尾插法顺序<a class="headerlink" href="#_629" title="Permanent link">&para;</a></h6>
<h6 id="_630">则一样)<a class="headerlink" href="#_630" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-250-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-250-1" name="__codelineno-250-1"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-251-1">1</a></span>
<span class="normal"><a href="#__codelineno-251-2">2</a></span>
<span class="normal"><a href="#__codelineno-251-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-251-1" name="__codelineno-251-1"></a>void DFS_AMGraph(AMGraph *G, VertexType v) { //封装函数
<a id="__codelineno-251-2" name="__codelineno-251-2"></a>bool *visit = (bool *)malloc(sizeof(bool) * G-&gt;vertices); //为visit分配空间
<a id="__codelineno-251-3" name="__codelineno-251-3"></a>memset(visit, false, sizeof(bool) * G-&gt;vertices); //初始化为false
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-252-1">1</a></span>
<span class="normal"><a href="#__codelineno-252-2">2</a></span>
<span class="normal"><a href="#__codelineno-252-3">3</a></span>
<span class="normal"><a href="#__codelineno-252-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-252-1" name="__codelineno-252-1"></a>int index = Locate_vertex(G, v); //找到下标
<a id="__codelineno-252-2" name="__codelineno-252-2"></a>DFS_AM(G, index, visit); //以此下标为顶点出发，遍历
<a id="__codelineno-252-3" name="__codelineno-252-3"></a>free(visit);
<a id="__codelineno-252-4" name="__codelineno-252-4"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-253-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-253-1" name="__codelineno-253-1"></a>#include &quot;AMGraph.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-254-1">1</a></span>
<span class="normal"><a href="#__codelineno-254-2">2</a></span>
<span class="normal"><a href="#__codelineno-254-3">3</a></span>
<span class="normal"><a href="#__codelineno-254-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-254-1" name="__codelineno-254-1"></a>int main(void) {
<a id="__codelineno-254-2" name="__codelineno-254-2"></a>AMGraph G;
<a id="__codelineno-254-3" name="__codelineno-254-3"></a>Creat_unAMGraph_unweightd(&amp;G);
<a id="__codelineno-254-4" name="__codelineno-254-4"></a>DFS_AMGraph(&amp;G, &#39;A&#39;);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-255-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-255-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-255-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-255-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-255-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-255-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-255-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-255-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-255-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-255-10">10</a></span>
<span class="normal"><a href="#__codelineno-255-11">11</a></span>
<span class="normal"><a href="#__codelineno-255-12">12</a></span>
<span class="normal"><a href="#__codelineno-255-13">13</a></span>
<span class="normal"><a href="#__codelineno-255-14">14</a></span>
<span class="normal"><a href="#__codelineno-255-15">15</a></span>
<span class="normal"><a href="#__codelineno-255-16">16</a></span>
<span class="normal"><a href="#__codelineno-255-17">17</a></span>
<span class="normal"><a href="#__codelineno-255-18">18</a></span>
<span class="normal"><a href="#__codelineno-255-19">19</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-255-1" name="__codelineno-255-1"></a>system(&quot;pause&quot;);
<a id="__codelineno-255-2" name="__codelineno-255-2"></a>return 0 ;
<a id="__codelineno-255-3" name="__codelineno-255-3"></a>}
<a id="__codelineno-255-4" name="__codelineno-255-4"></a>//
<a id="__codelineno-255-5" name="__codelineno-255-5"></a>/*
<a id="__codelineno-255-6" name="__codelineno-255-6"></a>8 9
<a id="__codelineno-255-7" name="__codelineno-255-7"></a>A B C D E F G H
<a id="__codelineno-255-8" name="__codelineno-255-8"></a>A B
<a id="__codelineno-255-9" name="__codelineno-255-9"></a>A C
<a id="__codelineno-255-10" name="__codelineno-255-10"></a>B D
<a id="__codelineno-255-11" name="__codelineno-255-11"></a>D H
<a id="__codelineno-255-12" name="__codelineno-255-12"></a>B E
<a id="__codelineno-255-13" name="__codelineno-255-13"></a>E H
<a id="__codelineno-255-14" name="__codelineno-255-14"></a>C F
<a id="__codelineno-255-15" name="__codelineno-255-15"></a>C G
<a id="__codelineno-255-16" name="__codelineno-255-16"></a>F G
<a id="__codelineno-255-17" name="__codelineno-255-17"></a>----------------------
<a id="__codelineno-255-18" name="__codelineno-255-18"></a>A B D H E C F G
<a id="__codelineno-255-19" name="__codelineno-255-19"></a>*/
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-256-1">1</a></span>
<span class="normal"><a href="#__codelineno-256-2">2</a></span>
<span class="normal"><a href="#__codelineno-256-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-256-1" name="__codelineno-256-1"></a>void DFS_AL(ALGraph *G, int v, bool *visit) {
<a id="__codelineno-256-2" name="__codelineno-256-2"></a>printf(&quot;%c &quot;, G-&gt;vertex[v].name);
<a id="__codelineno-256-3" name="__codelineno-256-3"></a>visit[v] = true;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-257-1">1</a></span>
<span class="normal"><a href="#__codelineno-257-2">2</a></span>
<span class="normal"><a href="#__codelineno-257-3">3</a></span>
<span class="normal"><a href="#__codelineno-257-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-257-1" name="__codelineno-257-1"></a>EdgeNode *p = G-&gt;vertex[v].first;
<a id="__codelineno-257-2" name="__codelineno-257-2"></a>while (p) {
<a id="__codelineno-257-3" name="__codelineno-257-3"></a>int adj = p-&gt;adjvertex;
<a id="__codelineno-257-4" name="__codelineno-257-4"></a>if (!visit[adj]) // 只需判断visit数组，因为当p不为空时，adjvertex必然存在
</code></pre></div></td></tr></table></div></p>
<h6 id="_631">测试代码<a class="headerlink" href="#_631" title="Permanent link">&para;</a></h6>
<h4 id="breadth-first-search_1">广度优先 (Breadth First Search)<a class="headerlink" href="#breadth-first-search_1" title="Permanent link">&para;</a></h4>
<h6 id="_632">从图的 出发，首先访问 ，然后访问 的所有邻接点<a class="headerlink" href="#_632" title="Permanent link">&para;</a></h6>
<h6 id="_633">然后按照 的顺序，依次访问他们的邻接点<a class="headerlink" href="#_633" title="Permanent link">&para;</a></h6>
<h6 id="_634">实现遍历下图<a class="headerlink" href="#_634" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-258-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-258-1" name="__codelineno-258-1"></a>DFS_AL(G, adj, visit);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-259-1">1</a></span>
<span class="normal"><a href="#__codelineno-259-2">2</a></span>
<span class="normal"><a href="#__codelineno-259-3">3</a></span>
<span class="normal"><a href="#__codelineno-259-4">4</a></span>
<span class="normal"><a href="#__codelineno-259-5">5</a></span>
<span class="normal"><a href="#__codelineno-259-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-259-1" name="__codelineno-259-1"></a>p = p-&gt;next;
<a id="__codelineno-259-2" name="__codelineno-259-2"></a>}
<a id="__codelineno-259-3" name="__codelineno-259-3"></a>}
<a id="__codelineno-259-4" name="__codelineno-259-4"></a>void DFS_ALGraph(ALGraph *G, VertexType v) { //封装代码
<a id="__codelineno-259-5" name="__codelineno-259-5"></a>bool *visit = (bool *)malloc(sizeof(bool) * G-&gt;vertices);
<a id="__codelineno-259-6" name="__codelineno-259-6"></a>memset(visit, false, sizeof(bool) * G-&gt;vertices);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-260-1">1</a></span>
<span class="normal"><a href="#__codelineno-260-2">2</a></span>
<span class="normal"><a href="#__codelineno-260-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-260-1" name="__codelineno-260-1"></a>int index = Locate_vertex(G, v);
<a id="__codelineno-260-2" name="__codelineno-260-2"></a>DFS_AL(G, index, visit);
<a id="__codelineno-260-3" name="__codelineno-260-3"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-261-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-261-1" name="__codelineno-261-1"></a>#include &quot;ALGraph.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-262-1">1</a></span>
<span class="normal"><a href="#__codelineno-262-2">2</a></span>
<span class="normal"><a href="#__codelineno-262-3">3</a></span>
<span class="normal"><a href="#__codelineno-262-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-262-1" name="__codelineno-262-1"></a>int main(void) {
<a id="__codelineno-262-2" name="__codelineno-262-2"></a>ALGraph G;
<a id="__codelineno-262-3" name="__codelineno-262-3"></a>Creat_unALGraph_unweighted(&amp;G);
<a id="__codelineno-262-4" name="__codelineno-262-4"></a>DFS_ALGraph(&amp;G, &#39;A&#39;);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-263-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-263-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-263-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-263-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-263-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-263-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-263-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-263-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-263-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-263-10">10</a></span>
<span class="normal"><a href="#__codelineno-263-11">11</a></span>
<span class="normal"><a href="#__codelineno-263-12">12</a></span>
<span class="normal"><a href="#__codelineno-263-13">13</a></span>
<span class="normal"><a href="#__codelineno-263-14">14</a></span>
<span class="normal"><a href="#__codelineno-263-15">15</a></span>
<span class="normal"><a href="#__codelineno-263-16">16</a></span>
<span class="normal"><a href="#__codelineno-263-17">17</a></span>
<span class="normal"><a href="#__codelineno-263-18">18</a></span>
<span class="normal"><a href="#__codelineno-263-19">19</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-263-1" name="__codelineno-263-1"></a>system(&quot;pause&quot;);
<a id="__codelineno-263-2" name="__codelineno-263-2"></a>return 0 ;
<a id="__codelineno-263-3" name="__codelineno-263-3"></a>}
<a id="__codelineno-263-4" name="__codelineno-263-4"></a>//
<a id="__codelineno-263-5" name="__codelineno-263-5"></a>/*
<a id="__codelineno-263-6" name="__codelineno-263-6"></a>8 9
<a id="__codelineno-263-7" name="__codelineno-263-7"></a>A B C D E F G H
<a id="__codelineno-263-8" name="__codelineno-263-8"></a>A B
<a id="__codelineno-263-9" name="__codelineno-263-9"></a>A C
<a id="__codelineno-263-10" name="__codelineno-263-10"></a>B D
<a id="__codelineno-263-11" name="__codelineno-263-11"></a>D H
<a id="__codelineno-263-12" name="__codelineno-263-12"></a>B E
<a id="__codelineno-263-13" name="__codelineno-263-13"></a>E H
<a id="__codelineno-263-14" name="__codelineno-263-14"></a>C F
<a id="__codelineno-263-15" name="__codelineno-263-15"></a>C G
<a id="__codelineno-263-16" name="__codelineno-263-16"></a>F G
<a id="__codelineno-263-17" name="__codelineno-263-17"></a>----------------------
<a id="__codelineno-263-18" name="__codelineno-263-18"></a>A C G F B E H D
<a id="__codelineno-263-19" name="__codelineno-263-19"></a>*/
</code></pre></div></td></tr></table></div></p>
<h6 id="_635">代码实现<a class="headerlink" href="#_635" title="Permanent link">&para;</a></h6>
<h6 id="_636">遍历矩阵<a class="headerlink" href="#_636" title="Permanent link">&para;</a></h6>
<h6 id="_637">测试代码<a class="headerlink" href="#_637" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-264-1">1</a></span>
<span class="normal"><a href="#__codelineno-264-2">2</a></span>
<span class="normal"><a href="#__codelineno-264-3">3</a></span>
<span class="normal"><a href="#__codelineno-264-4">4</a></span>
<span class="normal"><a href="#__codelineno-264-5">5</a></span>
<span class="normal"><a href="#__codelineno-264-6">6</a></span>
<span class="normal"><a href="#__codelineno-264-7">7</a></span>
<span class="normal"><a href="#__codelineno-264-8">8</a></span>
<span class="normal"><a href="#__codelineno-264-9">9</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-264-1" name="__codelineno-264-1"></a>void BFS_AM(AMGraph *G, int v, bool *visit) {
<a id="__codelineno-264-2" name="__codelineno-264-2"></a>SqQueue Q;
<a id="__codelineno-264-3" name="__codelineno-264-3"></a>InitQueue(&amp;Q);
<a id="__codelineno-264-4" name="__codelineno-264-4"></a>EntryQ(&amp;Q, v); //先让顶点入队
<a id="__codelineno-264-5" name="__codelineno-264-5"></a>visit[v] = true; //入队时设置visit状态
<a id="__codelineno-264-6" name="__codelineno-264-6"></a>int pop; //用于接收队列弹出数据
<a id="__codelineno-264-7" name="__codelineno-264-7"></a>while (!IsEmpty(&amp;Q)) {
<a id="__codelineno-264-8" name="__codelineno-264-8"></a>OutQ(&amp;Q, &amp;pop);
<a id="__codelineno-264-9" name="__codelineno-264-9"></a>printf(&quot;%c &quot;, G-&gt;vertex[pop]); //出队时，打印
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-265-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-265-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-265-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-265-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-265-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-265-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-265-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-265-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-265-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-265-10">10</a></span>
<span class="normal"><a href="#__codelineno-265-11">11</a></span>
<span class="normal"><a href="#__codelineno-265-12">12</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-265-1" name="__codelineno-265-1"></a>for (int k = 0 ; k &lt; G-&gt;vertices; ++k) {
<a id="__codelineno-265-2" name="__codelineno-265-2"></a>if (G-&gt;edge[pop][k] &amp;&amp; !visit[k]) {
<a id="__codelineno-265-3" name="__codelineno-265-3"></a>EntryQ(&amp;Q, k);
<a id="__codelineno-265-4" name="__codelineno-265-4"></a>visit[k] = true;
<a id="__codelineno-265-5" name="__codelineno-265-5"></a>//! 设置visit状态，不可以放在printf后面，因为for循环可能造成重复入队
<a id="__codelineno-265-6" name="__codelineno-265-6"></a>}
<a id="__codelineno-265-7" name="__codelineno-265-7"></a>}
<a id="__codelineno-265-8" name="__codelineno-265-8"></a>}
<a id="__codelineno-265-9" name="__codelineno-265-9"></a>}
<a id="__codelineno-265-10" name="__codelineno-265-10"></a>void BFS_AMGraph(AMGraph *G, VertexType v) {
<a id="__codelineno-265-11" name="__codelineno-265-11"></a>bool *visit = (bool *)malloc(sizeof(bool) * G-&gt;vertices); //为visit分配空间
<a id="__codelineno-265-12" name="__codelineno-265-12"></a>memset(visit, false, sizeof(bool) * G-&gt;vertices); //初始化为false
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-266-1">1</a></span>
<span class="normal"><a href="#__codelineno-266-2">2</a></span>
<span class="normal"><a href="#__codelineno-266-3">3</a></span>
<span class="normal"><a href="#__codelineno-266-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-266-1" name="__codelineno-266-1"></a>int index = Locate_vertex(G, v); //找到下标
<a id="__codelineno-266-2" name="__codelineno-266-2"></a>BFS_AM(G, index, visit); //以此下标为顶点出发，遍历
<a id="__codelineno-266-3" name="__codelineno-266-3"></a>free(visit);
<a id="__codelineno-266-4" name="__codelineno-266-4"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-267-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-267-1" name="__codelineno-267-1"></a>#include &quot;AMGraph.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-268-1">1</a></span>
<span class="normal"><a href="#__codelineno-268-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-268-1" name="__codelineno-268-1"></a>int main(void) {
<a id="__codelineno-268-2" name="__codelineno-268-2"></a>AMGraph G;
</code></pre></div></td></tr></table></div></p>
<h6 id="_638">遍历邻接表<a class="headerlink" href="#_638" title="Permanent link">&para;</a></h6>
<h6 id="_639">注意:使用邻接表时，遍历的顺序和邻接矩阵不一样，因为创建邻接表使用头插法(如果使用尾插法顺序<a class="headerlink" href="#_639" title="Permanent link">&para;</a></h6>
<h6 id="_640">则一样)<a class="headerlink" href="#_640" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-269-1">1</a></span>
<span class="normal"><a href="#__codelineno-269-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-269-1" name="__codelineno-269-1"></a>Creat_unAMGraph_unweightd(&amp;G);
<a id="__codelineno-269-2" name="__codelineno-269-2"></a>BFS_AMGraph(&amp;G, &#39;A&#39;);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-270-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-270-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-270-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-270-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-270-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-270-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-270-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-270-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-270-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-270-10">10</a></span>
<span class="normal"><a href="#__codelineno-270-11">11</a></span>
<span class="normal"><a href="#__codelineno-270-12">12</a></span>
<span class="normal"><a href="#__codelineno-270-13">13</a></span>
<span class="normal"><a href="#__codelineno-270-14">14</a></span>
<span class="normal"><a href="#__codelineno-270-15">15</a></span>
<span class="normal"><a href="#__codelineno-270-16">16</a></span>
<span class="normal"><a href="#__codelineno-270-17">17</a></span>
<span class="normal"><a href="#__codelineno-270-18">18</a></span>
<span class="normal"><a href="#__codelineno-270-19">19</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-270-1" name="__codelineno-270-1"></a>system(&quot;pause&quot;);
<a id="__codelineno-270-2" name="__codelineno-270-2"></a>return 0 ;
<a id="__codelineno-270-3" name="__codelineno-270-3"></a>}
<a id="__codelineno-270-4" name="__codelineno-270-4"></a>//
<a id="__codelineno-270-5" name="__codelineno-270-5"></a>/*
<a id="__codelineno-270-6" name="__codelineno-270-6"></a>8 9
<a id="__codelineno-270-7" name="__codelineno-270-7"></a>A B C D E F G H
<a id="__codelineno-270-8" name="__codelineno-270-8"></a>A B
<a id="__codelineno-270-9" name="__codelineno-270-9"></a>A C
<a id="__codelineno-270-10" name="__codelineno-270-10"></a>B D
<a id="__codelineno-270-11" name="__codelineno-270-11"></a>D H
<a id="__codelineno-270-12" name="__codelineno-270-12"></a>B E
<a id="__codelineno-270-13" name="__codelineno-270-13"></a>E H
<a id="__codelineno-270-14" name="__codelineno-270-14"></a>C F
<a id="__codelineno-270-15" name="__codelineno-270-15"></a>C G
<a id="__codelineno-270-16" name="__codelineno-270-16"></a>F G
<a id="__codelineno-270-17" name="__codelineno-270-17"></a>----------------------
<a id="__codelineno-270-18" name="__codelineno-270-18"></a>A B C D E F G H
<a id="__codelineno-270-19" name="__codelineno-270-19"></a>*/
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-271-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-271-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-271-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-271-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-271-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-271-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-271-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-271-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-271-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-271-10">10</a></span>
<span class="normal"><a href="#__codelineno-271-11">11</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-271-1" name="__codelineno-271-1"></a>void BFS_AL(ALGraph *G, int v, bool *visit) {
<a id="__codelineno-271-2" name="__codelineno-271-2"></a>SqQueue Q;
<a id="__codelineno-271-3" name="__codelineno-271-3"></a>InitQueue(&amp;Q);
<a id="__codelineno-271-4" name="__codelineno-271-4"></a>EdgeNode *p; //用于遍历邻接表
<a id="__codelineno-271-5" name="__codelineno-271-5"></a>EntryQ(&amp;Q, v); //入队顶点
<a id="__codelineno-271-6" name="__codelineno-271-6"></a>visit[v] = true; //设置顶点visit数组状态
<a id="__codelineno-271-7" name="__codelineno-271-7"></a>int pop; //用于接收队列弹出数据
<a id="__codelineno-271-8" name="__codelineno-271-8"></a>while (!IsEmpty(&amp;Q)) {
<a id="__codelineno-271-9" name="__codelineno-271-9"></a>OutQ(&amp;Q, &amp;pop);
<a id="__codelineno-271-10" name="__codelineno-271-10"></a>printf(&quot;%c &quot;, G-&gt;vertex[pop].name); //出队后打印
<a id="__codelineno-271-11" name="__codelineno-271-11"></a>p = G-&gt;vertex[pop].first; //利用p遍历
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-272-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-272-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-272-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-272-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-272-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-272-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-272-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-272-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-272-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-272-10">10</a></span>
<span class="normal"><a href="#__codelineno-272-11">11</a></span>
<span class="normal"><a href="#__codelineno-272-12">12</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-272-1" name="__codelineno-272-1"></a>while (p) {
<a id="__codelineno-272-2" name="__codelineno-272-2"></a>if (!visit[p-&gt;adjvertex]) { //判断p遍历中的邻接点是否被遍历过
<a id="__codelineno-272-3" name="__codelineno-272-3"></a>EntryQ(&amp;Q, p-&gt;adjvertex); //如果没有被遍历过，入队
<a id="__codelineno-272-4" name="__codelineno-272-4"></a>visit[p-&gt;adjvertex] = true; //同时设置visit状态
<a id="__codelineno-272-5" name="__codelineno-272-5"></a>}
<a id="__codelineno-272-6" name="__codelineno-272-6"></a>p = p-&gt;next;
<a id="__codelineno-272-7" name="__codelineno-272-7"></a>}
<a id="__codelineno-272-8" name="__codelineno-272-8"></a>}
<a id="__codelineno-272-9" name="__codelineno-272-9"></a>}
<a id="__codelineno-272-10" name="__codelineno-272-10"></a>void BFS_ALGraph(ALGraph *G, VertexType v) {
<a id="__codelineno-272-11" name="__codelineno-272-11"></a>bool *visit = (bool *)malloc(sizeof(bool) * G-&gt;vertices); //为visit分配空间
<a id="__codelineno-272-12" name="__codelineno-272-12"></a>memset(visit, false, sizeof(bool) * G-&gt;vertices); //初始化为false
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-273-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-273-1" name="__codelineno-273-1"></a>int index = Locate_vertex(G, v); //找到下标
</code></pre></div></td></tr></table></div></p>
<h6 id="_641">测试代码<a class="headerlink" href="#_641" title="Permanent link">&para;</a></h6>
<h4 id="_642">算法效率<a class="headerlink" href="#_642" title="Permanent link">&para;</a></h4>
<h6 id="_643">可知，邻接矩阵的时间效率为 邻接表的时间效率为<a class="headerlink" href="#_643" title="Permanent link">&para;</a></h6>
<h3 id="spanning-tree_3">最小生成树 Spanning Tree<a class="headerlink" href="#spanning-tree_3" title="Permanent link">&para;</a></h3>
<h4 id="prim_1">Prim 算法<a class="headerlink" href="#prim_1" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-274-1">1</a></span>
<span class="normal"><a href="#__codelineno-274-2">2</a></span>
<span class="normal"><a href="#__codelineno-274-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-274-1" name="__codelineno-274-1"></a>BFS_AL(G, index, visit); //以此下标为顶点出发，遍历
<a id="__codelineno-274-2" name="__codelineno-274-2"></a>free(visit);
<a id="__codelineno-274-3" name="__codelineno-274-3"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-275-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-275-1" name="__codelineno-275-1"></a>#include &quot;ALGraph.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-276-1">1</a></span>
<span class="normal"><a href="#__codelineno-276-2">2</a></span>
<span class="normal"><a href="#__codelineno-276-3">3</a></span>
<span class="normal"><a href="#__codelineno-276-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-276-1" name="__codelineno-276-1"></a>int main(void) {
<a id="__codelineno-276-2" name="__codelineno-276-2"></a>ALGraph G;
<a id="__codelineno-276-3" name="__codelineno-276-3"></a>Creat_unALGraph_unweighted(&amp;G);
<a id="__codelineno-276-4" name="__codelineno-276-4"></a>BFS_ALGraph(&amp;G, &#39;A&#39;);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-277-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-277-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-277-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-277-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-277-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-277-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-277-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-277-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-277-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-277-10">10</a></span>
<span class="normal"><a href="#__codelineno-277-11">11</a></span>
<span class="normal"><a href="#__codelineno-277-12">12</a></span>
<span class="normal"><a href="#__codelineno-277-13">13</a></span>
<span class="normal"><a href="#__codelineno-277-14">14</a></span>
<span class="normal"><a href="#__codelineno-277-15">15</a></span>
<span class="normal"><a href="#__codelineno-277-16">16</a></span>
<span class="normal"><a href="#__codelineno-277-17">17</a></span>
<span class="normal"><a href="#__codelineno-277-18">18</a></span>
<span class="normal"><a href="#__codelineno-277-19">19</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-277-1" name="__codelineno-277-1"></a>system(&quot;pause&quot;);
<a id="__codelineno-277-2" name="__codelineno-277-2"></a>return 0 ;
<a id="__codelineno-277-3" name="__codelineno-277-3"></a>}
<a id="__codelineno-277-4" name="__codelineno-277-4"></a>//
<a id="__codelineno-277-5" name="__codelineno-277-5"></a>/*
<a id="__codelineno-277-6" name="__codelineno-277-6"></a>8 9
<a id="__codelineno-277-7" name="__codelineno-277-7"></a>A B C D E F G H
<a id="__codelineno-277-8" name="__codelineno-277-8"></a>A B
<a id="__codelineno-277-9" name="__codelineno-277-9"></a>A C
<a id="__codelineno-277-10" name="__codelineno-277-10"></a>B D
<a id="__codelineno-277-11" name="__codelineno-277-11"></a>D H
<a id="__codelineno-277-12" name="__codelineno-277-12"></a>B E
<a id="__codelineno-277-13" name="__codelineno-277-13"></a>E H
<a id="__codelineno-277-14" name="__codelineno-277-14"></a>C F
<a id="__codelineno-277-15" name="__codelineno-277-15"></a>C G
<a id="__codelineno-277-16" name="__codelineno-277-16"></a>F G
<a id="__codelineno-277-17" name="__codelineno-277-17"></a>----------------------
<a id="__codelineno-277-18" name="__codelineno-277-18"></a>A C B G F E D H
<a id="__codelineno-277-19" name="__codelineno-277-19"></a>*/
</code></pre></div></td></tr></table></div></p>
<h6 id="_644">令 为连通图带权，且<a class="headerlink" href="#_644" title="Permanent link">&para;</a></h6>
<h6 id="_645">设起点为 把 加入到 中<a class="headerlink" href="#_645" title="Permanent link">&para;</a></h6>
<h6 id="_646">选取 为最小<a class="headerlink" href="#_646" title="Permanent link">&para;</a></h6>
<h6 id="_647">输出 边<a class="headerlink" href="#_647" title="Permanent link">&para;</a></h6>
<h6 id="_648">把 加入 中<a class="headerlink" href="#_648" title="Permanent link">&para;</a></h6>
<h6 id="_649">选取 为最小<a class="headerlink" href="#_649" title="Permanent link">&para;</a></h6>
<h6 id="_650">输出 边<a class="headerlink" href="#_650" title="Permanent link">&para;</a></h6>
<h6 id="_651">直到存在 条边<a class="headerlink" href="#_651" title="Permanent link">&para;</a></h6>
<h6 id="_652">此时输出的边即为<a class="headerlink" href="#_652" title="Permanent link">&para;</a></h6>
<h6 id="_653">代码实现<a class="headerlink" href="#_653" title="Permanent link">&para;</a></h6>
<h6 id="spanning-tree_4">实现下图的Spanning Tree<a class="headerlink" href="#spanning-tree_4" title="Permanent link">&para;</a></h6>
<h6 id="u">需要辅助集合U<a class="headerlink" href="#u" title="Permanent link">&para;</a></h6>
<h6 id="_654">邻接矩阵<a class="headerlink" href="#_654" title="Permanent link">&para;</a></h6>
<h6 id="_655">前置算法<a class="headerlink" href="#_655" title="Permanent link">&para;</a></h6>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-278-1">1</a></span>
<span class="normal"><a href="#__codelineno-278-2">2</a></span>
<span class="normal"><a href="#__codelineno-278-3">3</a></span>
<span class="normal"><a href="#__codelineno-278-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-278-1" name="__codelineno-278-1"></a>struct Uset {
<a id="__codelineno-278-2" name="__codelineno-278-2"></a>int adjvertex; //下标为i的点的邻接点
<a id="__codelineno-278-3" name="__codelineno-278-3"></a>int weight; //当前权值
<a id="__codelineno-278-4" name="__codelineno-278-4"></a>};
</code></pre></div></td></tr></table></div>
<h6 id="_656">邻接表<a class="headerlink" href="#_656" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-279-1">1</a></span>
<span class="normal"><a href="#__codelineno-279-2">2</a></span>
<span class="normal"><a href="#__codelineno-279-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-279-1" name="__codelineno-279-1"></a>int Min_Uset(Uset *U, int n) {
<a id="__codelineno-279-2" name="__codelineno-279-2"></a>int min = INT_MAX;
<a id="__codelineno-279-3" name="__codelineno-279-3"></a>int pos = 0 ;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-280-1">1</a></span>
<span class="normal"><a href="#__codelineno-280-2">2</a></span>
<span class="normal"><a href="#__codelineno-280-3">3</a></span>
<span class="normal"><a href="#__codelineno-280-4">4</a></span>
<span class="normal"><a href="#__codelineno-280-5">5</a></span>
<span class="normal"><a href="#__codelineno-280-6">6</a></span>
<span class="normal"><a href="#__codelineno-280-7">7</a></span>
<span class="normal"><a href="#__codelineno-280-8">8</a></span>
<span class="normal"><a href="#__codelineno-280-9">9</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-280-1" name="__codelineno-280-1"></a>for (int i = 0 ; i &lt; n; ++i) {
<a id="__codelineno-280-2" name="__codelineno-280-2"></a>if (U[i].weight != 0 &amp;&amp; U[i].weight &lt; min) {
<a id="__codelineno-280-3" name="__codelineno-280-3"></a>//! 核心语句 U[i].weight != 0 说明不在U中，即V-U
<a id="__codelineno-280-4" name="__codelineno-280-4"></a>min = U[i].weight;
<a id="__codelineno-280-5" name="__codelineno-280-5"></a>pos = i;
<a id="__codelineno-280-6" name="__codelineno-280-6"></a>}
<a id="__codelineno-280-7" name="__codelineno-280-7"></a>}
<a id="__codelineno-280-8" name="__codelineno-280-8"></a>return pos;
<a id="__codelineno-280-9" name="__codelineno-280-9"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-281-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-281-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-281-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-281-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-281-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-281-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-281-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-281-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-281-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-281-10">10</a></span>
<span class="normal"><a href="#__codelineno-281-11">11</a></span>
<span class="normal"><a href="#__codelineno-281-12">12</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-281-1" name="__codelineno-281-1"></a>void MST_Prim(AMGraph *G, VertexType v) {
<a id="__codelineno-281-2" name="__codelineno-281-2"></a>int u = Locate_vertex(G, v);
<a id="__codelineno-281-3" name="__codelineno-281-3"></a>Uset *U = (Uset *)malloc(sizeof(Uset) * G-&gt;vertices);
<a id="__codelineno-281-4" name="__codelineno-281-4"></a>//动态为U分配空间，大小为n(顶点个数)
<a id="__codelineno-281-5" name="__codelineno-281-5"></a>for (int i = 0 ; i &lt; G-&gt;vertices; ++i) {
<a id="__codelineno-281-6" name="__codelineno-281-6"></a>//初始化U集合，因为先把顶点v放入U集合中，所以U[i].adjvertex为
<a id="__codelineno-281-7" name="__codelineno-281-7"></a>//顶点v的下标，即u。如果i与点v存在边
<a id="__codelineno-281-8" name="__codelineno-281-8"></a>U[i].adjvertex = u;
<a id="__codelineno-281-9" name="__codelineno-281-9"></a>//如果i与点v存在边，赋值，如果不存在weight为 99999
<a id="__codelineno-281-10" name="__codelineno-281-10"></a>U[i].weight = G-&gt;edge[u][i];
<a id="__codelineno-281-11" name="__codelineno-281-11"></a>}
<a id="__codelineno-281-12" name="__codelineno-281-12"></a>U[u].weight = 0 ; // weight = 0 说明此点已经加入U集合
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-282-1">1</a></span>
<span class="normal"><a href="#__codelineno-282-2">2</a></span>
<span class="normal"><a href="#__codelineno-282-3">3</a></span>
<span class="normal"><a href="#__codelineno-282-4">4</a></span>
<span class="normal"><a href="#__codelineno-282-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-282-1" name="__codelineno-282-1"></a>for (int i = 1 ; i &lt; G-&gt;vertices; ++i) { //选取n-1条边
<a id="__codelineno-282-2" name="__codelineno-282-2"></a>int min = Min_Uset(U, G-&gt;vertices); //在V-U中选取权值最小的边
<a id="__codelineno-282-3" name="__codelineno-282-3"></a>int u_0 = U[min].adjvertex; // u_0为最小边的邻接点
<a id="__codelineno-282-4" name="__codelineno-282-4"></a>printf(&quot;%c-&gt;%c &quot;, G-&gt;vertex[u_0], G-&gt;vertex[min]); //输出此两点
<a id="__codelineno-282-5" name="__codelineno-282-5"></a>U[min].weight = 0 ; //把该边的顶点加入集合U
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-283-1">1</a></span>
<span class="normal"><a href="#__codelineno-283-2">2</a></span>
<span class="normal"><a href="#__codelineno-283-3">3</a></span>
<span class="normal"><a href="#__codelineno-283-4">4</a></span>
<span class="normal"><a href="#__codelineno-283-5">5</a></span>
<span class="normal"><a href="#__codelineno-283-6">6</a></span>
<span class="normal"><a href="#__codelineno-283-7">7</a></span>
<span class="normal"><a href="#__codelineno-283-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-283-1" name="__codelineno-283-1"></a>for (int j = 0 ; j &lt; G-&gt;vertices; ++j) { //更新U集合
<a id="__codelineno-283-2" name="__codelineno-283-2"></a>if (G-&gt;edge[min][j] &lt; U[j].weight) {
<a id="__codelineno-283-3" name="__codelineno-283-3"></a>//如果成立，使U的weight，和adjvertex和min相关
<a id="__codelineno-283-4" name="__codelineno-283-4"></a>U[j].weight = G-&gt;edge[min][j];
<a id="__codelineno-283-5" name="__codelineno-283-5"></a>U[j].adjvertex = min;
<a id="__codelineno-283-6" name="__codelineno-283-6"></a>}
<a id="__codelineno-283-7" name="__codelineno-283-7"></a>}
<a id="__codelineno-283-8" name="__codelineno-283-8"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-284-1">1</a></span>
<span class="normal"><a href="#__codelineno-284-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-284-1" name="__codelineno-284-1"></a>free(U);
<a id="__codelineno-284-2" name="__codelineno-284-2"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-285-1">1</a></span>
<span class="normal"><a href="#__codelineno-285-2">2</a></span>
<span class="normal"><a href="#__codelineno-285-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-285-1" name="__codelineno-285-1"></a>void MST_Prime(ALGraph *G, VertexType v) {
<a id="__codelineno-285-2" name="__codelineno-285-2"></a>int u = Locate_vertex(G, v);
<a id="__codelineno-285-3" name="__codelineno-285-3"></a>Uset *U = (Uset *)malloc(sizeof(Uset) * G-&gt;vertices);
</code></pre></div></td></tr></table></div></p>
<h6 id="_657">测试代码<a class="headerlink" href="#_657" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-286-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-286-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-286-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-286-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-286-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-286-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-286-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-286-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-286-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-286-10">10</a></span>
<span class="normal"><a href="#__codelineno-286-11">11</a></span>
<span class="normal"><a href="#__codelineno-286-12">12</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-286-1" name="__codelineno-286-1"></a>for (int i = 0 ; i &lt; G-&gt;vertices; ++i) {
<a id="__codelineno-286-2" name="__codelineno-286-2"></a>//邻接表的weight不会为最大值，所以初始化为最大值
<a id="__codelineno-286-3" name="__codelineno-286-3"></a>U[i].weight = MAXWEIGHT;
<a id="__codelineno-286-4" name="__codelineno-286-4"></a>U[i].adjvertex = u;
<a id="__codelineno-286-5" name="__codelineno-286-5"></a>}
<a id="__codelineno-286-6" name="__codelineno-286-6"></a>U[u].weight = 0 ; //加入U集合
<a id="__codelineno-286-7" name="__codelineno-286-7"></a>EdgeNode *p = G-&gt;vertex[u].first;
<a id="__codelineno-286-8" name="__codelineno-286-8"></a>while (p) {
<a id="__codelineno-286-9" name="__codelineno-286-9"></a>//遍历点v的邻接表，把weight放入U中
<a id="__codelineno-286-10" name="__codelineno-286-10"></a>U[p-&gt;adjvertex].weight = p-&gt;weight;
<a id="__codelineno-286-11" name="__codelineno-286-11"></a>p = p-&gt;next;
<a id="__codelineno-286-12" name="__codelineno-286-12"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-287-1">1</a></span>
<span class="normal"><a href="#__codelineno-287-2">2</a></span>
<span class="normal"><a href="#__codelineno-287-3">3</a></span>
<span class="normal"><a href="#__codelineno-287-4">4</a></span>
<span class="normal"><a href="#__codelineno-287-5">5</a></span>
<span class="normal"><a href="#__codelineno-287-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-287-1" name="__codelineno-287-1"></a>for (int i = 1 ; i &lt; G-&gt;vertices; ++i) {
<a id="__codelineno-287-2" name="__codelineno-287-2"></a>// n-1个边
<a id="__codelineno-287-3" name="__codelineno-287-3"></a>int min = Min_Uset(U, G-&gt;vertices); // 权值最小边
<a id="__codelineno-287-4" name="__codelineno-287-4"></a>int u_0 = U[min].adjvertex;
<a id="__codelineno-287-5" name="__codelineno-287-5"></a>printf(&quot;%c-&gt;%c &quot;, G-&gt;vertex[u_0].name, G-&gt;vertex[min].name);
<a id="__codelineno-287-6" name="__codelineno-287-6"></a>U[min].weight = 0 ; //加入集合U中
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-288-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-288-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-288-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-288-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-288-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-288-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-288-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-288-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-288-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-288-10">10</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-288-1" name="__codelineno-288-1"></a>EdgeNode *p_min = G-&gt;vertex[min].first;
<a id="__codelineno-288-2" name="__codelineno-288-2"></a>while (p_min) {
<a id="__codelineno-288-3" name="__codelineno-288-3"></a>//因为邻接表的特性，无需要遍历所有顶点，只需遍历min的邻接表即可
<a id="__codelineno-288-4" name="__codelineno-288-4"></a>if (p_min-&gt;weight &lt; U[p_min-&gt;adjvertex].weight) {
<a id="__codelineno-288-5" name="__codelineno-288-5"></a>U[p_min-&gt;adjvertex].adjvertex = min;
<a id="__codelineno-288-6" name="__codelineno-288-6"></a>U[p_min-&gt;adjvertex].weight = p_min-&gt;weight;
<a id="__codelineno-288-7" name="__codelineno-288-7"></a>}
<a id="__codelineno-288-8" name="__codelineno-288-8"></a>p_min = p_min-&gt;next;
<a id="__codelineno-288-9" name="__codelineno-288-9"></a>}
<a id="__codelineno-288-10" name="__codelineno-288-10"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-289-1">1</a></span>
<span class="normal"><a href="#__codelineno-289-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-289-1" name="__codelineno-289-1"></a>free(U);
<a id="__codelineno-289-2" name="__codelineno-289-2"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-290-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-290-1" name="__codelineno-290-1"></a>#include &quot;ALGraph.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-291-1">1</a></span>
<span class="normal"><a href="#__codelineno-291-2">2</a></span>
<span class="normal"><a href="#__codelineno-291-3">3</a></span>
<span class="normal"><a href="#__codelineno-291-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-291-1" name="__codelineno-291-1"></a>int main(void) {
<a id="__codelineno-291-2" name="__codelineno-291-2"></a>ALGraph G;
<a id="__codelineno-291-3" name="__codelineno-291-3"></a>Creat_unALGraph_weighted(&amp;G);
<a id="__codelineno-291-4" name="__codelineno-291-4"></a>MST_Prime(&amp;G, &#39;A&#39;);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-292-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-292-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-292-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-292-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-292-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-292-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-292-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-292-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-292-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-292-10">10</a></span>
<span class="normal"><a href="#__codelineno-292-11">11</a></span>
<span class="normal"><a href="#__codelineno-292-12">12</a></span>
<span class="normal"><a href="#__codelineno-292-13">13</a></span>
<span class="normal"><a href="#__codelineno-292-14">14</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-292-1" name="__codelineno-292-1"></a>system(&quot;pause&quot;);
<a id="__codelineno-292-2" name="__codelineno-292-2"></a>return 0 ;
<a id="__codelineno-292-3" name="__codelineno-292-3"></a>}
<a id="__codelineno-292-4" name="__codelineno-292-4"></a>//
<a id="__codelineno-292-5" name="__codelineno-292-5"></a>/*
<a id="__codelineno-292-6" name="__codelineno-292-6"></a>6 10
<a id="__codelineno-292-7" name="__codelineno-292-7"></a>A B C D E F
<a id="__codelineno-292-8" name="__codelineno-292-8"></a>A B 6
<a id="__codelineno-292-9" name="__codelineno-292-9"></a>A D 5
<a id="__codelineno-292-10" name="__codelineno-292-10"></a>A C 1
<a id="__codelineno-292-11" name="__codelineno-292-11"></a>B C 5
<a id="__codelineno-292-12" name="__codelineno-292-12"></a>C D 5
<a id="__codelineno-292-13" name="__codelineno-292-13"></a>B E 3
<a id="__codelineno-292-14" name="__codelineno-292-14"></a>E C 6
</code></pre></div></td></tr></table></div></p>
<h4 id="kruskal_1">Kruskal 算法<a class="headerlink" href="#kruskal_1" title="Permanent link">&para;</a></h4>
<h6 id="_658">定理<a class="headerlink" href="#_658" title="Permanent link">&para;</a></h6>
<h6 id="_659">若无向有权无环图 为 图的最大连通子图<a class="headerlink" href="#_659" title="Permanent link">&para;</a></h6>
<h6 id="_660">，作为连通依赖点，则 集合所有点必然存在一条通往 的路径<a class="headerlink" href="#_660" title="Permanent link">&para;</a></h6>
<h6 id="_661">单个顶点的连通依赖点为自身注意 表示为 不可以这么表示<a class="headerlink" href="#_661" title="Permanent link">&para;</a></h6>
<h6 id="_662">令 为连通依赖点，且 使 之间并不存在路径<a class="headerlink" href="#_662" title="Permanent link">&para;</a></h6>
<h6 id="_663">为连通图<a class="headerlink" href="#_663" title="Permanent link">&para;</a></h6>
<h6 id="_664">引理<a class="headerlink" href="#_664" title="Permanent link">&para;</a></h6>
<h6 id="_665">若 分别为 的最大连通子图<a class="headerlink" href="#_665" title="Permanent link">&para;</a></h6>
<h6 id="_666">若 ，则<a class="headerlink" href="#_666" title="Permanent link">&para;</a></h6>
<h6 id="_667">利用<a class="headerlink" href="#_667" title="Permanent link">&para;</a></h6>
<h6 id="_668">若 ，则说明 中所有的点都有一条通往 的路径<a class="headerlink" href="#_668" title="Permanent link">&para;</a></h6>
<h6 id="_669">为最大连通子图子图 同理<a class="headerlink" href="#_669" title="Permanent link">&para;</a></h6>
<h6 id="_670">算法<a class="headerlink" href="#_670" title="Permanent link">&para;</a></h6>
<h6 id="_671">若存在无向带权图 且 连通<a class="headerlink" href="#_671" title="Permanent link">&para;</a></h6>
<h6 id="_672">令集合<a class="headerlink" href="#_672" title="Permanent link">&para;</a></h6>
<h6 id="_673">对 进行排序，取 ，把 加入 中<a class="headerlink" href="#_673" title="Permanent link">&para;</a></h6>
<h6 id="_674">循环对 进行如下操作<a class="headerlink" href="#_674" title="Permanent link">&para;</a></h6>
<h6 id="_675">如果 的连通依赖点 的联通点<a class="headerlink" href="#_675" title="Permanent link">&para;</a></h6>
<h6 id="_676">则把 加入到<a class="headerlink" href="#_676" title="Permanent link">&para;</a></h6>
<h6 id="_677">直到遍历所有边<a class="headerlink" href="#_677" title="Permanent link">&para;</a></h6>
<h6 id="_678">集合中为 的<a class="headerlink" href="#_678" title="Permanent link">&para;</a></h6>
<h6 id="_679">代码实现<a class="headerlink" href="#_679" title="Permanent link">&para;</a></h6>
<h6 id="_680">数据类型定义<a class="headerlink" href="#_680" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-293-1">1</a></span>
<span class="normal"><a href="#__codelineno-293-2">2</a></span>
<span class="normal"><a href="#__codelineno-293-3">3</a></span>
<span class="normal"><a href="#__codelineno-293-4">4</a></span>
<span class="normal"><a href="#__codelineno-293-5">5</a></span>
<span class="normal"><a href="#__codelineno-293-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-293-1" name="__codelineno-293-1"></a>C F 4
<a id="__codelineno-293-2" name="__codelineno-293-2"></a>D F 2
<a id="__codelineno-293-3" name="__codelineno-293-3"></a>E F 6
<a id="__codelineno-293-4" name="__codelineno-293-4"></a>----------------------
<a id="__codelineno-293-5" name="__codelineno-293-5"></a>A-&gt;C C-&gt;F F-&gt;D C-&gt;B B-&gt;E
<a id="__codelineno-293-6" name="__codelineno-293-6"></a>*/
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-294-1">1</a></span>
<span class="normal"><a href="#__codelineno-294-2">2</a></span>
<span class="normal"><a href="#__codelineno-294-3">3</a></span>
<span class="normal"><a href="#__codelineno-294-4">4</a></span>
<span class="normal"><a href="#__codelineno-294-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-294-1" name="__codelineno-294-1"></a>struct Eset { //边集合
<a id="__codelineno-294-2" name="__codelineno-294-2"></a>int start; //起点
<a id="__codelineno-294-3" name="__codelineno-294-3"></a>int end; //终点
<a id="__codelineno-294-4" name="__codelineno-294-4"></a>int weight;
<a id="__codelineno-294-5" name="__codelineno-294-5"></a>};
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-295-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-295-1" name="__codelineno-295-1"></a>void Sort_Eset(Eset *E, int length); //排序函数
</code></pre></div></td></tr></table></div></p>
<h6 id="_681">采用冒泡排序，可以灵活变换<a class="headerlink" href="#_681" title="Permanent link">&para;</a></h6>
<h6 id="_682">邻接矩阵<a class="headerlink" href="#_682" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-296-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-296-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-296-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-296-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-296-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-296-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-296-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-296-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-296-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-296-10">10</a></span>
<span class="normal"><a href="#__codelineno-296-11">11</a></span>
<span class="normal"><a href="#__codelineno-296-12">12</a></span>
<span class="normal"><a href="#__codelineno-296-13">13</a></span>
<span class="normal"><a href="#__codelineno-296-14">14</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-296-1" name="__codelineno-296-1"></a>void Sort_Eset(Eset *E, int length) {
<a id="__codelineno-296-2" name="__codelineno-296-2"></a>bool flag = true; //排序flag
<a id="__codelineno-296-3" name="__codelineno-296-3"></a>for (int i = 0 ; i &lt; length - 1 &amp;&amp; flag; ++i) { //如果未发生交换则说明有序
<a id="__codelineno-296-4" name="__codelineno-296-4"></a>flag = false; //第一次设置为false
<a id="__codelineno-296-5" name="__codelineno-296-5"></a>for (int j = 0 ; j &lt; length - 1 - i; ++j) {
<a id="__codelineno-296-6" name="__codelineno-296-6"></a>if (E[j].weight &gt; E[j + 1 ].weight) {
<a id="__codelineno-296-7" name="__codelineno-296-7"></a>flag = true; //如果发生交换，为true
<a id="__codelineno-296-8" name="__codelineno-296-8"></a>Eset temp = E[j];
<a id="__codelineno-296-9" name="__codelineno-296-9"></a>E[j] = E[j + 1 ];
<a id="__codelineno-296-10" name="__codelineno-296-10"></a>E[j + 1 ] = temp;
<a id="__codelineno-296-11" name="__codelineno-296-11"></a>}
<a id="__codelineno-296-12" name="__codelineno-296-12"></a>}
<a id="__codelineno-296-13" name="__codelineno-296-13"></a>}
<a id="__codelineno-296-14" name="__codelineno-296-14"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-297-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-297-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-297-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-297-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-297-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-297-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-297-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-297-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-297-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-297-10">10</a></span>
<span class="normal"><a href="#__codelineno-297-11">11</a></span>
<span class="normal"><a href="#__codelineno-297-12">12</a></span>
<span class="normal"><a href="#__codelineno-297-13">13</a></span>
<span class="normal"><a href="#__codelineno-297-14">14</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-297-1" name="__codelineno-297-1"></a>void InitEset(Eset *E, AMGraph *G) {
<a id="__codelineno-297-2" name="__codelineno-297-2"></a>//遍历上三角矩阵
<a id="__codelineno-297-3" name="__codelineno-297-3"></a>Eset *p = E;
<a id="__codelineno-297-4" name="__codelineno-297-4"></a>for (int i = 0 ; i &lt; G-&gt;vertices; ++i) // i为array
<a id="__codelineno-297-5" name="__codelineno-297-5"></a>for (int k = i + 1 ; k &lt; G-&gt;vertices; ++k) { // k为column
<a id="__codelineno-297-6" name="__codelineno-297-6"></a>if (G-&gt;edge[i][k] &lt; MAXWEIGHT) { //小于说明存在
<a id="__codelineno-297-7" name="__codelineno-297-7"></a>(p)-&gt;start = i;
<a id="__codelineno-297-8" name="__codelineno-297-8"></a>(p)-&gt;end = k;
<a id="__codelineno-297-9" name="__codelineno-297-9"></a>(p)-&gt;weight = G-&gt;edge[i][k];
<a id="__codelineno-297-10" name="__codelineno-297-10"></a>++p;
<a id="__codelineno-297-11" name="__codelineno-297-11"></a>}
<a id="__codelineno-297-12" name="__codelineno-297-12"></a>}
<a id="__codelineno-297-13" name="__codelineno-297-13"></a>p = NULL;
<a id="__codelineno-297-14" name="__codelineno-297-14"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-298-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-298-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-298-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-298-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-298-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-298-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-298-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-298-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-298-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-298-10">10</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-298-1" name="__codelineno-298-1"></a>void MST_Krusal(AMGraph *G) {
<a id="__codelineno-298-2" name="__codelineno-298-2"></a>Eset *E = (Eset *)malloc(sizeof(Eset) * G-&gt;edges);
<a id="__codelineno-298-3" name="__codelineno-298-3"></a>InitEset(E, G);
<a id="__codelineno-298-4" name="__codelineno-298-4"></a>Sort_Eset(E, G-&gt;edges);
<a id="__codelineno-298-5" name="__codelineno-298-5"></a>//此时E集合有序
<a id="__codelineno-298-6" name="__codelineno-298-6"></a>//建立V集合存放连通依赖点
<a id="__codelineno-298-7" name="__codelineno-298-7"></a>int V[G-&gt;vertices]; //例如V[i] = k;
<a id="__codelineno-298-8" name="__codelineno-298-8"></a>//表示顶点i依赖于k点(即必有一条到k的路径)
<a id="__codelineno-298-9" name="__codelineno-298-9"></a>for (int i = 0 ; i &lt; G-&gt;vertices; ++i) //清掉所有边
<a id="__codelineno-298-10" name="__codelineno-298-10"></a>V[i] = i; //现在V集合的连通分量就是自己，即所有顶点无邻接点
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-299-1">1</a></span>
<span class="normal"><a href="#__codelineno-299-2">2</a></span>
<span class="normal"><a href="#__codelineno-299-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-299-1" name="__codelineno-299-1"></a>for (int j = 0 ; j &lt; G-&gt;edges; ++j) {
<a id="__codelineno-299-2" name="__codelineno-299-2"></a>int v_1 = E[j].start; // v_1和v_2分别为这个边的顶点
<a id="__codelineno-299-3" name="__codelineno-299-3"></a>int v_2 = E[j].end;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-300-1">1</a></span>
<span class="normal"><a href="#__codelineno-300-2">2</a></span>
<span class="normal"><a href="#__codelineno-300-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-300-1" name="__codelineno-300-1"></a>int component_v_1 = V[v_1]; // v_1所属的连通分量
<a id="__codelineno-300-2" name="__codelineno-300-2"></a>int component_v_2 = V[v_2]; // v_2所属的连通分量
<a id="__codelineno-300-3" name="__codelineno-300-3"></a>if (component_v_1 != component_v_2) { //说明不会形成loop
</code></pre></div></td></tr></table></div></p>
<h6 id="_683">测试代码<a class="headerlink" href="#_683" title="Permanent link">&para;</a></h6>
<h6 id="_684">邻接表<a class="headerlink" href="#_684" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-301-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-301-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-301-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-301-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-301-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-301-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-301-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-301-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-301-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-301-10">10</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-301-1" name="__codelineno-301-1"></a>printf(&quot;%c-&gt;%c &quot;, G-&gt;vertex[v_1], G-&gt;vertex[v_2]);
<a id="__codelineno-301-2" name="__codelineno-301-2"></a>//链接这两个顶点，并且输出
<a id="__codelineno-301-3" name="__codelineno-301-3"></a>//因为链接了两个顶点，那么此时构成一条新的连通分量，所以要更新连通分量依赖点
<a id="__codelineno-301-4" name="__codelineno-301-4"></a>for (int k = 0 ; k &lt; G-&gt;vertices; ++k) {
<a id="__codelineno-301-5" name="__codelineno-301-5"></a>if (V[k] == component_v_2) //如果k顶点依赖于v_2的连通分量
<a id="__codelineno-301-6" name="__codelineno-301-6"></a>//那么在连接之后，所有的顶点都依赖于v_1的连通分量
<a id="__codelineno-301-7" name="__codelineno-301-7"></a>V[k] = component_v_1;
<a id="__codelineno-301-8" name="__codelineno-301-8"></a>}
<a id="__codelineno-301-9" name="__codelineno-301-9"></a>}
<a id="__codelineno-301-10" name="__codelineno-301-10"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-302-1">1</a></span>
<span class="normal"><a href="#__codelineno-302-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-302-1" name="__codelineno-302-1"></a>free(E);
<a id="__codelineno-302-2" name="__codelineno-302-2"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-303-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-303-1" name="__codelineno-303-1"></a>#include &quot;AMGraph.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-304-1">1</a></span>
<span class="normal"><a href="#__codelineno-304-2">2</a></span>
<span class="normal"><a href="#__codelineno-304-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-304-1" name="__codelineno-304-1"></a>int main(void) {
<a id="__codelineno-304-2" name="__codelineno-304-2"></a>AMGraph G;
<a id="__codelineno-304-3" name="__codelineno-304-3"></a>Creat_unAMGraph_weightd(&amp;G);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-305-1">1</a></span>
<span class="normal"><a href="#__codelineno-305-2">2</a></span>
<span class="normal"><a href="#__codelineno-305-3">3</a></span>
<span class="normal"><a href="#__codelineno-305-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-305-1" name="__codelineno-305-1"></a>MST_Krusal(&amp;G);
<a id="__codelineno-305-2" name="__codelineno-305-2"></a>system(&quot;pause&quot;);
<a id="__codelineno-305-3" name="__codelineno-305-3"></a>return 0 ;
<a id="__codelineno-305-4" name="__codelineno-305-4"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-306-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-306-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-306-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-306-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-306-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-306-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-306-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-306-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-306-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-306-10">10</a></span>
<span class="normal"><a href="#__codelineno-306-11">11</a></span>
<span class="normal"><a href="#__codelineno-306-12">12</a></span>
<span class="normal"><a href="#__codelineno-306-13">13</a></span>
<span class="normal"><a href="#__codelineno-306-14">14</a></span>
<span class="normal"><a href="#__codelineno-306-15">15</a></span>
<span class="normal"><a href="#__codelineno-306-16">16</a></span>
<span class="normal"><a href="#__codelineno-306-17">17</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-306-1" name="__codelineno-306-1"></a>//
<a id="__codelineno-306-2" name="__codelineno-306-2"></a>/*
<a id="__codelineno-306-3" name="__codelineno-306-3"></a>6 10
<a id="__codelineno-306-4" name="__codelineno-306-4"></a>A B C D E F
<a id="__codelineno-306-5" name="__codelineno-306-5"></a>A B 6
<a id="__codelineno-306-6" name="__codelineno-306-6"></a>A D 5
<a id="__codelineno-306-7" name="__codelineno-306-7"></a>A C 1
<a id="__codelineno-306-8" name="__codelineno-306-8"></a>B C 5
<a id="__codelineno-306-9" name="__codelineno-306-9"></a>C D 5
<a id="__codelineno-306-10" name="__codelineno-306-10"></a>B E 3
<a id="__codelineno-306-11" name="__codelineno-306-11"></a>E C 6
<a id="__codelineno-306-12" name="__codelineno-306-12"></a>C F 4
<a id="__codelineno-306-13" name="__codelineno-306-13"></a>D F 2
<a id="__codelineno-306-14" name="__codelineno-306-14"></a>E F 6
<a id="__codelineno-306-15" name="__codelineno-306-15"></a>----------------------
<a id="__codelineno-306-16" name="__codelineno-306-16"></a>A-&gt;C D-&gt;F B-&gt;E C-&gt;F B-&gt;C
<a id="__codelineno-306-17" name="__codelineno-306-17"></a>*/
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-307-1">1</a></span>
<span class="normal"><a href="#__codelineno-307-2">2</a></span>
<span class="normal"><a href="#__codelineno-307-3">3</a></span>
<span class="normal"><a href="#__codelineno-307-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-307-1" name="__codelineno-307-1"></a>void InitEset(Eset *E, ALGraph *G) {
<a id="__codelineno-307-2" name="__codelineno-307-2"></a>//! 邻接表和邻接矩阵不一样，矩阵是连续的，而邻接表在存储上不是连续的
<a id="__codelineno-307-3" name="__codelineno-307-3"></a>//! ALGraph需要为有向图
<a id="__codelineno-307-4" name="__codelineno-307-4"></a>Eset *p_E = E;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-308-1">1</a></span>
<span class="normal"><a href="#__codelineno-308-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-308-1" name="__codelineno-308-1"></a>for (int i = 0 ; i &lt; G-&gt;vertices; ++i) {
<a id="__codelineno-308-2" name="__codelineno-308-2"></a>EdgeNode *p = G-&gt;vertex[i].first;
</code></pre></div></td></tr></table></div></p>
<h6 id="_685">测试代码<a class="headerlink" href="#_685" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-309-1">1</a></span>
<span class="normal"><a href="#__codelineno-309-2">2</a></span>
<span class="normal"><a href="#__codelineno-309-3">3</a></span>
<span class="normal"><a href="#__codelineno-309-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-309-1" name="__codelineno-309-1"></a>while (p) {
<a id="__codelineno-309-2" name="__codelineno-309-2"></a>p_E-&gt;start = i;
<a id="__codelineno-309-3" name="__codelineno-309-3"></a>p_E-&gt;end = p-&gt;adjvertex;
<a id="__codelineno-309-4" name="__codelineno-309-4"></a>p_E-&gt;weight = p-&gt;weight;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-310-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-310-1" name="__codelineno-310-1"></a>p = p-&gt;next;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-311-1">1</a></span>
<span class="normal"><a href="#__codelineno-311-2">2</a></span>
<span class="normal"><a href="#__codelineno-311-3">3</a></span>
<span class="normal"><a href="#__codelineno-311-4">4</a></span>
<span class="normal"><a href="#__codelineno-311-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-311-1" name="__codelineno-311-1"></a>++p_E;
<a id="__codelineno-311-2" name="__codelineno-311-2"></a>}
<a id="__codelineno-311-3" name="__codelineno-311-3"></a>}
<a id="__codelineno-311-4" name="__codelineno-311-4"></a>p_E = NULL;
<a id="__codelineno-311-5" name="__codelineno-311-5"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-312-1">1</a></span>
<span class="normal"><a href="#__codelineno-312-2">2</a></span>
<span class="normal"><a href="#__codelineno-312-3">3</a></span>
<span class="normal"><a href="#__codelineno-312-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-312-1" name="__codelineno-312-1"></a>void MST_Krusal(ALGraph *G) {
<a id="__codelineno-312-2" name="__codelineno-312-2"></a>Eset *E = (Eset *)malloc(sizeof(Eset) * G-&gt;edges);
<a id="__codelineno-312-3" name="__codelineno-312-3"></a>InitEset(E, G);
<a id="__codelineno-312-4" name="__codelineno-312-4"></a>Sort_Eset(E, G-&gt;edges);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-313-1">1</a></span>
<span class="normal"><a href="#__codelineno-313-2">2</a></span>
<span class="normal"><a href="#__codelineno-313-3">3</a></span>
<span class="normal"><a href="#__codelineno-313-4">4</a></span>
<span class="normal"><a href="#__codelineno-313-5">5</a></span>
<span class="normal"><a href="#__codelineno-313-6">6</a></span>
<span class="normal"><a href="#__codelineno-313-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-313-1" name="__codelineno-313-1"></a>for (int w = 0 ; w &lt; G-&gt;edges; ++w) {
<a id="__codelineno-313-2" name="__codelineno-313-2"></a>printf(&quot;(%d)start=%d, end=%d,weight=%d\n&quot;, w, E[w].start, E[w].end,
<a id="__codelineno-313-3" name="__codelineno-313-3"></a>E[w].weight);
<a id="__codelineno-313-4" name="__codelineno-313-4"></a>}
<a id="__codelineno-313-5" name="__codelineno-313-5"></a>int V[G-&gt;vertices];
<a id="__codelineno-313-6" name="__codelineno-313-6"></a>for (int i = 0 ; i &lt; G-&gt;vertices; ++i)
<a id="__codelineno-313-7" name="__codelineno-313-7"></a>V[i] = i;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-314-1">1</a></span>
<span class="normal"><a href="#__codelineno-314-2">2</a></span>
<span class="normal"><a href="#__codelineno-314-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-314-1" name="__codelineno-314-1"></a>for (int j = 0 ; j &lt; G-&gt;edges; ++j) {
<a id="__codelineno-314-2" name="__codelineno-314-2"></a>int v_1 = E[j].start;
<a id="__codelineno-314-3" name="__codelineno-314-3"></a>int v_2 = E[j].end;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-315-1">1</a></span>
<span class="normal"><a href="#__codelineno-315-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-315-1" name="__codelineno-315-1"></a>int component_v_1 = V[v_1];
<a id="__codelineno-315-2" name="__codelineno-315-2"></a>int component_v_2 = V[v_2];
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-316-1">1</a></span>
<span class="normal"><a href="#__codelineno-316-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-316-1" name="__codelineno-316-1"></a>if (component_v_1 != component_v_2) {
<a id="__codelineno-316-2" name="__codelineno-316-2"></a>printf(&quot;%c-&gt;%c &quot;, G-&gt;vertex[v_1].name, G-&gt;vertex[v_2].name);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-317-1">1</a></span>
<span class="normal"><a href="#__codelineno-317-2">2</a></span>
<span class="normal"><a href="#__codelineno-317-3">3</a></span>
<span class="normal"><a href="#__codelineno-317-4">4</a></span>
<span class="normal"><a href="#__codelineno-317-5">5</a></span>
<span class="normal"><a href="#__codelineno-317-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-317-1" name="__codelineno-317-1"></a>for (int k = 0 ; k &lt; G-&gt;vertices; ++k) {
<a id="__codelineno-317-2" name="__codelineno-317-2"></a>if (component_v_2 == V[k])
<a id="__codelineno-317-3" name="__codelineno-317-3"></a>V[k] = component_v_1;
<a id="__codelineno-317-4" name="__codelineno-317-4"></a>}
<a id="__codelineno-317-5" name="__codelineno-317-5"></a>}
<a id="__codelineno-317-6" name="__codelineno-317-6"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-318-1">1</a></span>
<span class="normal"><a href="#__codelineno-318-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-318-1" name="__codelineno-318-1"></a>free(E);
<a id="__codelineno-318-2" name="__codelineno-318-2"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-319-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-319-1" name="__codelineno-319-1"></a>#include &quot;ALGraph.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-320-1">1</a></span>
<span class="normal"><a href="#__codelineno-320-2">2</a></span>
<span class="normal"><a href="#__codelineno-320-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-320-1" name="__codelineno-320-1"></a>int main(void) {
<a id="__codelineno-320-2" name="__codelineno-320-2"></a>ALGraph G;
<a id="__codelineno-320-3" name="__codelineno-320-3"></a>Creat_ALGraph_weighted(&amp;G); //! 需要用有向图来表示无向图
</code></pre></div></td></tr></table></div></p>
<h3 id="_686">最短路径<a class="headerlink" href="#_686" title="Permanent link">&para;</a></h3>
<h4 id="dijkstra_1">Dijkstra 算法<a class="headerlink" href="#dijkstra_1" title="Permanent link">&para;</a></h4>
<h6 id="_687">若有无向带权网<a class="headerlink" href="#_687" title="Permanent link">&para;</a></h6>
<h6 id="_688">以 为顶点，求出所有 和 间的最路径<a class="headerlink" href="#_688" title="Permanent link">&para;</a></h6>
<h6 id="_689">令 为 到 间的路径长度，集合<a class="headerlink" href="#_689" title="Permanent link">&para;</a></h6>
<h6 id="_690">若 存在，则初始化 ，若不存在则<a class="headerlink" href="#_690" title="Permanent link">&para;</a></h6>
<h6 id="_691">遍历所有点之后，把 加入到 中<a class="headerlink" href="#_691" title="Permanent link">&para;</a></h6>
<h6 id="_692">把 加入到 中，若 为 的邻接点，且<a class="headerlink" href="#_692" title="Permanent link">&para;</a></h6>
<h6 id="_693">则<a class="headerlink" href="#_693" title="Permanent link">&para;</a></h6>
<h6 id="_694">重复上步骤，直到<a class="headerlink" href="#_694" title="Permanent link">&para;</a></h6>
<h6 id="_695">用代码实现此图<a class="headerlink" href="#_695" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-321-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-321-1" name="__codelineno-321-1"></a>MST_Krusal(&amp;G);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-322-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-322-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-322-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-322-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-322-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-322-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-322-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-322-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-322-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-322-10">10</a></span>
<span class="normal"><a href="#__codelineno-322-11">11</a></span>
<span class="normal"><a href="#__codelineno-322-12">12</a></span>
<span class="normal"><a href="#__codelineno-322-13">13</a></span>
<span class="normal"><a href="#__codelineno-322-14">14</a></span>
<span class="normal"><a href="#__codelineno-322-15">15</a></span>
<span class="normal"><a href="#__codelineno-322-16">16</a></span>
<span class="normal"><a href="#__codelineno-322-17">17</a></span>
<span class="normal"><a href="#__codelineno-322-18">18</a></span>
<span class="normal"><a href="#__codelineno-322-19">19</a></span>
<span class="normal"><a href="#__codelineno-322-20">20</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-322-1" name="__codelineno-322-1"></a>system(&quot;pause&quot;);
<a id="__codelineno-322-2" name="__codelineno-322-2"></a>return 0 ;
<a id="__codelineno-322-3" name="__codelineno-322-3"></a>}
<a id="__codelineno-322-4" name="__codelineno-322-4"></a>//
<a id="__codelineno-322-5" name="__codelineno-322-5"></a>/*
<a id="__codelineno-322-6" name="__codelineno-322-6"></a>6 10
<a id="__codelineno-322-7" name="__codelineno-322-7"></a>A B C D E F
<a id="__codelineno-322-8" name="__codelineno-322-8"></a>A B 6
<a id="__codelineno-322-9" name="__codelineno-322-9"></a>A D 5
<a id="__codelineno-322-10" name="__codelineno-322-10"></a>A C 1
<a id="__codelineno-322-11" name="__codelineno-322-11"></a>B C 5
<a id="__codelineno-322-12" name="__codelineno-322-12"></a>C D 5
<a id="__codelineno-322-13" name="__codelineno-322-13"></a>B E 3
<a id="__codelineno-322-14" name="__codelineno-322-14"></a>E C 6
<a id="__codelineno-322-15" name="__codelineno-322-15"></a>C F 4
<a id="__codelineno-322-16" name="__codelineno-322-16"></a>D F 2
<a id="__codelineno-322-17" name="__codelineno-322-17"></a>E F 6
<a id="__codelineno-322-18" name="__codelineno-322-18"></a>----------------------
<a id="__codelineno-322-19" name="__codelineno-322-19"></a>A-&gt;C D-&gt;F B-&gt;E C-&gt;F B-&gt;C
<a id="__codelineno-322-20" name="__codelineno-322-20"></a>*/
</code></pre></div></td></tr></table></div></p>
<h6 id="_696">代码实现<a class="headerlink" href="#_696" title="Permanent link">&para;</a></h6>
<h6 id="_697">邻接矩阵<a class="headerlink" href="#_697" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-323-1">1</a></span>
<span class="normal"><a href="#__codelineno-323-2">2</a></span>
<span class="normal"><a href="#__codelineno-323-3">3</a></span>
<span class="normal"><a href="#__codelineno-323-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-323-1" name="__codelineno-323-1"></a>void ShortestPath(AMGraph *G, int v, int *path) {
<a id="__codelineno-323-2" name="__codelineno-323-2"></a>//! 数组path[i]表示i的最短前驱
<a id="__codelineno-323-3" name="__codelineno-323-3"></a>int D[G-&gt;vertices]; //集合D表示各个顶点到v的距离
<a id="__codelineno-323-4" name="__codelineno-323-4"></a>bool S[G-&gt;vertices]; //集合S，如果i点在S中则为true
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-324-1">1</a></span>
<span class="normal"><a href="#__codelineno-324-2">2</a></span>
<span class="normal"><a href="#__codelineno-324-3">3</a></span>
<span class="normal"><a href="#__codelineno-324-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-324-1" name="__codelineno-324-1"></a>for (int i = 0 ; i &lt; G-&gt;vertices; ++i) {
<a id="__codelineno-324-2" name="__codelineno-324-2"></a>//初始化D,S,path
<a id="__codelineno-324-3" name="__codelineno-324-3"></a>D[i] = G-&gt;edge[v][i]; //如果不存在边，则为MAXWEIGHT
<a id="__codelineno-324-4" name="__codelineno-324-4"></a>S[i] = false; //初始化S为空集
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-325-1">1</a></span>
<span class="normal"><a href="#__codelineno-325-2">2</a></span>
<span class="normal"><a href="#__codelineno-325-3">3</a></span>
<span class="normal"><a href="#__codelineno-325-4">4</a></span>
<span class="normal"><a href="#__codelineno-325-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-325-1" name="__codelineno-325-1"></a>if (D[i] &lt; MAXWEIGHT) //说明边存在
<a id="__codelineno-325-2" name="__codelineno-325-2"></a>path[i] = v; //设置前驱
<a id="__codelineno-325-3" name="__codelineno-325-3"></a>else
<a id="__codelineno-325-4" name="__codelineno-325-4"></a>path[i] = - 1 ; //如果不存在边，-1
<a id="__codelineno-325-5" name="__codelineno-325-5"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-326-1">1</a></span>
<span class="normal"><a href="#__codelineno-326-2">2</a></span>
<span class="normal"><a href="#__codelineno-326-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-326-1" name="__codelineno-326-1"></a>S[v] = true;
<a id="__codelineno-326-2" name="__codelineno-326-2"></a>D[v] = 0 ;
<a id="__codelineno-326-3" name="__codelineno-326-3"></a>//初始化完成
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-327-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-327-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-327-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-327-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-327-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-327-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-327-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-327-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-327-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-327-10">10</a></span>
<span class="normal"><a href="#__codelineno-327-11">11</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-327-1" name="__codelineno-327-1"></a>for (int i = 1 ; i &lt; G-&gt;vertices; ++i) {
<a id="__codelineno-327-2" name="__codelineno-327-2"></a>int min_index;
<a id="__codelineno-327-3" name="__codelineno-327-3"></a>int min = MAXWEIGHT;
<a id="__codelineno-327-4" name="__codelineno-327-4"></a>for (int j = 0 ; j &lt; G-&gt;vertices; ++j) {
<a id="__codelineno-327-5" name="__codelineno-327-5"></a>//从D中选出路径最短点，且不在集合S中
<a id="__codelineno-327-6" name="__codelineno-327-6"></a>if (!S[j] &amp;&amp; D[j] &lt; min) {
<a id="__codelineno-327-7" name="__codelineno-327-7"></a>min_index = j;
<a id="__codelineno-327-8" name="__codelineno-327-8"></a>min = D[j]; //求出D[j]最小的点
<a id="__codelineno-327-9" name="__codelineno-327-9"></a>}
<a id="__codelineno-327-10" name="__codelineno-327-10"></a>}
<a id="__codelineno-327-11" name="__codelineno-327-11"></a>S[min_index] = true; //把该点加入到S中
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-328-1">1</a></span>
<span class="normal"><a href="#__codelineno-328-2">2</a></span>
<span class="normal"><a href="#__codelineno-328-3">3</a></span>
<span class="normal"><a href="#__codelineno-328-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-328-1" name="__codelineno-328-1"></a>for (int k = 0 ; k &lt; G-&gt;vertices; ++k) {
<a id="__codelineno-328-2" name="__codelineno-328-2"></a>if (!S[k] &amp;&amp; (G-&gt;edge[min_index][k] + D[min_index] &lt; D[k])) {
<a id="__codelineno-328-3" name="__codelineno-328-3"></a>//遍历min_index的邻接点，进行判断
<a id="__codelineno-328-4" name="__codelineno-328-4"></a>D[k] = G-&gt;edge[min_index][k] + D[min_index];
</code></pre></div></td></tr></table></div></p>
<h6 id="_698">测试代码<a class="headerlink" href="#_698" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-329-1">1</a></span>
<span class="normal"><a href="#__codelineno-329-2">2</a></span>
<span class="normal"><a href="#__codelineno-329-3">3</a></span>
<span class="normal"><a href="#__codelineno-329-4">4</a></span>
<span class="normal"><a href="#__codelineno-329-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-329-1" name="__codelineno-329-1"></a>path[k] = min_index;
<a id="__codelineno-329-2" name="__codelineno-329-2"></a>}
<a id="__codelineno-329-3" name="__codelineno-329-3"></a>}
<a id="__codelineno-329-4" name="__codelineno-329-4"></a>}
<a id="__codelineno-329-5" name="__codelineno-329-5"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-330-1">1</a></span>
<span class="normal"><a href="#__codelineno-330-2">2</a></span>
<span class="normal"><a href="#__codelineno-330-3">3</a></span>
<span class="normal"><a href="#__codelineno-330-4">4</a></span>
<span class="normal"><a href="#__codelineno-330-5">5</a></span>
<span class="normal"><a href="#__codelineno-330-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-330-1" name="__codelineno-330-1"></a>void ShortestPath_Dijkstra(AMGraph *G, VertexType v) {
<a id="__codelineno-330-2" name="__codelineno-330-2"></a>//封装的函数，表示以v为起点，求出所有点与v的最短路径
<a id="__codelineno-330-3" name="__codelineno-330-3"></a>int v_index = Locate_vertex(G, v);
<a id="__codelineno-330-4" name="__codelineno-330-4"></a>int *path = (int *)malloc(sizeof(int) * G-&gt;vertices);
<a id="__codelineno-330-5" name="__codelineno-330-5"></a>ShortestPath(G, v_index, path);
<a id="__codelineno-330-6" name="__codelineno-330-6"></a>// for (int i = 0; i &lt; G-&gt;vertices; ++i)
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-331-1">1</a></span>
<span class="normal"><a href="#__codelineno-331-2">2</a></span>
<span class="normal"><a href="#__codelineno-331-3">3</a></span>
<span class="normal"><a href="#__codelineno-331-4">4</a></span>
<span class="normal"><a href="#__codelineno-331-5">5</a></span>
<span class="normal"><a href="#__codelineno-331-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-331-1" name="__codelineno-331-1"></a>for (int i = 0 ; i &lt; G-&gt;vertices; ++i) {
<a id="__codelineno-331-2" name="__codelineno-331-2"></a>if (i != v_index) {
<a id="__codelineno-331-3" name="__codelineno-331-3"></a>print_path(G, path, v_index, i);
<a id="__codelineno-331-4" name="__codelineno-331-4"></a>printf(&quot;\n&quot;);
<a id="__codelineno-331-5" name="__codelineno-331-5"></a>}
<a id="__codelineno-331-6" name="__codelineno-331-6"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-332-1">1</a></span>
<span class="normal"><a href="#__codelineno-332-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-332-1" name="__codelineno-332-1"></a>free(path);
<a id="__codelineno-332-2" name="__codelineno-332-2"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-333-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-333-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-333-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-333-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-333-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-333-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-333-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-333-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-333-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-333-10">10</a></span>
<span class="normal"><a href="#__codelineno-333-11">11</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-333-1" name="__codelineno-333-1"></a>void print_path(AMGraph *G, int *path, int start, int end) {
<a id="__codelineno-333-2" name="__codelineno-333-2"></a>SqStack S;
<a id="__codelineno-333-3" name="__codelineno-333-3"></a>InitStack(&amp;S);
<a id="__codelineno-333-4" name="__codelineno-333-4"></a>printf(&quot;%c-&gt;&quot;, G-&gt;vertex[start]);
<a id="__codelineno-333-5" name="__codelineno-333-5"></a>Push(&amp;S, end); //先入栈end
<a id="__codelineno-333-6" name="__codelineno-333-6"></a>int flag = end; //用于判断是否输出&quot;-&gt;&quot;&quot;
<a id="__codelineno-333-7" name="__codelineno-333-7"></a>end = path[end];
<a id="__codelineno-333-8" name="__codelineno-333-8"></a>while (end != start) {
<a id="__codelineno-333-9" name="__codelineno-333-9"></a>Push(&amp;S, end);
<a id="__codelineno-333-10" name="__codelineno-333-10"></a>end = path[end];
<a id="__codelineno-333-11" name="__codelineno-333-11"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-334-1">1</a></span>
<span class="normal"><a href="#__codelineno-334-2">2</a></span>
<span class="normal"><a href="#__codelineno-334-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-334-1" name="__codelineno-334-1"></a>int head = start;
<a id="__codelineno-334-2" name="__codelineno-334-2"></a>int pop;
<a id="__codelineno-334-3" name="__codelineno-334-3"></a>while (!IsEmpty(&amp;S)) {
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-335-1">1</a></span>
<span class="normal"><a href="#__codelineno-335-2">2</a></span>
<span class="normal"><a href="#__codelineno-335-3">3</a></span>
<span class="normal"><a href="#__codelineno-335-4">4</a></span>
<span class="normal"><a href="#__codelineno-335-5">5</a></span>
<span class="normal"><a href="#__codelineno-335-6">6</a></span>
<span class="normal"><a href="#__codelineno-335-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-335-1" name="__codelineno-335-1"></a>Pop(&amp;S, &amp;pop);
<a id="__codelineno-335-2" name="__codelineno-335-2"></a>printf(&quot;%c(%d)&quot;, G-&gt;vertex[pop], G-&gt;edge[head][pop]);
<a id="__codelineno-335-3" name="__codelineno-335-3"></a>if (pop != flag)
<a id="__codelineno-335-4" name="__codelineno-335-4"></a>printf(&quot;-&gt;&quot;);
<a id="__codelineno-335-5" name="__codelineno-335-5"></a>head = pop;
<a id="__codelineno-335-6" name="__codelineno-335-6"></a>}
<a id="__codelineno-335-7" name="__codelineno-335-7"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-336-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-336-1" name="__codelineno-336-1"></a>#include &quot;AMGraph.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-337-1">1</a></span>
<span class="normal"><a href="#__codelineno-337-2">2</a></span>
<span class="normal"><a href="#__codelineno-337-3">3</a></span>
<span class="normal"><a href="#__codelineno-337-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-337-1" name="__codelineno-337-1"></a>int main(void) {
<a id="__codelineno-337-2" name="__codelineno-337-2"></a>AMGraph G;
<a id="__codelineno-337-3" name="__codelineno-337-3"></a>Creat_unAMGraph_weightd(&amp;G);
<a id="__codelineno-337-4" name="__codelineno-337-4"></a>ShortestPath_Dijkstra(&amp;G, &#39;A&#39;);
</code></pre></div></td></tr></table></div></p>
<h4 id="floyd_1">Floyd算法<a class="headerlink" href="#floyd_1" title="Permanent link">&para;</a></h4>
<h6 id="_699">本质上为暴力算法<a class="headerlink" href="#_699" title="Permanent link">&para;</a></h6>
<h6 id="_700">令矩阵 存储图 的权值，其中 有 个顶点<a class="headerlink" href="#_700" title="Permanent link">&para;</a></h6>
<h6 id="_701">表示到的 表示 到 的<a class="headerlink" href="#_701" title="Permanent link">&para;</a></h6>
<h6 id="_702">遍历矩阵所有元素，向 之间插入点 ，如果<a class="headerlink" href="#_702" title="Permanent link">&para;</a></h6>
<h6 id="_703">则<a class="headerlink" href="#_703" title="Permanent link">&para;</a></h6>
<h6 id="_704">遍历结束后，矩阵 记录 的最短路径<a class="headerlink" href="#_704" title="Permanent link">&para;</a></h6>
<h6 id="_705">代码实现<a class="headerlink" href="#_705" title="Permanent link">&para;</a></h6>
<h6 id="_706">邻接矩阵<a class="headerlink" href="#_706" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-338-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-338-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-338-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-338-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-338-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-338-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-338-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-338-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-338-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-338-10">10</a></span>
<span class="normal"><a href="#__codelineno-338-11">11</a></span>
<span class="normal"><a href="#__codelineno-338-12">12</a></span>
<span class="normal"><a href="#__codelineno-338-13">13</a></span>
<span class="normal"><a href="#__codelineno-338-14">14</a></span>
<span class="normal"><a href="#__codelineno-338-15">15</a></span>
<span class="normal"><a href="#__codelineno-338-16">16</a></span>
<span class="normal"><a href="#__codelineno-338-17">17</a></span>
<span class="normal"><a href="#__codelineno-338-18">18</a></span>
<span class="normal"><a href="#__codelineno-338-19">19</a></span>
<span class="normal"><a href="#__codelineno-338-20">20</a></span>
<span class="normal"><a href="#__codelineno-338-21">21</a></span>
<span class="normal"><a href="#__codelineno-338-22">22</a></span>
<span class="normal"><a href="#__codelineno-338-23">23</a></span>
<span class="normal"><a href="#__codelineno-338-24">24</a></span>
<span class="normal"><a href="#__codelineno-338-25">25</a></span>
<span class="normal"><a href="#__codelineno-338-26">26</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-338-1" name="__codelineno-338-1"></a>system(&quot;pause&quot;);
<a id="__codelineno-338-2" name="__codelineno-338-2"></a>return 0 ;
<a id="__codelineno-338-3" name="__codelineno-338-3"></a>}
<a id="__codelineno-338-4" name="__codelineno-338-4"></a>//
<a id="__codelineno-338-5" name="__codelineno-338-5"></a>/*
<a id="__codelineno-338-6" name="__codelineno-338-6"></a>7 11
<a id="__codelineno-338-7" name="__codelineno-338-7"></a>A B C D E F G
<a id="__codelineno-338-8" name="__codelineno-338-8"></a>A B 15
<a id="__codelineno-338-9" name="__codelineno-338-9"></a>A C 9
<a id="__codelineno-338-10" name="__codelineno-338-10"></a>A D 4
<a id="__codelineno-338-11" name="__codelineno-338-11"></a>C F 12
<a id="__codelineno-338-12" name="__codelineno-338-12"></a>F G 16
<a id="__codelineno-338-13" name="__codelineno-338-13"></a>F D 6
<a id="__codelineno-338-14" name="__codelineno-338-14"></a>D B 5
<a id="__codelineno-338-15" name="__codelineno-338-15"></a>B G 8
<a id="__codelineno-338-16" name="__codelineno-338-16"></a>B E 2
<a id="__codelineno-338-17" name="__codelineno-338-17"></a>E G 3
<a id="__codelineno-338-18" name="__codelineno-338-18"></a>D G 11
<a id="__codelineno-338-19" name="__codelineno-338-19"></a>----------------------
<a id="__codelineno-338-20" name="__codelineno-338-20"></a>A-&gt;D(4)-&gt;B(5)
<a id="__codelineno-338-21" name="__codelineno-338-21"></a>A-&gt;C(9)
<a id="__codelineno-338-22" name="__codelineno-338-22"></a>A-&gt;D(4)
<a id="__codelineno-338-23" name="__codelineno-338-23"></a>A-&gt;D(4)-&gt;B(5)-&gt;E(2)
<a id="__codelineno-338-24" name="__codelineno-338-24"></a>A-&gt;D(4)-&gt;F(6)
<a id="__codelineno-338-25" name="__codelineno-338-25"></a>A-&gt;D(4)-&gt;B(5)-&gt;E(2)-&gt;G(3)
<a id="__codelineno-338-26" name="__codelineno-338-26"></a>*/
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-339-1">1</a></span>
<span class="normal"><a href="#__codelineno-339-2">2</a></span>
<span class="normal"><a href="#__codelineno-339-3">3</a></span>
<span class="normal"><a href="#__codelineno-339-4">4</a></span>
<span class="normal"><a href="#__codelineno-339-5">5</a></span>
<span class="normal"><a href="#__codelineno-339-6">6</a></span>
<span class="normal"><a href="#__codelineno-339-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-339-1" name="__codelineno-339-1"></a>int **Path_Matrix(AMGraph *G) {
<a id="__codelineno-339-2" name="__codelineno-339-2"></a>// path[i][j]表示从i到j的路径上，j点的直接前驱
<a id="__codelineno-339-3" name="__codelineno-339-3"></a>int n = G-&gt;vertices;
<a id="__codelineno-339-4" name="__codelineno-339-4"></a>int **path = (int **)malloc(sizeof(int *) * n); //先分配一维指针数组
<a id="__codelineno-339-5" name="__codelineno-339-5"></a>for (int i = 0 ; i &lt; G-&gt;vertices; ++i) // path[i]分配空间;
<a id="__codelineno-339-6" name="__codelineno-339-6"></a>path[i] = (int *)malloc(sizeof(int) * n);
<a id="__codelineno-339-7" name="__codelineno-339-7"></a>//此时path为二维数组
</code></pre></div></td></tr></table></div></p>
<p>int D[n][n];</p>
<p>for (int i = 0 ; i &lt; n; ++i)
for (int j = 0 ; j &lt; n; ++j) {
D[i][j] = G-&gt;edge[i][j]; // copy给D
if (D[i][j] &lt; MAXWEIGHT) //点i,j如果为邻接点
path[i][j] = i; //此时的路径即为i，j之间的边，所以j的前驱为i
else
path[i][j] = - 1 ;
}</p>
<p>for (int k = 0 ; k &lt; n; ++k) //尝试在两点之间加入点k
for (int i = 0 ; i &lt; n; ++i)
for (int j = 0 ; j &lt; n; ++j) {
if (D[i][k] + D[k][j] &lt; D[i][j]) {
D[i][j] = D[i][k] + D[k][j];
path[i][j] = path[k][j]; //更新path，即j的前驱，向前递归
}
}</p>
<p>return path;
}</p>
<p>void ShortestPath_Floyd(AMGraph *G, VertexType v1, VertexType v2) {
int start = Locate_vertex(G, v1);
int end = Locate_vertex(G, v2);</p>
<p>int **path = Path_Matrix(G);</p>
<p>SqStack S;
InitStack(&amp;S);
Push(&amp;S, end); //先入栈末端点
int prior = path[start][end];</p>
<p>while (prior != start) {
//向前回溯，直到prior == start
Push(&amp;S, prior);
prior = path[start][prior];
}</p>
<p>int head = start; // head用于向前追溯
int pop;
printf("%c-&gt;", G-&gt;vertex[start]);
while (!IsEmpty(&amp;S)) {
Pop(&amp;S, &amp;pop);
printf("%c(%d)", G-&gt;vertex[pop], G-&gt;edge[head][pop]);
if (pop != end)
printf("-&gt;");
head = pop; //向前追溯
}</p>
<p>for (int i = 0 ; i &lt; G-&gt;vertices; ++i)
//因为path本质上是一维指针数组，每个指针又指向一块空间，所以逐个释放
free(path[i]);
free(path); //还需要释放path</p>
<h3 id="directed-acycline-graph_1">有向无环图(Directed Acycline Graph)<a class="headerlink" href="#directed-acycline-graph_1" title="Permanent link">&para;</a></h3>
<h4 id="aocaoe_1">AOC和AOE<a class="headerlink" href="#aocaoe_1" title="Permanent link">&para;</a></h4>
<h6 id="_707">网<a class="headerlink" href="#_707" title="Permanent link">&para;</a></h6>
<h6 id="_708">用一个有向图表示一个工程的各个子工程及其相互制约关系<a class="headerlink" href="#_708" title="Permanent link">&para;</a></h6>
<h6 id="_709">其中顶点表示活动，弧表示优先制约关系<a class="headerlink" href="#_709" title="Permanent link">&para;</a></h6>
<h6 id="_710">网<a class="headerlink" href="#_710" title="Permanent link">&para;</a></h6>
<h6 id="_711">弧表示活动，以顶点表示活动开始或结束事件<a class="headerlink" href="#_711" title="Permanent link">&para;</a></h6>
<h4 id="_712">拓扑排序<a class="headerlink" href="#_712" title="Permanent link">&para;</a></h4>
<h6 id="_713">在 网没有回路的前提下，将全部活动排列成一个线性序列<a class="headerlink" href="#_713" title="Permanent link">&para;</a></h6>
<h6 id="_714">网中边 存在，则在这个序列中一定排在的前面<a class="headerlink" href="#_714" title="Permanent link">&para;</a></h6>
<h6 id="_715">对 网进行如上排序，即为拓扑排序<a class="headerlink" href="#_715" title="Permanent link">&para;</a></h6>
<h6 id="_716">算法思路<a class="headerlink" href="#_716" title="Permanent link">&para;</a></h6>
<h6 id="_717">若 图中 ，则去除掉所有和 相关的边<a class="headerlink" href="#_717" title="Permanent link">&para;</a></h6>
<h6 id="_718">令 ，把 加入到 中<a class="headerlink" href="#_718" title="Permanent link">&para;</a></h6>
<h6 id="_719">更新所有 的<a class="headerlink" href="#_719" title="Permanent link">&para;</a></h6>
<h6 id="_720">直到<a class="headerlink" href="#_720" title="Permanent link">&para;</a></h6>
<h6 id="_721">此时 的序列则为拓扑序列<a class="headerlink" href="#_721" title="Permanent link">&para;</a></h6>
<h6 id="_722">代码实现<a class="headerlink" href="#_722" title="Permanent link">&para;</a></h6>
<h6 id="_723">实现下图<a class="headerlink" href="#_723" title="Permanent link">&para;</a></h6>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-340-1">1</a></span>
<span class="normal"><a href="#__codelineno-340-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-340-1" name="__codelineno-340-1"></a>path = NULL;
<a id="__codelineno-340-2" name="__codelineno-340-2"></a>}
</code></pre></div></td></tr></table></div>
<h6 id="_724">邻接表<a class="headerlink" href="#_724" title="Permanent link">&para;</a></h6>
<h6 id="_725">前置函数<a class="headerlink" href="#_725" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-341-1">1</a></span>
<span class="normal"><a href="#__codelineno-341-2">2</a></span>
<span class="normal"><a href="#__codelineno-341-3">3</a></span>
<span class="normal"><a href="#__codelineno-341-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-341-1" name="__codelineno-341-1"></a>void InDegree(ALGraph *G, int *a) {
<a id="__codelineno-341-2" name="__codelineno-341-2"></a>//获取所有点的indegree
<a id="__codelineno-341-3" name="__codelineno-341-3"></a>for (int i = 0 ; i &lt; G-&gt;vertices; ++i) {
<a id="__codelineno-341-4" name="__codelineno-341-4"></a>EdgeNode *p = G-&gt;vertex[i].first;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-342-1">1</a></span>
<span class="normal"><a href="#__codelineno-342-2">2</a></span>
<span class="normal"><a href="#__codelineno-342-3">3</a></span>
<span class="normal"><a href="#__codelineno-342-4">4</a></span>
<span class="normal"><a href="#__codelineno-342-5">5</a></span>
<span class="normal"><a href="#__codelineno-342-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-342-1" name="__codelineno-342-1"></a>while (p) {
<a id="__codelineno-342-2" name="__codelineno-342-2"></a>++a[p-&gt;adjvertex];
<a id="__codelineno-342-3" name="__codelineno-342-3"></a>p = p-&gt;next;
<a id="__codelineno-342-4" name="__codelineno-342-4"></a>}
<a id="__codelineno-342-5" name="__codelineno-342-5"></a>}
<a id="__codelineno-342-6" name="__codelineno-342-6"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-343-1">1</a></span>
<span class="normal"><a href="#__codelineno-343-2">2</a></span>
<span class="normal"><a href="#__codelineno-343-3">3</a></span>
<span class="normal"><a href="#__codelineno-343-4">4</a></span>
<span class="normal"><a href="#__codelineno-343-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-343-1" name="__codelineno-343-1"></a>int *Get_Topo(ALGraph *G) {
<a id="__codelineno-343-2" name="__codelineno-343-2"></a>int *indegree = (int *)malloc(sizeof(int) * G-&gt;vertices);
<a id="__codelineno-343-3" name="__codelineno-343-3"></a>memset(indegree, 0 , sizeof(int) * G-&gt;vertices); //主要要对堆数据初始化
<a id="__codelineno-343-4" name="__codelineno-343-4"></a>int *topo = (int *)malloc(sizeof(int) * G-&gt;vertices);
<a id="__codelineno-343-5" name="__codelineno-343-5"></a>memset(topo, 0 , sizeof(int) * G-&gt;vertices);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-344-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-344-1" name="__codelineno-344-1"></a>InDegree(G, indegree); //获取全部点的indegree
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-345-1">1</a></span>
<span class="normal"><a href="#__codelineno-345-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-345-1" name="__codelineno-345-1"></a>SqStack S;
<a id="__codelineno-345-2" name="__codelineno-345-2"></a>InitStack(&amp;S);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-346-1">1</a></span>
<span class="normal"><a href="#__codelineno-346-2">2</a></span>
<span class="normal"><a href="#__codelineno-346-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-346-1" name="__codelineno-346-1"></a>for (int i = 0 ; i &lt; G-&gt;vertices; ++i)
<a id="__codelineno-346-2" name="__codelineno-346-2"></a>if (!indegree[i]) //如果indegree==0 入栈
<a id="__codelineno-346-3" name="__codelineno-346-3"></a>Push(&amp;S, i);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-347-1">1</a></span>
<span class="normal"><a href="#__codelineno-347-2">2</a></span>
<span class="normal"><a href="#__codelineno-347-3">3</a></span>
<span class="normal"><a href="#__codelineno-347-4">4</a></span>
<span class="normal"><a href="#__codelineno-347-5">5</a></span>
<span class="normal"><a href="#__codelineno-347-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-347-1" name="__codelineno-347-1"></a>int m = 0 ; //用于控制topo下标
<a id="__codelineno-347-2" name="__codelineno-347-2"></a>int pop; //用于接收栈弹出值
<a id="__codelineno-347-3" name="__codelineno-347-3"></a>while (!IsEmpty(&amp;S)) {
<a id="__codelineno-347-4" name="__codelineno-347-4"></a>Pop(&amp;S, &amp;pop); //弹出
<a id="__codelineno-347-5" name="__codelineno-347-5"></a>topo[m++] = pop; //栈顶即为拓扑序列顶点
<a id="__codelineno-347-6" name="__codelineno-347-6"></a>EdgeNode *p = G-&gt;vertex[pop].first;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-348-1">1</a></span>
<span class="normal"><a href="#__codelineno-348-2">2</a></span>
<span class="normal"><a href="#__codelineno-348-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-348-1" name="__codelineno-348-1"></a>while (p) {
<a id="__codelineno-348-2" name="__codelineno-348-2"></a>//因为在逻辑上删除了pop点，所以更新它邻接点的indegree
<a id="__codelineno-348-3" name="__codelineno-348-3"></a>--indegree[p-&gt;adjvertex];
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-349-1">1</a></span>
<span class="normal"><a href="#__codelineno-349-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-349-1" name="__codelineno-349-1"></a>if (!indegree[p-&gt;adjvertex]) //判断indegree==0
<a id="__codelineno-349-2" name="__codelineno-349-2"></a>Push(&amp;S, p-&gt;adjvertex);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-350-1">1</a></span>
<span class="normal"><a href="#__codelineno-350-2">2</a></span>
<span class="normal"><a href="#__codelineno-350-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-350-1" name="__codelineno-350-1"></a>p = p-&gt;next;
<a id="__codelineno-350-2" name="__codelineno-350-2"></a>}
<a id="__codelineno-350-3" name="__codelineno-350-3"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-351-1">1</a></span>
<span class="normal"><a href="#__codelineno-351-2">2</a></span>
<span class="normal"><a href="#__codelineno-351-3">3</a></span>
<span class="normal"><a href="#__codelineno-351-4">4</a></span>
<span class="normal"><a href="#__codelineno-351-5">5</a></span>
<span class="normal"><a href="#__codelineno-351-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-351-1" name="__codelineno-351-1"></a>if (m &lt; G-&gt;vertices) {
<a id="__codelineno-351-2" name="__codelineno-351-2"></a>//如果m=G-&gt;vertices 说明G为AOV
<a id="__codelineno-351-3" name="__codelineno-351-3"></a>//如果不说明有回路
<a id="__codelineno-351-4" name="__codelineno-351-4"></a>free(indegree);
<a id="__codelineno-351-5" name="__codelineno-351-5"></a>free(topo);
<a id="__codelineno-351-6" name="__codelineno-351-6"></a>return NULL; //返回空
</code></pre></div></td></tr></table></div></p>
<h3 id="_726">关键路径<a class="headerlink" href="#_726" title="Permanent link">&para;</a></h3>
<h6 id="_727">如上图 网，源点 表示事件整体的开始，汇点 表示事件整体结束<a class="headerlink" href="#_727" title="Permanent link">&para;</a></h6>
<h6 id="_728">其他的点则表示一个活动的结束，同时也表示另外一个活动的开始<a class="headerlink" href="#_728" title="Permanent link">&para;</a></h6>
<h6 id="_729">关 表示时间，而 表示活动， 表示活动所需要的时间<a class="headerlink" href="#_729" title="Permanent link">&para;</a></h6>
<h6 id="_730">令 表示 的最早开始时间，即 时间之前的活动必须完成， 才能开始<a class="headerlink" href="#_730" title="Permanent link">&para;</a></h6>
<h6 id="_731">即 为的直接前驱<a class="headerlink" href="#_731" title="Permanent link">&para;</a></h6>
<h6 id="_732">令 表示 的最迟开始时间 即 的后继点 需要为 留出时间 为 的直接前驱<a class="headerlink" href="#_732" title="Permanent link">&para;</a></h6>
<h6 id="_733">若已知 ，则<a class="headerlink" href="#_733" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-352-1">1</a></span>
<span class="normal"><a href="#__codelineno-352-2">2</a></span>
<span class="normal"><a href="#__codelineno-352-3">3</a></span>
<span class="normal"><a href="#__codelineno-352-4">4</a></span>
<span class="normal"><a href="#__codelineno-352-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-352-1" name="__codelineno-352-1"></a>} else {
<a id="__codelineno-352-2" name="__codelineno-352-2"></a>free(indegree);
<a id="__codelineno-352-3" name="__codelineno-352-3"></a>return topo;
<a id="__codelineno-352-4" name="__codelineno-352-4"></a>}
<a id="__codelineno-352-5" name="__codelineno-352-5"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-353-1">1</a></span>
<span class="normal"><a href="#__codelineno-353-2">2</a></span>
<span class="normal"><a href="#__codelineno-353-3">3</a></span>
<span class="normal"><a href="#__codelineno-353-4">4</a></span>
<span class="normal"><a href="#__codelineno-353-5">5</a></span>
<span class="normal"><a href="#__codelineno-353-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-353-1" name="__codelineno-353-1"></a>void TopoSort(ALGraph *G) {
<a id="__codelineno-353-2" name="__codelineno-353-2"></a>int *topo = Get_Topo(G);
<a id="__codelineno-353-3" name="__codelineno-353-3"></a>if (!topo) { //如果为NULL
<a id="__codelineno-353-4" name="__codelineno-353-4"></a>printf(&quot;The Graph is not AVO!\n&quot;);
<a id="__codelineno-353-5" name="__codelineno-353-5"></a>return;
<a id="__codelineno-353-6" name="__codelineno-353-6"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-354-1">1</a></span>
<span class="normal"><a href="#__codelineno-354-2">2</a></span>
<span class="normal"><a href="#__codelineno-354-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-354-1" name="__codelineno-354-1"></a>for (int i = 0 ; i &lt; G-&gt;vertices; ++i) {
<a id="__codelineno-354-2" name="__codelineno-354-2"></a>printf(&quot;%c &quot;, G-&gt;vertex[topo[i]].name);
<a id="__codelineno-354-3" name="__codelineno-354-3"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-355-1">1</a></span>
<span class="normal"><a href="#__codelineno-355-2">2</a></span>
<span class="normal"><a href="#__codelineno-355-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-355-1" name="__codelineno-355-1"></a>free(topo); //注意释放堆区数据
<a id="__codelineno-355-2" name="__codelineno-355-2"></a>topo = NULL;
<a id="__codelineno-355-3" name="__codelineno-355-3"></a>}
</code></pre></div></td></tr></table></div></p>
<h6 id="_734">活动时间 表示边 的<a class="headerlink" href="#_734" title="Permanent link">&para;</a></h6>
<h6 id="_735">表示， 发生的最早时间，只有 发生了， 才能发生<a class="headerlink" href="#_735" title="Permanent link">&para;</a></h6>
<h6 id="_736">所以<a class="headerlink" href="#_736" title="Permanent link">&para;</a></h6>
<h6 id="_737">注意<a class="headerlink" href="#_737" title="Permanent link">&para;</a></h6>
<h6 id="_738">，即源点 的最早发生时间为<a class="headerlink" href="#_738" title="Permanent link">&para;</a></h6>
<h6 id="_739">即汇点 的发生最早时间 的最迟时间<a class="headerlink" href="#_739" title="Permanent link">&para;</a></h6>
<h6 id="_740">由此可知 从源点开始向前递归 从后向前递归<a class="headerlink" href="#_740" title="Permanent link">&para;</a></h6>
<h6 id="_741">表示 的最迟发生时间<a class="headerlink" href="#_741" title="Permanent link">&para;</a></h6>
<h6 id="_742">若 则说明活动 没有缓冲时间，为关键路径<a class="headerlink" href="#_742" title="Permanent link">&para;</a></h6>
<h6 id="_743">如果 这说明活动 有 时间可以调整<a class="headerlink" href="#_743" title="Permanent link">&para;</a></h6>
<h6 id="_744">代码实现<a class="headerlink" href="#_744" title="Permanent link">&para;</a></h6>
<h6 id="_745">实现下图<a class="headerlink" href="#_745" title="Permanent link">&para;</a></h6>
<h6 id="_746">邻接表<a class="headerlink" href="#_746" title="Permanent link">&para;</a></h6>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-356-1">1</a></span>
<span class="normal"><a href="#__codelineno-356-2">2</a></span>
<span class="normal"><a href="#__codelineno-356-3">3</a></span>
<span class="normal"><a href="#__codelineno-356-4">4</a></span>
<span class="normal"><a href="#__codelineno-356-5">5</a></span>
<span class="normal"><a href="#__codelineno-356-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-356-1" name="__codelineno-356-1"></a>void CriticalPath(ALGraph *G) {
<a id="__codelineno-356-2" name="__codelineno-356-2"></a>int *topo = Get_Topo(G);
<a id="__codelineno-356-3" name="__codelineno-356-3"></a>if (!topo) {
<a id="__codelineno-356-4" name="__codelineno-356-4"></a>printf(&quot;The Graph is not AVO&quot;);
<a id="__codelineno-356-5" name="__codelineno-356-5"></a>return;
<a id="__codelineno-356-6" name="__codelineno-356-6"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-357-1">1</a></span>
<span class="normal"><a href="#__codelineno-357-2">2</a></span>
<span class="normal"><a href="#__codelineno-357-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-357-1" name="__codelineno-357-1"></a>int n = G-&gt;vertices;
<a id="__codelineno-357-2" name="__codelineno-357-2"></a>int ve[n], vl[n]; // ve表示i顶点的最早发生时间，vl表示i顶点的最晚发生时间
<a id="__codelineno-357-3" name="__codelineno-357-3"></a>memset(ve, 0 , sizeof(int) * n); //初始化为 0
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-358-1">1</a></span>
<span class="normal"><a href="#__codelineno-358-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-358-1" name="__codelineno-358-1"></a>for (int i = 0 ; i &lt; n; ++i) {
<a id="__codelineno-358-2" name="__codelineno-358-2"></a>int k = topo[i]; //按照拓扑序列遍历各点的邻接点
</code></pre></div></td></tr></table></div></p>
<h3 id="_747">图的头文件<a class="headerlink" href="#_747" title="Permanent link">&para;</a></h3>
<h4 id="define_graphh_1">define_Graph.h<a class="headerlink" href="#define_graphh_1" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-359-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-359-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-359-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-359-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-359-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-359-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-359-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-359-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-359-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-359-10">10</a></span>
<span class="normal"><a href="#__codelineno-359-11">11</a></span>
<span class="normal"><a href="#__codelineno-359-12">12</a></span>
<span class="normal"><a href="#__codelineno-359-13">13</a></span>
<span class="normal"><a href="#__codelineno-359-14">14</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-359-1" name="__codelineno-359-1"></a>EdgeNode *p = G-&gt;vertex[k].first;
<a id="__codelineno-359-2" name="__codelineno-359-2"></a>while (p) {
<a id="__codelineno-359-3" name="__codelineno-359-3"></a>if (ve[p-&gt;adjvertex] &lt; ve[k] + p-&gt;weight) //求出最大值
<a id="__codelineno-359-4" name="__codelineno-359-4"></a>ve[p-&gt;adjvertex] = ve[k] + p-&gt;weight;
<a id="__codelineno-359-5" name="__codelineno-359-5"></a>p = p-&gt;next; //接着判断下一个邻接点
<a id="__codelineno-359-6" name="__codelineno-359-6"></a>}
<a id="__codelineno-359-7" name="__codelineno-359-7"></a>}
<a id="__codelineno-359-8" name="__codelineno-359-8"></a>//把所有的顶点的最晚发生时间初始化为汇点的最晚发生时间
<a id="__codelineno-359-9" name="__codelineno-359-9"></a>for (int i = 0 ; i &lt; n; ++i)
<a id="__codelineno-359-10" name="__codelineno-359-10"></a>vl[i] = ve[topo[n - 1 ]]; // topo[n-1]的ve是最大的，为下面求vl最小值做准备
<a id="__codelineno-359-11" name="__codelineno-359-11"></a>//--------------------------------------------
<a id="__codelineno-359-12" name="__codelineno-359-12"></a>for (int i = n - 1 ; i &gt;= 0 ; --i) {
<a id="__codelineno-359-13" name="__codelineno-359-13"></a>//从汇点从后向前遍历拓扑序列
<a id="__codelineno-359-14" name="__codelineno-359-14"></a>int k = topo[i];
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-360-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-360-1" name="__codelineno-360-1"></a>EdgeNode *p = G-&gt;vertex[k].first;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-361-1">1</a></span>
<span class="normal"><a href="#__codelineno-361-2">2</a></span>
<span class="normal"><a href="#__codelineno-361-3">3</a></span>
<span class="normal"><a href="#__codelineno-361-4">4</a></span>
<span class="normal"><a href="#__codelineno-361-5">5</a></span>
<span class="normal"><a href="#__codelineno-361-6">6</a></span>
<span class="normal"><a href="#__codelineno-361-7">7</a></span>
<span class="normal"><a href="#__codelineno-361-8">8</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-361-1" name="__codelineno-361-1"></a>while (p) {
<a id="__codelineno-361-2" name="__codelineno-361-2"></a>if (vl[k] &gt; vl[p-&gt;adjvertex] - p-&gt;weight)
<a id="__codelineno-361-3" name="__codelineno-361-3"></a>vl[k] = vl[p-&gt;adjvertex] - p-&gt;weight; //要vl的最小值
<a id="__codelineno-361-4" name="__codelineno-361-4"></a>p = p-&gt;next;
<a id="__codelineno-361-5" name="__codelineno-361-5"></a>}
<a id="__codelineno-361-6" name="__codelineno-361-6"></a>}
<a id="__codelineno-361-7" name="__codelineno-361-7"></a>//------------------------------------------
<a id="__codelineno-361-8" name="__codelineno-361-8"></a>for (int i = 0 ; i &lt; n; ++i) {
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-362-1">1</a></span>
<span class="normal"><a href="#__codelineno-362-2">2</a></span>
<span class="normal"><a href="#__codelineno-362-3">3</a></span>
<span class="normal"><a href="#__codelineno-362-4">4</a></span>
<span class="normal"><a href="#__codelineno-362-5">5</a></span>
<span class="normal"><a href="#__codelineno-362-6">6</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-362-1" name="__codelineno-362-1"></a>EdgeNode *p = G-&gt;vertex[i].first;
<a id="__codelineno-362-2" name="__codelineno-362-2"></a>while (p) {
<a id="__codelineno-362-3" name="__codelineno-362-3"></a>int j = p-&gt;adjvertex;
<a id="__codelineno-362-4" name="__codelineno-362-4"></a>int e = ve[i]; // 活动的最发生时间 = 该边的前驱节点i的最早发生时间
<a id="__codelineno-362-5" name="__codelineno-362-5"></a>//活动的最晚发生时间=该边前驱节点的最晚发生时间-该边的weight
<a id="__codelineno-362-6" name="__codelineno-362-6"></a>int l = vl[j] - p-&gt;weight;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-363-1">1</a></span>
<span class="normal"><a href="#__codelineno-363-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-363-1" name="__codelineno-363-1"></a>if (e == l) //如果等于即为关键路径
<a id="__codelineno-363-2" name="__codelineno-363-2"></a>printf(&quot;%c-&gt;%c &quot;, G-&gt;vertex[i].name, G-&gt;vertex[j].name);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-364-1">1</a></span>
<span class="normal"><a href="#__codelineno-364-2">2</a></span>
<span class="normal"><a href="#__codelineno-364-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-364-1" name="__codelineno-364-1"></a>p = p-&gt;next;
<a id="__codelineno-364-2" name="__codelineno-364-2"></a>}
<a id="__codelineno-364-3" name="__codelineno-364-3"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-365-1">1</a></span>
<span class="normal"><a href="#__codelineno-365-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-365-1" name="__codelineno-365-1"></a>free(topo);
<a id="__codelineno-365-2" name="__codelineno-365-2"></a>}
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-366-1">1</a></span>
<span class="normal"><a href="#__codelineno-366-2">2</a></span>
<span class="normal"><a href="#__codelineno-366-3">3</a></span>
<span class="normal"><a href="#__codelineno-366-4">4</a></span>
<span class="normal"><a href="#__codelineno-366-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-366-1" name="__codelineno-366-1"></a>#include &quot;Queue.h&quot;
<a id="__codelineno-366-2" name="__codelineno-366-2"></a>#include &quot;Stack.h&quot;
<a id="__codelineno-366-3" name="__codelineno-366-3"></a>#include &lt;stdio.h&gt;
<a id="__codelineno-366-4" name="__codelineno-366-4"></a>#include &lt;stdlib.h&gt;
<a id="__codelineno-366-5" name="__codelineno-366-5"></a>#include &lt;string.h&gt;
</code></pre></div></td></tr></table></div></p>
<h4 id="amgraphh_1">AMGraph.h<a class="headerlink" href="#amgraphh_1" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-367-1">1</a></span>
<span class="normal"><a href="#__codelineno-367-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-367-1" name="__codelineno-367-1"></a>#define MAXWEIGHT 99999 //最大权值
<a id="__codelineno-367-2" name="__codelineno-367-2"></a>#define MAXVERTEX 20 //最大定点数
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-368-1">1</a></span>
<span class="normal"><a href="#__codelineno-368-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-368-1" name="__codelineno-368-1"></a>typedef char VertexType; //顶点用字符表示
<a id="__codelineno-368-2" name="__codelineno-368-2"></a>typedef int MatrixType; //矩阵类型
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-369-1">1</a></span>
<span class="normal"><a href="#__codelineno-369-2">2</a></span>
<span class="normal"><a href="#__codelineno-369-3">3</a></span>
<span class="normal"><a href="#__codelineno-369-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-369-1" name="__codelineno-369-1"></a>struct Uset {
<a id="__codelineno-369-2" name="__codelineno-369-2"></a>int adjvertex; //下标为i的点的邻接点
<a id="__codelineno-369-3" name="__codelineno-369-3"></a>int weight; //当前权值
<a id="__codelineno-369-4" name="__codelineno-369-4"></a>};
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-370-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-370-1" name="__codelineno-370-1"></a>int Min_Uset(Uset *U, int n);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-371-1">1</a></span>
<span class="normal"><a href="#__codelineno-371-2">2</a></span>
<span class="normal"><a href="#__codelineno-371-3">3</a></span>
<span class="normal"><a href="#__codelineno-371-4">4</a></span>
<span class="normal"><a href="#__codelineno-371-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-371-1" name="__codelineno-371-1"></a>struct Eset {
<a id="__codelineno-371-2" name="__codelineno-371-2"></a>int start;
<a id="__codelineno-371-3" name="__codelineno-371-3"></a>int end;
<a id="__codelineno-371-4" name="__codelineno-371-4"></a>int weight;
<a id="__codelineno-371-5" name="__codelineno-371-5"></a>};
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-372-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-372-1" name="__codelineno-372-1"></a>void Sort_Eset(Eset *E, int length);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-373-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-373-1" name="__codelineno-373-1"></a>#include &quot;define_Graph.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-374-1">1</a></span>
<span class="normal"><a href="#__codelineno-374-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-374-1" name="__codelineno-374-1"></a>#ifndef __GRAPH_H
<a id="__codelineno-374-2" name="__codelineno-374-2"></a>#define __GRAPH_H
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-375-1">1</a></span>
<span class="normal"><a href="#__codelineno-375-2">2</a></span>
<span class="normal"><a href="#__codelineno-375-3">3</a></span>
<span class="normal"><a href="#__codelineno-375-4">4</a></span>
<span class="normal"><a href="#__codelineno-375-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-375-1" name="__codelineno-375-1"></a>typedef struct __AMGraph {
<a id="__codelineno-375-2" name="__codelineno-375-2"></a>VertexType vertex[MAXVERTEX];
<a id="__codelineno-375-3" name="__codelineno-375-3"></a>MatrixType edge[MAXVERTEX][MAXVERTEX];
<a id="__codelineno-375-4" name="__codelineno-375-4"></a>int vertices, edges;
<a id="__codelineno-375-5" name="__codelineno-375-5"></a>} AMGraph;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-376-1">1</a></span>
<span class="normal"><a href="#__codelineno-376-2">2</a></span>
<span class="normal"><a href="#__codelineno-376-3">3</a></span>
<span class="normal"><a href="#__codelineno-376-4">4</a></span>
<span class="normal"><a href="#__codelineno-376-5">5</a></span>
<span class="normal"><a href="#__codelineno-376-6">6</a></span>
<span class="normal"><a href="#__codelineno-376-7">7</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-376-1" name="__codelineno-376-1"></a>int Locate_vertex(AMGraph *G, char v);
<a id="__codelineno-376-2" name="__codelineno-376-2"></a>void print_Matrix_weighted(const AMGraph *G);
<a id="__codelineno-376-3" name="__codelineno-376-3"></a>void print_Matrix_unweighted(const AMGraph *G);
<a id="__codelineno-376-4" name="__codelineno-376-4"></a>void Creat_unAMGraph_unweightd(AMGraph *G);
<a id="__codelineno-376-5" name="__codelineno-376-5"></a>void Creat_unAMGraph_weightd(AMGraph *G);
<a id="__codelineno-376-6" name="__codelineno-376-6"></a>void Creat_AMGraph_weightd(AMGraph *G);
<a id="__codelineno-376-7" name="__codelineno-376-7"></a>void Creat_AMGraph_unweightd(AMGraph *G);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-377-1">1</a></span>
<span class="normal"><a href="#__codelineno-377-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-377-1" name="__codelineno-377-1"></a>void DFS_AM(AMGraph *G, int v, bool *visit);
<a id="__codelineno-377-2" name="__codelineno-377-2"></a>void DFS_AMGraph(AMGraph *G, VertexType v);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-378-1">1</a></span>
<span class="normal"><a href="#__codelineno-378-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-378-1" name="__codelineno-378-1"></a>void BFS_AM(AMGraph *G, int v, bool *visit);
<a id="__codelineno-378-2" name="__codelineno-378-2"></a>void BFS_AMGraph(AMGraph *G, VertexType v);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-379-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-379-1" name="__codelineno-379-1"></a>void MST_Prim(AMGraph *G, VertexType v);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-380-1">1</a></span>
<span class="normal"><a href="#__codelineno-380-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-380-1" name="__codelineno-380-1"></a>void InitEset(Eset *E, AMGraph *G);
<a id="__codelineno-380-2" name="__codelineno-380-2"></a>void MST_Krusal(AMGraph *G);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-381-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-381-1" name="__codelineno-381-1"></a>void ShortestPath(AMGraph *G, VertexType v);
</code></pre></div></td></tr></table></div></p>
<h4 id="algraphh_1">ALGraph.h<a class="headerlink" href="#algraphh_1" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-382-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-382-1" name="__codelineno-382-1"></a>void ShortestPath_Dijkstra(AMGraph *G, VertexType v);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-383-1">1</a></span>
<span class="normal"><a href="#__codelineno-383-2">2</a></span>
<span class="normal"><a href="#__codelineno-383-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-383-1" name="__codelineno-383-1"></a>void ShortestPath(AMGraph *G, int v, int *path);
<a id="__codelineno-383-2" name="__codelineno-383-2"></a>void ShortestPath_Dijkstra(AMGraph *G, VertexType v);
<a id="__codelineno-383-3" name="__codelineno-383-3"></a>void print_path(AMGraph *G, int *path, int start, int end);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-384-1">1</a></span>
<span class="normal"><a href="#__codelineno-384-2">2</a></span>
<span class="normal"><a href="#__codelineno-384-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-384-1" name="__codelineno-384-1"></a>int **Path_Matrix(AMGraph *G);
<a id="__codelineno-384-2" name="__codelineno-384-2"></a>void ShortestPath_Floyd(AMGraph *G, VertexType v1, VertexType v2);
<a id="__codelineno-384-3" name="__codelineno-384-3"></a>#endif
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-385-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-385-1" name="__codelineno-385-1"></a>#include &quot;define_Graph.h&quot;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-386-1">1</a></span>
<span class="normal"><a href="#__codelineno-386-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-386-1" name="__codelineno-386-1"></a>#ifndef __ALGRAPH_H
<a id="__codelineno-386-2" name="__codelineno-386-2"></a>#define __ALGRAPH_H
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-387-1">1</a></span>
<span class="normal"><a href="#__codelineno-387-2">2</a></span>
<span class="normal"><a href="#__codelineno-387-3">3</a></span>
<span class="normal"><a href="#__codelineno-387-4">4</a></span>
<span class="normal"><a href="#__codelineno-387-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-387-1" name="__codelineno-387-1"></a>typedef struct __EdgeNode {
<a id="__codelineno-387-2" name="__codelineno-387-2"></a>int adjvertex;
<a id="__codelineno-387-3" name="__codelineno-387-3"></a>__EdgeNode *next;
<a id="__codelineno-387-4" name="__codelineno-387-4"></a>int weight;
<a id="__codelineno-387-5" name="__codelineno-387-5"></a>} EdgeNode;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-388-1">1</a></span>
<span class="normal"><a href="#__codelineno-388-2">2</a></span>
<span class="normal"><a href="#__codelineno-388-3">3</a></span>
<span class="normal"><a href="#__codelineno-388-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-388-1" name="__codelineno-388-1"></a>typedef struct __ALGNode {
<a id="__codelineno-388-2" name="__codelineno-388-2"></a>VertexType name;
<a id="__codelineno-388-3" name="__codelineno-388-3"></a>EdgeNode *first;
<a id="__codelineno-388-4" name="__codelineno-388-4"></a>} ALGNode;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-389-1">1</a></span>
<span class="normal"><a href="#__codelineno-389-2">2</a></span>
<span class="normal"><a href="#__codelineno-389-3">3</a></span>
<span class="normal"><a href="#__codelineno-389-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-389-1" name="__codelineno-389-1"></a>typedef struct __ALGraph {
<a id="__codelineno-389-2" name="__codelineno-389-2"></a>ALGNode vertex[MAXVERTEX];
<a id="__codelineno-389-3" name="__codelineno-389-3"></a>int edges, vertices;
<a id="__codelineno-389-4" name="__codelineno-389-4"></a>} ALGraph;
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-390-1">1</a></span>
<span class="normal"><a href="#__codelineno-390-2">2</a></span>
<span class="normal"><a href="#__codelineno-390-3">3</a></span>
<span class="normal"><a href="#__codelineno-390-4">4</a></span>
<span class="normal"><a href="#__codelineno-390-5">5</a></span>
<span class="normal"><a href="#__codelineno-390-6">6</a></span>
<span class="normal"><a href="#__codelineno-390-7">7</a></span>
<span class="normal"><a href="#__codelineno-390-8">8</a></span>
<span class="normal"><a href="#__codelineno-390-9">9</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-390-1" name="__codelineno-390-1"></a>int Locate_vertex(const ALGraph *G, VertexType v);
<a id="__codelineno-390-2" name="__codelineno-390-2"></a>void print_ALG_unweighted(const ALGraph *G);
<a id="__codelineno-390-3" name="__codelineno-390-3"></a>void print_ALG_weighted(const ALGraph *G);
<a id="__codelineno-390-4" name="__codelineno-390-4"></a>void Creat_unALGraph_unweighted(ALGraph *G);
<a id="__codelineno-390-5" name="__codelineno-390-5"></a>void Creat_ALGraph_unweighted(ALGraph *G);
<a id="__codelineno-390-6" name="__codelineno-390-6"></a>void Creat_unALGraph_weighted(ALGraph *G);
<a id="__codelineno-390-7" name="__codelineno-390-7"></a>void Creat_ALGraph_weighted(ALGraph *G);
<a id="__codelineno-390-8" name="__codelineno-390-8"></a>void DFS_AL(ALGraph *G, int v, bool *visit);
<a id="__codelineno-390-9" name="__codelineno-390-9"></a>void DFS_ALGraph(ALGraph *G, VertexType v);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-391-1">1</a></span>
<span class="normal"><a href="#__codelineno-391-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-391-1" name="__codelineno-391-1"></a>void BFS_AL(ALGraph *G, int v, bool *visit);
<a id="__codelineno-391-2" name="__codelineno-391-2"></a>void BFS_ALGraph(ALGraph *G, VertexType v);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-392-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-392-1" name="__codelineno-392-1"></a>void MST_Prime(ALGraph *G, VertexType v);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-393-1">1</a></span>
<span class="normal"><a href="#__codelineno-393-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-393-1" name="__codelineno-393-1"></a>void InitEset(Eset *E, ALGraph *G);
<a id="__codelineno-393-2" name="__codelineno-393-2"></a>void MST_Krusal(ALGraph *G);
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-394-1">1</a></span>
<span class="normal"><a href="#__codelineno-394-2">2</a></span>
<span class="normal"><a href="#__codelineno-394-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-394-1" name="__codelineno-394-1"></a>void InDegree(ALGraph *G, int *a);
<a id="__codelineno-394-2" name="__codelineno-394-2"></a>int *Get_Topo(ALGraph *G);
<a id="__codelineno-394-3" name="__codelineno-394-3"></a>void TopoSort(ALGraph *G);
</code></pre></div></td></tr></table></div></p>
<p>void CriticalPath(ALGraph *G);</p>
<h1 id="endif">endif<a class="headerlink" href="#endif" title="Permanent link">&para;</a></h1>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2023 by CMQ233
    </div>
  
  
</div>
      
        <div class="md-social">
  
    
    
    
    
      
      
    
    <a href="https://github.com/PCDL233" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://space.bilibili.com/107669273?spm_id_from=333.1007.0.0" target="_blank" rel="noopener" title="space.bilibili.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M488.6 104.1c16.7 18.1 24.4 39.7 23.3 65.7v202.4c-.4 26.4-9.2 48.1-26.5 65.1-17.2 17-39.1 25.9-65.5 26.7H92.02c-26.45-.8-48.21-9.8-65.28-27.2C9.682 419.4.767 396.5 0 368.2V169.8c.767-26 9.682-47.6 26.74-65.7C43.81 87.75 65.57 78.77 92.02 78h29.38L96.05 52.19c-5.75-5.73-8.63-13-8.63-21.79 0-8.8 2.88-16.06 8.63-21.797C101.8 2.868 109.1 0 117.9 0s16.1 2.868 21.9 8.603L213.1 78h88l74.5-69.397C381.7 2.868 389.2 0 398 0c8.8 0 16.1 2.868 21.9 8.603 5.7 5.737 8.6 12.997 8.6 21.797 0 8.79-2.9 16.06-8.6 21.79L394.6 78h29.3c26.4.77 48 9.75 64.7 26.1zm-38.8 69.7c-.4-9.6-3.7-17.4-10.7-23.5-5.2-6.1-14-9.4-22.7-9.8H96.05c-9.59.4-17.45 3.7-23.58 9.8-6.14 6.1-9.4 13.9-9.78 23.5v194.4c0 9.2 3.26 17 9.78 23.5s14.38 9.8 23.58 9.8H416.4c9.2 0 17-3.3 23.3-9.8 6.3-6.5 9.7-14.3 10.1-23.5V173.8zm-264.3 42.7c6.3 6.3 9.7 14.1 10.1 23.2V273c-.4 9.2-3.7 16.9-9.8 23.2-6.2 6.3-14 9.5-23.6 9.5-9.6 0-17.5-3.2-23.6-9.5-6.1-6.3-9.4-14-9.8-23.2v-33.3c.4-9.1 3.8-16.9 10.1-23.2 6.3-6.3 13.2-9.6 23.3-10 9.2.4 17 3.7 23.3 10zm191.5 0c6.3 6.3 9.7 14.1 10.1 23.2V273c-.4 9.2-3.7 16.9-9.8 23.2-6.1 6.3-14 9.5-23.6 9.5-9.6 0-17.4-3.2-23.6-9.5-7-6.3-9.4-14-9.7-23.2v-33.3c.3-9.1 3.7-16.9 10-23.2 6.3-6.3 14.1-9.6 23.3-10 9.2.4 17 3.7 23.3 10z"/></svg>
    </a>
  
    
    
    
    
    <a href="mailto:<2815834616@qq.com>" target="_blank" rel="noopener" title="" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M498.1 5.6c10.1 7 15.4 19.1 13.5 31.2l-64 416c-1.5 9.7-7.4 18.2-16 23s-18.9 5.4-28 1.6L284 427.7l-68.5 74.1c-8.9 9.7-22.9 12.9-35.2 8.1S160 493.2 160 480v-83.6c0-4 1.5-7.8 4.2-10.7l167.6-182.9c5.8-6.3 5.6-16-.4-22s-15.7-6.4-22-.7L106 360.8l-88.3-44.2C7.1 311.3.3 300.7 0 288.9s5.9-22.8 16.1-28.7l448-256c10.7-6.1 23.9-5.5 34 1.4z"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.instant", "announce.dismiss", "navigation.tracking", "navigation.tabs", "search.suggest", "search.highlight", "navigation.expand", "navigation.indexes", "search.share"], "search": "../../assets/javascripts/workers/search.208ed371.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.fc8c2696.min.js"></script>
      
        <script src="../../js/extra.js"></script>
      
        <script src="../../js/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>